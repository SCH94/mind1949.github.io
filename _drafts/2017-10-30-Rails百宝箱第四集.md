---
layout: post
title: "Rails百宝箱第四集"
date: 2017-10-30
tags:
    Rails
    教材
---

#Rails百宝箱第四季

| 21. 多档案上传                                |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  21-1 上传单张图片](https://fullstack.xinshengdaxue.com/posts/1175) |                                          |
| [**  21-2 上传多档](https://fullstack.xinshengdaxue.com/posts/1176) |                                          |
| [**  21-3 上传多档案(使用额外Model)](https://fullstack.xinshengdaxue.com/posts/1177) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1177#task) |

| 22. 图表资料分析                               |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  22-1 前言和 Chart.js 安装](https://fullstack.xinshengdaxue.com/posts/1178) |                                          |
| [**  22-2 分析不同票种的报名人数](https://fullstack.xinshengdaxue.com/posts/1179) |                                          |
| [**  22-3 分析票种的总金额](https://fullstack.xinshengdaxue.com/posts/1180) |                                          |
| [**  22-4 分析票种的报名人数，并根据状态分类](https://fullstack.xinshengdaxue.com/posts/1181) |                                          |
| [**  22-5 分析每日报名人数，并根据状态分类](https://fullstack.xinshengdaxue.com/posts/1182) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1182#task) |

| 23. 用户权限控管                               |      |
| ---------------------------------------- | ---- |
| [**  23-1 增加后台管理员权限](https://fullstack.xinshengdaxue.com/posts/1183) |      |
| [**  23-2 增加其他角色](https://fullstack.xinshengdaxue.com/posts/1184) |      |
| [**  23-3 编辑用户角色](https://fullstack.xinshengdaxue.com/posts/1185) |      |
| [**  23-4 权限重构](https://fullstack.xinshengdaxue.com/posts/1186) |      |
| [**  23-5 补充: pundit 和 cancancan](https://fullstack.xinshengdaxue.com/posts/1187) |      |

| 24. HTML E-mail 寄送                       |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  24-1 安装 letter_opener](https://fullstack.xinshengdaxue.com/posts/1188) |                                          |
| [**  24-2 寄送报名完成的 E-mail](https://fullstack.xinshengdaxue.com/posts/1189) |                                          |
| [**  24-3 HTML E-mail](https://fullstack.xinshengdaxue.com/posts/1190) |                                          |
| [**  24-4 E-mail CSS 样式问题：安装 premailer](https://fullstack.xinshengdaxue.com/posts/1191) |                                          |
| [**  24-5 HTML E-mail 套版](https://fullstack.xinshengdaxue.com/posts/1192) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1192#task) |

| 25. 数据汇入                                 |      |
| ---------------------------------------- | ---- |
| [**  25-1 解析 CSV 档案 (Rake)](https://fullstack.xinshengdaxue.com/posts/1193) |      |
| [**  25-2 解析 CSV 档案 (Web UI 接口)](https://fullstack.xinshengdaxue.com/posts/1194) |      |
| [**  25-3 把汇入档案存下来纪录过程](https://fullstack.xinshengdaxue.com/posts/1195) |      |

| 26. 异步处理任务                               |      |
| ---------------------------------------- | ---- |
| [**  26-1 前言和安装 sidekiq](https://fullstack.xinshengdaxue.com/posts/1196) |      |
| [**  26-2 异步汇入](https://fullstack.xinshengdaxue.com/posts/1197) |      |
| [**  26-3 Sidekiq 管理 UI](https://fullstack.xinshengdaxue.com/posts/1198) |      |
| [**  26-4 异步汇出](https://fullstack.xinshengdaxue.com/posts/1199) |      |
| [**  26-5 报名15分钟内没完成自动取消](https://fullstack.xinshengdaxue.com/posts/1200) |      |
| [**  异步 E-mail 寄信](https://fullstack.xinshengdaxue.com/posts/1201) |      |

# 21-1 上传单张图片

这一章介绍上传文档，示范的情境有：

1. Event 活动可以上传一张 Logo 图片
2. Event 活动可以上传多张 Images 图片
3. Events 活动可以上传多个附加文档，每个文档有各自的描述说明

在 Rails 中上传和存储文档，最常见使用的 gem 是 [carrierwave](https://github.com/carrierwaveuploader/carrierwave) 和 [paperclip](https://github.com/thoughtbot/paperclip)，这里我们使用 carrierwave。

接下来我来实作为 Event 活动上传一张 Logo 图片：

编辑 Gemfile

Gemfile

```
+  gem 'carrierwave'
+  gem "mini_magick"
```

执行 `bundle`，重启服务器

执行 `rails g migration add_logo_to_events logo:string`，这会产生一个 migration 内容是为 events 增加一个 logo 字段。

执行 `rake db:migrate`

执行 `rails g uploader EventLogo`

编辑 `app/uploaders/event_logo_uploader.rb`

event_logo_uploader.rb

```
  class EventLogoUploader < CarrierWave::Uploader::Base

+   include CarrierWave::MiniMagick

+   version :thumb do
+     process resize_to_fit: [50, 50]
+   end

  end
```

编辑 `app/models/event.rb`，把 carrierwave 的 Uploader 挂载上去。

app/models/event.rb

```
  class Event < ApplicationRecord
+   mount_uploader :logo, EventLogoUploader
```

编辑 `app/views/admin/events/_form.html.erb` 加上文档上传的输入框。如果已经有上传过了，则多显示删除的 checkbox。

```
+  <div class="form-group">
+    <%= f.label :logo %>
+    <%= f.file_field :logo, :class => "form-control" %>
+    <% if f.object.logo.present? %>
+      <label>
+        <%= f.check_box :remove_logo %> 删除图档
+      </label>
+      <%= link_to f.object.logo.filename, f.object.logo.url, :target => "_blank" %>
+    <% end %>
+  </div>

   <div class="form-group">
     <%= f.label :description %>
```

编辑 `app/controllers/admin/events_controller.rb` 加上 `:logo` 和 `:remove_logo` 到 event_params

app/controllers/admin/events_controller.rb

```
  def event_params
-    params.require(:event).permit(:name, :description, :friendly_id, :status, :category_id, :tickets_attributes => [:id, :name, :description, :price, :_destroy])
+    params.require(:event).permit(:name, :logo, :remove_logo, :description, :friendly_id, :status, :category_id, :tickets_attributes => [:id, :name, :description, :price, :_destroy])
  end
```



[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Mr4XqYL1Shm9ijTbSFDv_21-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Mr4XqYL1Shm9ijTbSFDv_21-1.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/QsU4DWerSTeeduIK79As_21-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/QsU4DWerSTeeduIK79As_21-2.png)

编辑前台的活动页面 `app/views/events/show.html.erb`，把图片显示出来

app/views/events/show.html.erb

```
+ <% if @event.logo.present? %>
+   <%= link_to image_tag(@event.logo.url(:thumb)), @event.logo.url, :target => "_blank" %>
+ <% end %>

  <h1><%= @event.name %></h1>
```

最后，上传的文档不需要 git commit，所以请编辑 `.gitignore` 忽略掉 `public/uploads` 这个目录。

.gitignore

```
  # Ignore Byebug command history file.
  .byebug_history
+ /public/uploads/*
```

这样就完成了，请在后台上传图片，然后到前台活动页就可看到了。

# 21-2 上传多档

情境：Event 活动可以上传多张 Images 图片

执行 `rails g migration add_images_to_events images:string`

执行 `rake db:migrate`

执行 `rails g uploader EventImage`

编辑 `app/uploaders/event_image_uploader.rb`

app/uploaders/event_image_uploader.rb

```
  class EventImageUploader < CarrierWave::Uploader::Base

+   include CarrierWave::MiniMagick

+   version :small do
+     process resize_to_fit: [250, 250]
+   end

  end
```

编辑 `app/models/event.rb`，把 carrierwave 的 Uploader 挂载上去：

app/models/event.rb

```
  class Event < ApplicationRecord
    mount_uploader :logo, EventLogoUploader
+   mount_uploaders :images, EventImageUploader
+   serialize :images, JSON
```

编辑 `app/views/admin/events/_form.html.erb` 加上文档上传的输入框，注意到因为要支援多档上传，多了一个 `:multiple => true` 参数。

app/views/admin/events/_form.html.erb_

```
+  <div class="form-group">
+    <%= f.label :images %>
+    <%= f.file_field :images, :multiple => true, :class => "form-control" %>
+    <% if f.object.images.present? %>
+      <label>
+        <%= f.check_box :remove_images %> 删除图档
+      </label>
+      <% f.object.images.each do |i| %>
+        <%= link_to i.filename, i.url, :target => "_blank" %>
+      <% end %>
+    <% end %>
+  </div>

   <div class="form-group">
     <%= f.label :description %>
```

编辑 `app/controllers/admin/events_controller.rb` 加上 `:remove_images` 和 `:images => []` 到 event_params

app/controllers/admin/events_controller.rb

```
  def event_params
-    params.require(:event).permit(:name, :logo, :remove_logo, :description, :friendly_id, :status, :category_id, :tickets_attributes => [:id, :name, :description, :price, :_destroy])
+    params.require(:event).permit(:name, :logo, :remove_logo, :remove_images, :description, :friendly_id, :status, :category_id, :images => [], :tickets_attributes => [:id, :name, :description, :price, :_destroy])

  end
```

> 小心 `:images => []` 要放在最后，因为默认的 Hash 哈希参数都是放在参数最后

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/WmS1lwxIRm64dZLRVwkQ_21-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/WmS1lwxIRm64dZLRVwkQ_21-3.png)

> 请用 command 点选文档进行多选

编辑前台的活动页面 `app/views/events/show.html.erb`，把图片显示出来。注意到因为是多档了，所以相比显示 Logo 多了 `.each` 循环。

app/views/events/show.html.erb

```
   <h2><%= @event.category.try(:name) %></h2>

+  <% if @event.images.present? %>
+    <% @event.images.each do |i| %>
+      <%= link_to image_tag(i.url(:small)), i.url %>
+    <% end %>
+  <% end %>
```

这样就完成了。

# 21-3 上传多档案(使用额外Model)

上一节的多档上传实作，我们用了 `serialize :images, JSON` 这会将多个文档的档名数组，转成 JSON 后存储在 `images` 字段之中，Rails 在读出来的时候，会自动转回数组。这一招让 carrierwave 很简单就可以支援多档上传，它把所有档名的数据都塞进同一个字段 `images`。

不过这种方法有几个缺点：

1. 无法增加每个文档编辑额外的描述或其他资讯
2. 无法为个别的文档进行更新：重传的时候，它会全部砍掉然后全部重新上传
3. 上传的 UI 需要用户知道用 Command 按键才能多选文档。因此如果是后台管理员还可以教育，前台一般用户可能会不知道如何使用。

因此，接下来我们示范如何让 Events 活动可以上传多个附加文档，每个文档有各自的描述说明。

作法是新增一个 EventAttachment model，然后让 Event has_many EventAttachment，其中每一笔 EventAttachment 就是一个附加文档。表单 UI 的部分则使用百宝箱10教过的 「嵌套表单(1-to-many」

执行 `rails g model event_attachment`，我们将让 Event has_many 这个 EventAttachment model，然后将 carrierwave 也挂载到这个 EventAttachment model 身上。

编辑 `201XXXXX025046_create_event_attachments.rb`

db/migrate/201XXXXX025046_create_event_attachments.rb

```
  class CreateEventAttachments < ActiveRecord::Migration[5.0]
    def change
      create_table :event_attachments do |t|
+       t.integer :event_id, :index => true
+       t.string :attachment
+       t.string :description
        t.timestamps
      end
    end
  end
```

执行 `rake db:migrate`

执行 `rails g uploader EventAttachment`

编辑 `app/models/event.rb`

app/models/event.rb

```
   has_many :tickets, :dependent => :destroy
   accepts_nested_attributes_for :tickets, :allow_destroy => true, :reject_if => :all_blank

+  has_many :attachments, :class_name => "EventAttachment", :dependent => :destroy
+  accepts_nested_attributes_for :attachments, :allow_destroy => true, :reject_if => :all_blank
```

编辑 `app/models/event_attachment.rb`

app/models/event_attachment.rb

```
  class EventAttachment < ApplicationRecord

+   mount_uploader :attachment, EventAttachmentUploader
+   belongs_to :event

  end
```

这样 models 的部分就好了。接着编辑后台表单 `app/views/admin/events/_form.html.erb`

app/views/admin/events/_form.html.erb_

```
+ <%= f.nested_fields_for :attachments do |ff| %>
+   <fieldset style="border-left: 5px solid #bbb; margin-bottom: 10px; padding: 10px;">
+     <legend>Attachment</legend>
+     <div class="form-group">
+       <%= ff.label :attachment %>
+       <%= ff.file_field :attachment, :class => "form-control" %>
+       <% if ff.object.attachment.present? %>
+         已上传档案 <%= link_to ff.object.description, ff.object.attachment.url, :target => "_blank" %>
+       <% end %>
+     </div>
+
+     <div class="form-group">
+       <%= ff.label :description %>
+       <%= ff.text_field :description, :class => "form-control" %>
+     </div>
+
+     <%= ff.remove_nested_fields_link "移除这个档案", :class => "btn btn-danger" %>
+   </fieldset>
+ <% end %>
+ <p class="text-right">
+   <%= f.add_nested_fields_link :attachments, "新增档案", :class => "btn btn-default" %>
+ </p>
+

 <%= f.nested_fields_for :tickets do |ff| %>
```

编辑 `app/controllers/admin/events_controller.rb`，如果该 @event 没有 attachments 的话，new 出来一笔好让表单可以显示一笔进行编辑，以及把 `attachments_attributes` 加进 `event_params`。

app/controllers/admin/events_controller.rb

```
   def new
     @event = Event.new
     @event.tickets.build
+    @event.attachments.build
   end

   # (略)

   def edit
     @event = Event.find_by_friendly_id!(params[:id])
     @event.tickets.build if @event.tickets.empty?
+    @event.attachments.build if @event.attachments.empty?
   end

   # (略)

   protected

   def event_params
-    params.require(:event).permit(:name, :logo, :remove_logo, :remove_images, :description, :friendly_id, :status, :category_id, :images => [], :tickets_attributes => [:id, :name, :description, :price, :_destroy])
+    params.require(:event).permit(:name, :logo, :remove_logo, :remove_images, :description, :friendly_id, :status, :category_id, :images => [], :tickets_attributes => [:id, :name, :description, :price, :_destroy], :attachments_attributes => [:id, :attachment, :description, :_destroy])
   end
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cqVoKjNVSByyDpZKl51b_21-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cqVoKjNVSByyDpZKl51b_21-5.png)

编辑前台 `app/views/events/show.html.erb`

app/views/events/show.html.erb

```
+  <ul>
+  <% @event.attachments.each do |a| %>
+    <li><%= link_to a.description, a.attachment.url %></li>
+  <% end %>
+  </ul>

  <%= sanitize @event.description %>
```

这样就完成了。请在后台上传一些文档和描述，然后到前台浏览看看。

#### 本节作业

##### [第四集作业](https://fullstack.xinshengdaxue.com/assignments/55)：[作业一](https://fullstack.xinshengdaxue.com/tasks/321)

已有 16 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/321/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/321)

请在任一个项目中，实作上传多档案。

# 22-1 前言和 Chart.js 安装

这一章介绍如何制作图表来分析报名资料，包括：

- 分析票种的报名人数
- 分析票种的总金额
- 分析票种的报名人数，并根据状态分类(报名尚未完成、报名成功)
- 分析每日报名人数，并根据状态分类

制作图表需要用到前端 JavaScript 套件，例如：

- [Chartkick](http://chartkick.com/) 这一套搭配 Rails 最简单，甚至不需要写 JavaScript 代码，有 Helper 可以使用
- [Chart.js](http://www.chartjs.org/) 这一套好用又漂亮，需要写 JavaScript
- [D3.js](https://d3js.org/) 这一套功能最强，是专业的数据可视化套件，但也比较复杂

我们将示范会使用 [Chart.js](http://www.chartjs.org/)，这也有[中文文档](http://www.bootcss.com/p/chart.js/)。

#### Chart.js 安装

Chart.js 有 [chart-js-rails gem](https://github.com/coderbydesign/chart-js-rails) 可以安装，但是因为只有后台报表那一页有用到，所以我们就不包进 asset pipeline 了，而是使用 CDN 让用户直接从 CDN 服务器下载回去。

在国内免费的 CDN 服务器 [BootCDN](http://www.bootcdn.cn/) 上可以找到 Chart.js，编辑 `app/views/admin/events/show.html.erb` 把该位置贴上去：

app/views/admin/events/show.html.erb

```
+  <script src="//cdn.bootcss.com/Chart.js/2.5.0/Chart.bundle.min.js"></script>

   <h1><%= @event.name %></h1>
```

这样用户进到这一页，就可以使用 Chart.js 了。

让我们试试看效果，再次编辑 `app/views/admin/events/show.html.erb`，贴上一段范例：

app/views/admin/events/show.html.erb

```
   <script src="//cdn.bootcss.com/Chart.js/2.5.0/Chart.bundle.min.js"></script>

   <h1><%= @event.name %></h1>

   <p>
     <%= link_to "打开前台", event_path(@event), :target => "_blank", :class => "btn    btn-primary" %>
   </p>

+  <canvas id="myChart" width="400" height="200"></canvas>
+  <script>
+  var ctx = document.getElementById("myChart");
+  var myChart = new Chart(ctx, {
+      type: 'bar',
+      data: {
+          labels: ["Red", "Blue", "Yellow", "Green", "Purple", "Orange"],
+          datasets: [{
+              label: '# of Votes',
+              data: [12, 19, 3, 5, 2, 3],
+              backgroundColor: [
+                  'rgba(255, 99, 132, 0.2)',
+                  'rgba(54, 162, 235, 0.2)',
+                  'rgba(255, 206, 86, 0.2)',
+                  'rgba(75, 192, 192, 0.2)',
+                  'rgba(153, 102, 255, 0.2)',
+                  'rgba(255, 159, 64, 0.2)'
+              ],
+              borderColor: [
+                  'rgba(255,99,132,1)',
+                  'rgba(54, 162, 235, 1)',
+                  'rgba(255, 206, 86, 1)',
+                  'rgba(75, 192, 192, 1)',
+                  'rgba(153, 102, 255, 1)',
+                  'rgba(255, 159, 64, 1)'
+              ],
+              borderWidth: 1
+          }]
+      },
+      options: {
+          scales: {
+              yAxes: [{
+                  ticks: {
+                      beginAtZero:true
+                  }
+              }]
+          }
+      }
+  });
+  </script>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/WPraiiXjTDOLorlzd9ET_22-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/WPraiiXjTDOLorlzd9ET_22-1.png)

这只是个 Chart.js 范例，并没有用到数据库的真实资料。在继续下去之前，请删掉它。

# 22-2 分析不同票种的报名人数

最常见的数据分析模式，就是根据不同分类计算数量或总和，例如我们来分析不同票种的报名人数。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/lpC3TNN7SZqnzLwqVTjL_22-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/lpC3TNN7SZqnzLwqVTjL_22-2.png)

> 以下数据沿用我们在 [18-1 制作后台管理报名资料](https://fullstack.xinshengdaxue.com/posts/1160) 所产生的假活动和报名数据。

编辑 `app/controllers/admin/events_controller.rb`

app/controllers/admin/events_controller.rb

```
  def show
    @event = Event.find_by_friendly_id!(params[:id])

+    colors = ['rgba(255, 99, 132, 0.2)',
+              'rgba(54, 162, 235, 0.2)',
+              'rgba(255, 206, 86, 0.2)',
+              'rgba(75, 192, 192, 0.2)',
+              'rgba(153, 102, 255, 0.2)',
+              'rgba(255, 159, 64, 0.2)'
+              ]
+
+    ticket_names = @event.tickets.map { |t| t.name }
+
+    @data1 = {
+        labels: ticket_names,
+        datasets: [{
+          label: "# of Registrations",
+          data: @event.tickets.map{ |t| t.registrations.count },
+          backgroundColor: colors,
+          borderWidth: 1
+        }]
+    }
```

编辑 `app/views/admin/events/show.html.erb`

app/views/admin/events/show.html.erb

```
  <script src="//cdn.bootcss.com/Chart.js/2.5.0/Chart.bundle.min.js"></script>

  <h1><%= @event.name %></h1>

  <p>
    <%= link_to "打开前台", event_path(@event), :target => "_blank", :class => "btn   btn-primary" %>
  </p>

+  <canvas id="myChart1" width="400" height="200"></canvas>
+  <script>
+  var ctx1 = document.getElementById("myChart1");
+  var myChart1 = new Chart(ctx1, {
+      type: 'bar',
+      data: <%= raw @data1.to_json %>,
+      options: {
+          scales: {
+              yAxes: [{
+                  ticks: {
+                      beginAtZero:true
+                  }
+              }]
+          }
+      }
+  });
+  </script>
+
+  <hr>
```

我们在 controller 中准备了`@data1` 变量就是要餵给 Chart.js 的分析资料，在 View 中需要把这个 Ruby 变量透过 `to_json` 转成 JavaScript 变量。

这个 `@data1` 输出后的数据格式长这样：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FXlFQSMcRseHrl80ILxK_22-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FXlFQSMcRseHrl80ILxK_22-3.png)

Chart.js 参数说明：

```
type: 'bar',  // 长条图

data: {
  "labels": ["Guest","VIP 第一期","VIP 第二期"],   // 横轴的标籤有哪些

  "datasets": [
    { "label": "# of Registrations",   // 数据集的名称

      "data": [324,346,330],           // 数据(这是数组)

      "backgroundColor":["rgba(255, 99, 132, 0.2)","rgba(54, 162, 235, 0.2)","rgba(255, 206, 86, 0.2)","rgba(75, 192, 192, 0.2)","rgba(153, 102, 255, 0.2)","rgba(255, 159, 64, 0.2)"],  // 长条的颜色

      "borderWidth": 1    // 要有框线

    }
  ]
},
options: {
    scales: {
        yAxes: [{
            ticks: {
                beginAtZero:true   // X 轴要从 0 起跳

            }
        }]
    }
}
```

详细关于这个资料结构的说明，可以参考 Chart.js 文档。

# 22-3 分析票种的总金额

跟上一节类似，但改成计算报名成功的总金额。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ZvygV2IT2mW2Z7FvOKL5_22-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ZvygV2IT2mW2Z7FvOKL5_22-4.png)

编辑 `app/controllers/admin/events_controller.rb`

app/controllers/admin/events_controller.rb

```
+   @data2 = {
+       labels: ticket_names,
+       datasets: [{
+           label: '# of Amount',
+           data:  @event.tickets.map{ |t| t.registrations.by_status("confirmed").count * t.price },
+           backgroundColor: colors,
+           borderWidth: 1
+       }]
+   }
```

其中 data 的部分变成计算报名成功的数量乘上该票价。

编辑 `app/views/admin/event/show.html.erb` 加上图表：

app/views/admin/event/show.html.erb

```
   <hr>

+  <canvas id="myChart2" width="400" height="200"></canvas>
+  <script>
+  var ctx2 = document.getElementById("myChart2");
+  var myChart2 = new Chart(ctx2, {
+      type: 'bar',
+      data: <%= raw @data2.to_json %>,
+      options: {
+          scales: {
+              yAxes: [{
+                  ticks: {
+                      beginAtZero:true
+                  }
+              }]
+          }
+      }
+  });
+  </script>
```

这样就完成了。Guest 票因为票价是0元，所以总金额也是0。

# 22-4 分析票种的报名人数，并根据状态分类

在上上节 "不同票种的报名人数" 图表中，把报名未完成和报名成功的数据都算在一起了，有没有办法可以根据不同状态分开算呢？

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/NiA2RLO4ROSFrwhbTO21_22-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/NiA2RLO4ROSFrwhbTO21_22-5.png)

编辑 `app/controllers/admin/events_controller.rb`

app/controllers/admin/events_controller.rb

```
-   @data1 = {
-       labels: ticket_names,
-       datasets: [{
-         label: "# of Registrations",
-         data: @event.tickets.map{ |t| t.registrations.count },
-         backgroundColor: colors,
-         borderWidth: 1
-       }]
-   }

+   status_colors = { "confirmed" => "#FF6384",
                      "pending" => "#36A2EB"}

+   @data1 = {
+       labels: ticket_names,
+       datasets: Registration::STATUS.map do |s|
+         {
+           label: I18n.t(s, :scope => "registration.status"),
+           data: @event.tickets.map{ |t| t.registrations.by_status(s).count },
+           backgroundColor: status_colors[s],
+           borderWidth: 1
+         }
+       end
+   }
```

`datasets` 参数其实就是资料集的数组，本来只有一个资料集，现在改成透过 `Registration::STATUS.map`产生两个资料集，分别是报名未完成和报名成功。

让我们观察一下实际输出的数据格式长怎样：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9TFqc71Q6KKirZsyAz6Q_22-6.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9TFqc71Q6KKirZsyAz6Q_22-6.png)

```
  data: {
    "labels": ["Guest","VIP 第一期","VIP 第二期"],  // 这是 Y 轴的标籤

    "datasets":[
      { "label": "报名尚未完成",     // 这是第一个资料集

        "data": [160,164,160],
        "backgroundColor":"#36A2EB",
        "borderWidth":1
      },
      { "label": "报名成功",         // 这是第二个资料集

        "data":[164,182,170],
        "backgroundColor":"#FF6384",
        "borderWidth":1
      }
    ]
  },
```

当有多个资料集时，它会沿着 Y 轴的标籤依序画上去。

# 22-5 分析每日报名人数，并根据状态分类

分析从第一天到今天的每日报名人数，并根据状态分类。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/wys4IY7ySLGxyC0sDbrU_22-7.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/wys4IY7ySLGxyC0sDbrU_22-7.png)

编辑 `app/controllers/admin/events_controller.rb`。其中 labels 参数是 Y 轴，这里改成用 dates 数组，代表从有人报名的第一天到今天。

app/controllers/admin/events_controller.rb

```
+   if @event.registrations.any?
+     dates = (@event.registrations.order("id ASC").first.created_at.to_date..Date.today).to_a

+     @data3 = {
+       labels: dates,
+       datasets: Registration::STATUS.map do |s|
+         {
+           :label => I18n.t(s, :scope => "registration.status"),
+           :data => dates.map{ |d|
+             @event.registrations.by_status(s).where( "created_at >= ? AND created_at <= ?", d.beginning_of_day, d.end_of_day).count
+           },
+           borderColor: status_colors[s]
+         }
+       end
+     }
+   end
```

跟上一节类似，`data` 有有两个资料集分别是报名尚未完成和报名完成。

编辑 `app/views/admin/event/show.html.erb` 加上图表，这里改成用 `line` 折线图：

app/views/admin/event/show.html.erb

```
   <hr>

+  <canvas id="myChart3" width="400" height="200"></canvas>
+  <script>
+  var ctx3 = document.getElementById("myChart3");
+  var myChart3 = new Chart(ctx3, {
+      type: 'line',
+      data: <%= raw @data3.to_json %>,
+      options: {
+          scales: {
+              yAxes: [{
+                  ticks: {
+                      beginAtZero:true
+                  }
+              }]
+          }
+      }
+  });
+  </script>
```

这样就完成了。

#### 本节作业

##### [第四集作业](https://fullstack.xinshengdaxue.com/assignments/55)：[作业二](https://fullstack.xinshengdaxue.com/tasks/322)

已有 12 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/322/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/322)

请在购物车项目中，分析每日订单数量，并制作图表。

# 23-1 增加后台管理员权限

目前只要有登入就可以进入后台，接下来实作基本的权限检查(Authorization)吧，只有管理员才可以进入后台。

基本的原理很简单，我们在 User model 上新增一个字段标记是不是管理员即可。

执行 `rails g migration add_role_to_users role:string` 增加一个 role 字串符字段到 users table 上。

> 在之前的课程中，是用 `is_admin:boolean` 字段来表示是不是管理员，在这里改用 `role:string`，这样的好处是可以有角色扩充的弹性。

执行 `rake db:migrate`

编辑 `app/controllers/admin_controller.rb`，增加权限检查 `current_user` 的 role (角色)必须是 `admin`。

app/controllers/admin_controller.rb

```
  class AdminController < ApplicationController
    protect_from_forgery with: :exception

    before_action :authenticate_user!
+   before_action :require_admin!

    layout "admin"

+   protected

+   def require_admin!
+     if current_user.role != "admin"
+       flash[:alert] = "您的权限不足"
+       redirect_to root_path
+     end
+   end

  end
```

这时候点选主选单的后台面板，就会出现：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/w9hAiOVeS96PK3ocy3XJ_23-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/w9hAiOVeS96PK3ocy3XJ_23-1.png)

这样就进不去后台了。

要设定第一个管理员，只能透过 rails console 了。

执行 `rails console`，依序输入：

```
u = User.find_by_email("admin@example.org")
u.role = "admin"
u.save!
```

这样 `admin@example.org` 就有权限可以进入后台管理。

# 23-2 增加其他角色

用 `role` 的设计好处是可以扩充不同角色，让我们新设计一个 `editor` 角色：

- `admin` 有全部后台权限
- `editor` 可以进入后台管理活动，但不能管理用户

编辑 `app/controllers/admin_controller.rb`，拿掉本来后台都套用的 `before_action :require_admin!` 权限检查。然后新增一个 `require_editor!` 方法，等会我们得逐个 controllers 一个一个加上权限检查。

app/controllers/admin_controller.rb

```
  class AdminController < ApplicationController
    protect_from_forgery with: :exception

    before_action :authenticate_user!
-   before_action :require_admin!

    layout "admin"

    protected

+   def require_editor!
+     if current_user.role != "editor" && current_user.role != "admin"
+       flash[:alert] = "您的权限不足"
+       redirect_to root_path
+     end
+   end

    def require_admin!
      if current_user.role != "admin"
        flash[:alert] = "您的权限不足"
        redirect_to root_path
      end
    end

  end
```

编辑以下档案，需要 editor 权限：

- `app/controllers/admin/event_registrations_controller.rb`
- `app/controllers/admin/event_tickets_controller.rb`
- `app/controllers/admin/events_controller.rb`

```
+  before_action :require_editor!
```

编辑以下档案，需要 admin 权限：

- `app/controllers/admin/user_profiles_controller.rb`
- `app/controllers/admin/users_controller.rb`
- `app/controllers/admin/versions_controller.rb`

```
+  before_action :require_admin!
```

> 以上这些 controller 都应该继承自 `AdminController`，例如 `class Admin::EventsController < AdminController`，这样才会有这两个方法可以调用

这样就完成了，每个 `app/controllers/admin/` 目录下的 controller 都要记得加上权限检查。

# 23-3 编辑用户角色

除了第一个管理员需要进入 rails console 编辑角色之外，在编辑用户那一页，我们可以实作一个下拉选单来编辑角色。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/c9Uy1XoTSKYyXzfaI08Q_23-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/c9Uy1XoTSKYyXzfaI08Q_23-2.png)

编辑 `app/models/user.rb`

app/models/user.rb

```
  class User < ApplicationRecord

+   ROLES = ["admin", "editor"]
```

编辑 `app/views/admin/users/edit.html.erb`

app/views/admin/users/edit.html.erb

```
   <div class="form-group">
     <%= f.label :email %>
     <%= f.text_field :email, :class => "form-control" %>
   </div>

+  <div class="form-group">
+    <%= f.label :role %>
+    <%= f.select :role, User::ROLES.map{ |x| [t(x, :scope => "user.role"), x] }, { :include_blank => true }, :class => "form-control" %>
+  </div>
```

> 注意这里多加了 `:include_blank => true` 参数，这会让下拉选单多一个空的 nil 空选项。

编辑 `config/locales/zh-CN.yml`

config/locales/zh-CN.yml

```
  "zh-CN":
+   user:
+     role:
+       admin: 超级管理员
+       editor: 活动管理员
```

编辑 `app/controllers/admin/users_controller.rb`

app/controllers/admin/users_controller.rb

```
   def user_params
-    params.require(:user).permit(:email, :group_ids => [])
+    params.require(:user).permit(:email, :role, :group_ids => [])
   end
```

这样就可以编辑用户的角色了。请编辑任一个用户变成 editor，然后登出，改用那个帐号登入(假用户的密码是12345678)，就可以测试上一节的权限检查了：可以活动管理，但是点用户管理会跳出权限不足。

# 23-4 权限重构

既然 editor 没有权限可以管理用户，那么在主选单上就不应该出现用户管理的连结，让我们小小改进一下：

编辑 `app/views/layouts/admin.html.erb`，根据不同权限决定要不要显示连结：

app/views/layouts/admin.html.erb

```
  <% if current_user %>
+   <% if current_user.role == "admin" || current_user.role == "editor" %>
      <li class="active"><%= link_to('活动管理', admin_events_path) %></li>
+   <% end %>

+   <% if current_user.role == "admin" %>
      <li><%= link_to('用户管理', admin_users_path) %></li>
+    <% end %>
  <% end %>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pixHFFSQViREGemRy8Hg_23-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pixHFFSQViREGemRy8Hg_23-3.png)

不过这个 if 条件跟 `admin_controller.rb` 里面的权限检查条件，其实逻辑是一样的，也就是 admin 的权限包括 editor 的权限，我们进一步重构一下。

编辑 `app/models/user.rb`，加上两个方法判断是不是 admin 和 editor

app/models/user.rb

```
+  def is_admin?
+    self.role == "admin"
+  end
+
+  def is_editor?
+    ["admin", "editor"].include?(self.role)  # 如果是 admin 的话，当然也有 editor 的权限
+  end
```

编辑 `app/controllers/admin_controller.rb`，改成用 `is_admin?` 和 `is_editor?` 方法

```
  protected

  def require_editor!
-   if current_user.role != "editor" && current_user.role != "admin"
+   unless current_user.is_editor?
      flash[:alert] = "您的权限不足"
      redirect_to root_path
    end
  end

  def require_admin!
-   if current_user.role != "admin"
+   unless current_user.is_admin?
      flash[:alert] = "您的权限不足"
      redirect_to root_path
    end
  end
```

编辑 `app/views/layouts/admin.html.erb`，改成用 `is_admin?` 和 `is_editor?` 方法

app/views/layouts/admin.html.erb

```
  <% if current_user %>
-   <% if current_user.role == "admin" || current_user.role == "editor" %>
+   <% if current_user.is_editor? %>
      <li class="active"><%= link_to('活动管理', admin_events_path) %></li>
    <% end %>

-   <% if current_user.role == "admin" %>
+   <% if current_user.is_admin? %>
      <li><%= link_to('用户管理', admin_users_path) %></li>
     <% end %>
  <% end %>
```

这样就完成了，透过 User model 的 `is_admin?` 和 `is_editor?` 方法集中权限检查的逻辑，之后如果新增不同子权限，只要改 model 就可以了。

# 23-5 补充: pundit 和 cancancan

如果权限检查的逻辑比较复杂，有很多角色而且不同 action 又有不同权限，甚至是不同资料有不同权限，这时候我们可以考虑使用专用的权限检查 gem，帮助我们组织代码，也避免忘记加上权限(前几节的实作，如果忘记加上 `before_action` 你就忘记检查到囉)。最知名的有以下两套：

- [Pundit](https://github.com/elabs/pundit)
- [Cancancan](https://github.com/CanCanCommunity/cancancan)

详细用法请自行参考文档。

# 24-1 安装 letter_opener

在本机开发的时候，不需要真的寄出 E-mail，请安装 [letter_opener](https://github.com/ryanb/letter_opener)，这样 Rails 会在寄信时，自动打开浏览器进行预览。

编辑 `Gemfile`

Gemfile

```
  group :development do
    gem 'faker'
+   gem 'letter_opener'

```

编辑 `config/environments/development.rb` 设定 `delivery_method`

config/environments/development.rb

```
+  config.action_mailer.delivery_method = :letter_opener
   config.action_mailer.default_url_options = { :host => 'localhost:3000' }
```

执行 `bundle`，重启服务器

要测试 E-mail 的一个简单方式是去测试忘记密码流程：请登出，然后进入登入画面，点选 Forgot your password?

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/BmFako9ZSei1wyIAh6QT_24-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/BmFako9ZSei1wyIAh6QT_24-1.png)

输入 E-mail 后按下送出，这时候不会真的寄出 E-mail，而是自动跳出浏览器浏览信件内容：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MzLT86PfTbmfFTiWkArc_24-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MzLT86PfTbmfFTiWkArc_24-2.png)

# 24-2 寄送报名完成的 E-mail

实作目标：完成报名后，寄出通知 E-mail

执行 `rails g mailer notification`

编辑 `app/mailers/notification_mailer.rb`，新增 confirmed_registration 信

app/mailers/notification_mailer.rb

```
  class NotificationMailer < ApplicationMailer

+   def confirmed_registration(registration)
+     @registration = registration
+     @event = registration.event
+
+     mail( :to => @registration.email, :subject =>   I18n.t("notification.subject.confirmed_registration", :name => @event.name) )
+   end

  end
```

编辑 `config/locales/zh-CN.yml` 增加 E-mail 标题的翻译

config/locales/zh-CN.yml

```
  "zh-CN":
+   notification:
+     subject:
+       confirmed_registration: "报名成功: %{name}"
```

新增 `app/views/notification_mailer/confirmed_registration.text.erb` 是 E-mail 样板

```
Hi <%= @registration.name %>,

您已完成报名 <%= @event.name %> <%= event_url(@event) %>
```

> 在 E-mail 里面的网址都必须要写绝对网址 `xxx_url`，而不是相对网址 `xxx_path`。例如 `event_url(@event)` 会产生 `http://localhost:3000/events/fullstack-meetup`，而 `event_path(@event)` 会产生 `/events/fullstack-meetup`，这样在 E-mail 阅读器中点超连结才能顺利让浏览器打开网址。那 Rails 要怎么知道网站位置呢? 我们曾在 `config/environments/development.rb` 写过 `config.action_mailer.default_url_options = { :host => 'localhost:3000' }` 这就是 E-mail 中产生 `xxx_url` 网址时，会用的网站位置。之后上 production 你也必须在 `config/environments/production.rb` 进行设定。

编辑 `app/controllers/registrations_controller.rb` 在报名完成后寄出 E-mail

app/controllers/registrations_controller.rb

```
  def step3_update
    @registration = @event.registrations.find_by_uuid(params[:id])
    @registration.status = "confirmed"
    @registration.current_step = 3

    if @registration.update(registration_params)
      flash[:notice] = "报名成功"

+     NotificationMailer.confirmed_registration(@registration).deliver_later

      redirect_to event_registration_path(@event, @registration)
    else
      render "step3"
    end
  end

  "zh-CN":
+   notification:
+     subject:
+       confirmed_registration: "报名成功: %{name}"
```

这样就会在报名完成后，寄出 E-mail 了：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/zC0XX8WRBSnNQsyKvPGQ_24-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/zC0XX8WRBSnNQsyKvPGQ_24-3.png)

你也可以直接在 rails console 中进行测试：

执行 `rails console`，然后输入

```
NotificationMailer.confirmed_registration( Registration.by_status("confirmed").last ).deliver_now
```

这样就会寄出最后一笔报名成功的信，方便我们反复修改 `app/views/notification_mailer/confirmed_registration.text.erb` 样板，而不需要离开 rails console，每次改完只要在 rails console 中再寄一次就可以了。

# 24-3 HTML E-mail

上一节中的 E-mail 样板，采用的是纯文字 text 格式，所以副档名是 `.text.erb`。

纯文字的 E-mail 好处是排版简单，不需要烦恼样式、而且所有的 Email 阅读器都可以顺利打开，不过缺点就是因为没有 HTML，所以不能放超连结，只能直接放网址 (不过大部分的 E-mail 阅读器都能判断这是网址，便会自动帮你加上超连结)、不能放直接放图片(img)、不能放表格(table)等等。

因此如果想要制作漂亮的 E-mail，就需要制作 HTML 格式的 E-mail，要改成寄出 HTML E-mail 很简单：

请将 `app/views/notification_mailer/confirmed_registration.text.erb` 档名变更为 `app/views/notification_mailer/confirmed_registration.html.erb`，接着编辑它：

app/views/notification_mailer/confirmed_registration.html.erb

```
-   Hi <%= @registration.name %>,
+  <p>Hi <%= @registration.name %>,</p>

-  您已完成报名 <%= @event.name %> <%= event_url(@event) %>
+  <p>您已完成报名 <%= link_to @event.name, event_url(@event) %></p>
```

再测试寄一次，网址的部分就变成超连结了：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/8UtdwuvlSF2RRF8eEIkd_24-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/8UtdwuvlSF2RRF8eEIkd_24-4.png)

> Protip: 由用户触发的系统信比较适合用 HTML E-mail，用户会感觉那是系统自动寄出的信件。但如果是客服回信或意见询问，用纯文字 E-mail 可能反而比较有诚意喔。因为用户会感觉那是人写的信件，而不是系统自动寄出的信。

# 24-4 E-mail CSS 样式问题：安装 premailer

既然用了 HTML E-mail，接下来会想加一些 CSS 样式上去。不过这就是麻烦的地方，E-mail 阅读软件比起浏览器更多样更古老，例如有 Outlook、iPhone、Apple Mail、Yahoo! Mail、Google Mail、Android、QQ 信箱等等，这些 E-mail 阅读器对 CSS 的支援程度很不一致。详情请参考：

- [Modern HTML Email Development](https://blog.othree.net/log/2016/08/25/modern-html-email-develop/)
- [The Ultimate Guide to CSS](https://www.campaignmonitor.com/css/)
- [CSS | Email Design Reference](http://templates.mailchimp.com/development/css/)

基本来说，你不能用 `<link>` 标籤去加载 CSS 档案、有些 E-mail 阅读器不能用 `<style>` 标籤写 CSS 样式，当然也不可能写 JavaScript。

保险的作法是需要将 CSS 用 Inline (内联)的方式到 HTML 里面，例如以下的 HTML：

```
<link rel="stylesheet" media="all" href="/assets/email.css" />
<style>
  p { color: red }
</style>
<body>
  <p>TEST</p>
</body>
```

在寄出的 E-mail 中需要改成将 CSS 都集中到该标籤的 `style` 属性，这样 E-mail 阅读器才会套用到 CSS 样式。

```
<body>
  <p style="color: red; font-family: 'Helvetica N=
eue', Helvetica, Arial, sans-serif; font-size: 14px; font-weight: normal;">
</body>
```

这是一个大苦工啊，更何况写成 inline CSS 的话，代码维护性会变成非常差很难改。

好在 Rails 有个 [premailer-rails](https://github.com/fphilipe/premailer-rails) gem 可以帮我们自动做好这个转换，就可以用本来的写法，它会自动转换成 inline CSS 👍👍👍

请编辑 `Gemfile`

```
+  gem 'premailer-rails'
```

执行 `bundle`，重启服务器，下一节我们来套版。

# 24-5 HTML E-mail 套版

因为 E-mail 的 CSS 属性支援程度不一，如果要完全自己写 CSS 测试会很辛苦，好在我们有现成的 Email Responsive Template 样板可以套：

- [Transactional HTML Email Templates](http://blog.mailgun.com/transactional-html-email-templates/)
- [Really Simple Responsive HTML Email Template](https://github.com/leemunroe/responsive-html-email-template)
- [Responsive HTML Email Templates](https://htmlemail.io/) USD $49

请下载第一个 [Transactional HTML Email Templates 的 zip 压缩档](https://github.com/mailgun/transactional-email-templates/archive/master.zip)，我们拿它的 `templates/action.html` 来改。

> 你会发现这个他还有提供 inlined 的版本，把 style inline 进去后的 HTML 代码非常的恶心，很难修改。好在我们有装 `premailer-rails` gem 了，所以用不到。

请把 `templates/style.css` 复制到我们项目中的 `app/assets/stylesheets/email.css`

编辑 `app/views/layouts/mailer.html.erb`，把内容全部换成：

app/views/layouts/mailer.html.erb

```
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="viewport" content="width=device-width" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Notification</title>
<link href="email.css" media="all" rel="stylesheet" type="text/css" />
</head>

<body itemscope itemtype="http://schema.org/EmailMessage">

<table class="body-wrap">
  <tr>
    <td></td>
    <td class="container" width="600">
      <div class="content">
        <table class="main" width="100%" cellpadding="0" cellspacing="0" itemprop="action" itemscope itemtype="http://schema.org/ConfirmAction">
          <tr>
            <td class="content-wrap">
              <meta itemprop="name" content="Confirm Email"/>
              <table width="100%" cellpadding="0" cellspacing="0">
                <tr>
                  <td class="content-block">
                    <%= yield %>
                  </td>
                </tr>
                <tr>
                  <td class="content-block" itemprop="handler" itemscope itemtype="http://schema.org/HttpActionHandler">
                    <%= yield :action %>
                  </td>
                </tr>
                <tr>
                  <td class="content-block">
                    &mdash; 你的名字
                  </td>
                </tr>
              </table>
            </td>
          </tr>
        </table>
        <div class="footer">
          <table width="100%">
            <tr>
              <td class="aligncenter content-block"><a href="https://fullstack.xinshengdaxue.com">新生大学线上全栈营</a></td>
            </tr>
          </table>
        </div></div>
    </td>
    <td></td>
  </tr>
</table>

</body>
</html>
```

其中主内容是 `<%= yield %>`，另外还挖了一个洞是 `<%= yield :action %>`，等会用 `content_for :action` 可以填内容进去。

编辑 `app/views/notification_mailer/confirmed_registration.html.erb`

app/views/notification_mailer/confirmed_registration.html.erb

```
   <p>Hi <%= @registration.name %>,</p>

   <p>您已完成报名 <%= link_to @event.name, event_url(@event) %></p>

+  <% content_for :action do %>
+    <%= link_to "浏览报名结果", event_registration_url(@event, @registration), :class => "btn-primary", :itemprop => "url" %>
+  <% end %>
```

多加了一个用途是 Call to Action 的按钮，这样一封漂亮的 E-mail 就完成了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y6WMipPSD6UbhQVqgdWO_24-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y6WMipPSD6UbhQVqgdWO_24-5.png)

#### 本节作业

##### [第四集作业](https://fullstack.xinshengdaxue.com/assignments/55)：[作业三](https://fullstack.xinshengdaxue.com/tasks/323)

已有 12 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/323/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/323)

请在任一个项目中的 E-mail (例如购物车的订单完成信)，套用 HTML 样板。

# 25-1 解析 CSV 档案 (Rake)

我们在「百宝箱 20-数据汇出 」实作过汇出 CSV 格式，一个有良心的平台会实作汇出功能，方便用户进行分析或资料转移。或是用 Microsoft Excel 或 Apple Numbers 试算表，可以点选另存新档(Save As...)为 CSV UTF-8 格式来做数据汇出。

> [CSV 逗号分隔值](https://zh.wikipedia.org/wiki/%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC) 格式除了容易汇出，也是最容易汇入处理的格式，这一章会用 CSV 举例，不需要额外装 gem 就能处理。

假设我们拿到这样的 CSV 档案，接下来要如果汇入数据库呢？总不能一笔一笔输入太慢了，当然要用写程序的方式来做汇入。

如果汇入是程序员的一次性的任务，我们可以不需要实作 Web UI，只需要一个 rake 任务可以执行就好了。

请下载这一个 CSV: [registrations.csv](https://raw.githubusercontent.com/growthschool/rails-recipes/master/registrations.csv) 放在项目 `tmp` 目录下（按右键另存新档)

> 这有1000笔报名资料，其中有2笔故意缺少了 E-mail。

编辑 `lib/tasks/dev.rake`，让我们新增一个 `import_registration_csv_file` 任务

lib/tasks/dev.rake

```
+ require 'csv'
  namespace :dev do

+   task :import_registration_csv_file => :environment do
+     event = Event.find_by_friendly_id("fullstack-meetup")
+     tickets = event.tickets
+
+     success = 0
+     failed_records = []
+
+     CSV.foreach("#{Rails.root}/tmp/registrations.csv") do |row|
+       registration = event.registrations.new( :status => "confirmed",
+                                    :ticket => tickets.find{ |t| t.name == row[0] },
+                                    :name => row[1],
+                                    :email => row[2],
+                                    :cellphone => row[3],
+                                    :website => row[4],
+                                    :bio => row[5],
+                                    :created_at => Time.parse(row[6]) )
+
+       if registration.save
+         success += 1
+       else
+         failed_records << [row, registration]
+       end
+     end
+
+     puts "总共汇入 #{success} 笔，失败 #{failed_records.size} 笔"
+
+     failed_records.each do |record|
+       puts "#{record[0]} ---> #{record[1].errors.full_messages}"
+     end
+
+   end
```

执行 `rake dev:import_registration_csv_file` 就会执行了汇入的操作到 `fullstack-meetup` 这个活动。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FQqv602eRrGiC0mVt6qa_25-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FQqv602eRrGiC0mVt6qa_25-1.png)

解说:

1. 和汇出 CSV 一样，Ruby 内建了 CSV 库可以解析 CSV，所以第一行先 `require 'csv'`
2. `CSV.foreach` 会打开这个 CSV 档案跑循环，每笔资料就是一行 `row`，那一行的第一列是 `row[0]`、第二列是 `row[1]`。只要依序塞给 `event.registrations.new` 即可。
3. CSV 中的票种是字符串，但是转进我们的数据库中需要转换成 Ticket model，因此这里写成 `tickets.find{ |t| t.name == row[0] }` 用票种名称去找是哪一个对象。
4. 时间也是一样，透过 `Time.parse` 转成时间对象
5. 因为汇入会一次汇入非常多笔，我们希望不管每笔资料 save 成功或失败，都能跑完全部资料，最后印出一个总结：告诉我们总共几笔成功，总共几笔失败，是哪些笔失败又是什么原因。

# 25-2 解析 CSV 档案 (Web UI 接口)

需要 Web UI 可以上传档案的话，让我们来实作一下：

请编辑 `config/routes.rb`，新增一个 import 路由

config/routes.rb

```
   namespace :admin do
     # 略
     resources :events do
-      resources :registrations, :controller => "event_registrations"
+      resources :registrations, :controller => "event_registrations" do
+        collection do
+          post :import
+        end
+      end
```

编辑 `app/views/admin/event_registrations/index.html.erb` 加上档案上传的输入框：

app/views/admin/event_registrations/index.html.erb

```
   <%= link_to "汇出 CSV", admin_event_registrations_path(:format => :csv), :class => "btn btn-default" %>
   <%= link_to "汇出 Excel", admin_event_registrations_path(:format => :xlsx), :class => "btn btn-default" %>
 </p>
+
+ <hr>
+
+ <%= form_tag import_admin_event_registrations_path(@event), :multipart => true do %>
+   <p><%= file_field_tag "csv_file" %></p>
+   <p><%= submit_tag "汇入CSV", :class => "btn btn-danger" %></p>
+ <% end %>
```

编辑 `app/controllers/admin/event_registrations_controller.rb` 新增一个 import action，内容基本上跟 rake 的版本差不多

app/controllers/admin/event_registrations_controller.rb

```
+  def import
+    csv_string = params[:csv_file].read.force_encoding('utf-8')
+
+    tickets = @event.tickets
+
+    success = 0
+    failed_records = []
+
+    CSV.parse(csv_string) do |row|
+      registration = @event.registrations.new( :status => "confirmed",
+                                   :ticket => tickets.find{ |t| t.name == row[0] },
+                                   :name => row[1],
+                                   :email => row[2],
+                                   :cellphone => row[3],
+                                   :website => row[4],
+                                   :bio => row[5],
+                                   :created_at => Time.parse(row[6]) )
+
+      if registration.save
+        success += 1
+      else
+        failed_records << [row, registration]
+        Rails.logger.info("#{row} ----> #{registration.errors.full_messages}")
+      end
+    end
+
+    flash[:notice] = "总共汇入 #{success} 笔，失败 #{failed_records.size} 笔"
+    redirect_to admin_event_registrations_path(@event)
+  end
+
   protected
```

其中 `csv_string` 就是从上传的档案中读取内容，接着用 `CSV.parse` 进行解析循环。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YE9m2o1cSwu0nsTPa5Bb_25-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YE9m2o1cSwu0nsTPa5Bb_25-2.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/NrcLkD5gSPW82NN7xD1t_25-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/NrcLkD5gSPW82NN7xD1t_25-3.png)

注意本来的 admin layout 中的 flash 样式有点问题，请修改 `app/views/layouts/admin.html.erb` 修正一下：

app/views/layouts/admin.html.erb

```
-    <div class="container">
+    <div class="container" style="padding-top: 60px">

-      <p class="notice"><%= notice %></p>
-      <p class="alert"><%= alert %></p>

+      <% if notice %>
+        <p class="notice alert-success"><%= notice %></p>
+      <% end %>

+      <% if alert %>
+        <p class="alert alert-danger"><%= alert %></p>
+      <% end %>
```

# 25-3 把汇入档案存下来纪录过程

上一节的方式比较简略，我们并没有把上传的档案存下来，而是直接读取档案内容进行处理。

如果这是一个面向终端用户的功能，会需要实作的更完整，例如：

1. 把上传的档案先存下来，先给用户预览字段顺序是否正确、有多少数据要汇入、哪些数据有问题
2. 确认后，才开始汇入数据库
3. 可以浏览过往的汇入历史纪录

接下来我们示范如何新增一个 Model 把档案存下来处理，以及新增一个 RegistrationImports controller 显示汇入的历史纪录。

执行 `rails g model registration_import`，这个 Model 会存下上传的 CSV 档案，并记录汇入的结果。

编辑 `db/migrate/2017XXXXXX4512_create_registration_imports.rb`

db/migrate/2017XXXXXX4512_create_registration_imports.rb

```
  class CreateRegistrationImports < ActiveRecord::Migration[5.0]
    def change
      create_table :registration_imports do |t|
+       t.string :status
+       t.string :csv_file
+       t.integer :event_id, :index => true
+       t.integer :user_id
+       t.integer :total_count
+       t.integer :success_count
+       t.text :error_messages
        t.timestamps
      end
    end
  end
```

执行 `rake db:migrate`

执行 `rails g uploader registration_import_csv`

编辑 `app/models/registration_import.rb`，其中的 `process!` 方法就是要执行的汇入操作。

app/models/registration_import.rb

```
+ require 'csv'
  class RegistrationImport < ApplicationRecord

+   mount_uploader :csv_file, RegistrationImportCsvUploader
+
+   validates_presence_of :csv_file
+
+   belongs_to :event
+   belongs_to :user
+
+   serialize :error_messages, JSON
+
+   def process!
+     csv_string = self.csv_file.read.force_encoding('utf-8')
+     tickets = self.event.tickets
+
+     success = 0
+     failed_records = []
+
+     CSV.parse(csv_string) do |row|
+       registration = self.event.registrations.new( :status => "confirmed",
+                                    :ticket => tickets.find{ |t| t.name == row[0] },
+                                    :name => row[1],
+                                    :email => row[2],
+                                    :cellphone => row[3],
+                                    :website => row[4],
+                                    :bio => row[5],
+                                    :created_at => Time.parse(row[6]) )
+
+       if registration.save
+         success += 1
+       else
+         failed_records << [row, registration.errors.full_messages]
+       end
+     end
+
+     self.status = "imported"
+     self.success_count = success
+     self.total_count = success + failed_records.size
+     self.error_messages = failed_records
+
+     self.save!
+   end

  end
```

编辑 `app/models/event.rb`

app/models/event.rb

```
   has_many :registrations, :dependent => :destroy
+  has_many :registration_imports, :dependent => :destroy
```

编辑 `config/routes.rb`

config/routes.rb

```
  namespace :admin do
     # (略)
     resources :events do
+      resources :registration_imports
```

编辑 `app/views/admin/event_registrations/index.html.erb` 加上一个按钮

app/views/admin/event_registrations/index.html.erb

```
  <p class="text-right">
    <%= link_to "New Registration", new_admin_event_registration_path(@event), :class => "btn btn-primary" %>
+   <%= link_to "Import Registration", admin_event_registration_imports_path(@event), :class => "btn btn-primary" %>
   </p>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y1o2zIdOTzyKQwJbTcLf_25-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y1o2zIdOTzyKQwJbTcLf_25-4.png)

执行 `rails g controller admin::registration_imports`

编辑 `app/controllers/admin/registration_imports_controller.rb`

app/controllers/admin/registration_imports_controller.rb

```
- class Admin::RegistrationImportsController < ApplicationController
+ class Admin::RegistrationImportsController < AdminController

+   before_action :require_editor!
+   before_action :find_event
+
+   def index
+     @imports = @event.registration_imports.order("id DESC")
+   end
+
+   def create
+     @import = @event.registration_imports.new(registration_import_params)
+     @import.status = "pending"
+     @import.user = current_user
+
+     if @import.save
+       @import.process!
+       flash[:notice] = "汇入完成"
+     end
+
+     redirect_to admin_event_registration_imports_path(@event)
+   end
+
+   protected
+
+   def find_event
+     @event = Event.find_by_friendly_id!(params[:event_id])
+   end
+
+   def registration_import_params
+     params.require(:registration_import).permit(:csv_file)
+   end

  end
```

其中在 `@import.save` 之后，随即呼叫 `process!` 开始汇入。

新增 `app/views/admin/registration_imports/index.html.erb` 显示档案上传的输入框，以及历史汇入纪录。

app/views/admin/registration_imports/index.html.erb

```
<h1><%= @event.name %> / Registrations Import</h1>


<%= form_for [:admin, @event, RegistrationImport.new] do |f| %>

  <div class="form-group">
    <%= f.label :csv_file %>
    <%= f.file_field :csv_file, :required => true, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.submit "送出", :class => "btn btn-primary" %>
  </div>

<% end %>

<table class="table">
<tr>
  <th>ID</th>
  <th>状态</th>
  <th>CSV档案</th>
  <th>总笔数</th>
  <th>汇入成功笔数</th>
  <th>错误讯息</th>
</tr>
<% @imports.each do |import| %>
  <tr>
    <td><%= import.id %></td>
    <td><%= import.status %></td>
    <td><%= link_to import.csv_file.url, import.csv_file.url %></td>
    <td><%= import.total_count %></td>
    <td><%= import.success_count %></td>
    <td>
      <ul>
      <% Array(import.error_messages).each do |e| %>
       <li><%= e[0] %> ----> <strong><%= e[1] %></strong></li>
      <% end %>
      </ul>
    </td>
  </tr>
<% end %>
</table>
```

这样就完工啦。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/wy7rA3aRrSGT7BtGhFlF_25-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/wy7rA3aRrSGT7BtGhFlF_25-5.png)

# 26-1 前言和安装 sidekiq

所谓的异步处理任务，就是在用户送出操作后，Rails 不会立即执行这个任务，而是交由另一个进程(process)在背景进行处理执行。

使用的场景是：当任务要执行很久的时候，例如汇出大笔数据、汇入大笔数据等，当数据量上万笔的时候，可能会需要好几分钟才能执行完成。这时候如果不做异步处理，用户的浏览器就会像卡住一样，需要等服务器完成任务才有回应。

等待时间太久除了让用户感受不佳之外，对于服务器效能上的影响也很巨大。用户可能等不及又重新整理一次，于是相同的任务又在重头执行一遍。而一个 HTTP Request 如果长时间执行，也会让 Rails 服务器无法服务其他用户。

因此，这类型的任务我们会改成异步处理，第一时间用户会先看到「操作正在执行中，请稍候再回来」或是「完成后会 E-mail 通知您」的讯息。

常用的异步处理有两套 gem:

- [delayed_job](https://github.com/collectiveidea/delayed_job): 使用关联式数据库，容易安装使用
- [Sidekiq](http://sidekiq.org/): 使用高效能的 [Redis](https://redis.io/) 数据库，执行效率极好，业界较常用

这两套 gem 的作用都是让 Rails 可以存下要执行的异步处理任务，然后启动进程(process)在背景进行处理执行。

这一章将用 Sidekiq 举例，本机 Mac 需要安装 Redis 数据库：

执行 `brew install redis`

另开一个 Termonal 视窗，执行 `redis-server /usr/local/etc/redis.conf` 就会跑起来 Redis 服务器

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/dGmddzyTTdqGfcvYuom0_26-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/dGmddzyTTdqGfcvYuom0_26-2.png)

编辑 `Gemfile`

Gemfile

```
+  gem 'sidekiq'
```

执行 `bundle`

编辑 `config/environments/development.rb` 和 `config/environments/production.rb` 告诉 Rails 要用 sidekiq 来做异步处理

config/environments/development.rb

```
+ config.active_job.queue_adapter = :sidekiq
```

新增 `config/sidekiq.yml`

```
---
:queues:
  - default
  - mailers
```

重启服务器

# 26-2 异步汇入

就拿上一章的数据汇入来改吧，本来的汇入有1000笔其实就要跑一阵子了，这是个标准情况需要改成异步处理。

执行 `rails g job import_worker` 这会产生一种异步处理任务，叫做 `ImportWorkerJob`

app/jobs/import_worker_job.rb

```
  class ImportWorkerJob < ApplicationJob
    queue_as :default

-   def perform(*args)
-     # Do something later
-   end

+   def perform(import_id)
+     import = RegistrationImport.find(import_id)
+     import.process!
+   end

  end
```

这个异步处理要怎么调用呢？接着修改 `app/controllers/admin/registration_imports_controller.rb`，改成异步处理：

app/controllers/admin/registration_imports_controller.rb

```
  def create
    @import = @event.registration_imports.new(registration_import_params)
    @import.status = "pending"
    @import.user = current_user

    if @import.save
-     @import.process!
+     ImportWorkerJob.perform_later(@import.id)

-     flash[:notice] = "汇入完成"
+     flash[:notice] = "汇入已在背景执行，请稍候再来看结果"
    end

    redirect_to admin_event_registration_imports_path(@event)
  end
```

本来是直接调用 `@import.process!`，现在改成调用 `ImportWorkerJob.perform_later(@import.id)` 就会变成异步。

你可以回到 25-3 实作的数据汇入，上传一个档案看看，你会发现服务器立即就回传了「汇入已在背景执行，请稍候再来看结果」讯息。之所以这么快，是因为它没有执行汇入，它只是跟 Sidekiq 说有一个任务要执行而已。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/zsarmhrZSnu7WEV9A3E0_26-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/zsarmhrZSnu7WEV9A3E0_26-1.png)

那到底谁去执行这个异步任务呢? 我们需要另外启动 Sidekiq 进程，请再开一个新个 Terminal 视窗，执行

`bundle exec sidekiq`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/jZluYz6RS7ClcZCrD7UA_26-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/jZluYz6RS7ClcZCrD7UA_26-4.png)

只要有异步任务进来，这个 Sidekiq 会去去执行它。

> 如果进 rails console 想要单纯测试这个任务，可以不需要异步，改用 `.perform_now` 方法就会马上执行

# 26-3 Sidekiq 管理 UI

Sidekiq 有提供一个漂亮的管理 UI，可以欣赏有多少待执行的异步任务、有多少执行成功和失败(失败sidekiq会重试)，也可以删除任务。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/fu5NgA99TySIWr2WHeYR_26-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/fu5NgA99TySIWr2WHeYR_26-5.png)

修改 `config/routes.rb`

config/routes.rb

```
  Rails.application.routes.draw do

+   require 'sidekiq/web'
+   authenticate :user, lambda { |u| u.is_admin? } do
+     mount Sidekiq::Web => '/sidekiq'
+   end
```

> 其中 authenticate 方法会检查权限，利用我们之前写的 User#is_admin? 方法

浏览器浏览 `http://localhost:3000/sidekiq`

# 26-4 异步汇出

数据汇出也是一个常用异步来处理的任务，流程和汇入其实87分像：

- 建立 RegistraionExport model，这个 model 会纪录是那个 user 做汇出、是哪个 event 要汇出，以及存储最后汇出的档案
- 建立一个 RegistrationExports controller，这个 controller 让用户可以新增汇出纪录，以及浏览汇出纪录
- 建立 ExportWorkerJob，这个异步任务会执行汇出操作，并将汇出的档案放到 RegistraionExport model 上
- 异步任务最后完成时，可以寄 E-mail 通知用户汇出的档案已经准备好了

这里就不示范实做了。

最后，汇出和汇入的功能要完整实做的话，还需要考虑档案存储的位置。我们用 carrierwave 上传的档案，默认是公开的。但是汇出和汇入的档案，应该也必须要检查有没有权限才行。这部分的实作牵扯到我们使用哪种档案服务器：

- 存储在本机的话，请参考 [How To: Secure Upload](https://github.com/carrierwaveuploader/carrierwave/wiki/how-to:-secure-upload)
- 存储在七牛云，请参考 [下载凭证](https://developer.qiniu.com/kodo/manual/1202/download-token)
- 存储在 AWS S3，请参考 [Serving Private Content](http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html)

在之后的进阶部署课程中，会再进一步示范如何使用。

# 26-5 报名15分钟内没完成自动取消

异步处理可以设定延迟时间，例如我们来实作一个小功能：如果报名15分钟内没有完成，系统会自动取消

执行 `rails g job check_registration`

编辑 `app/jobs/check_registration_job.rb`

app/jobs/check_registration_job.rb

```
  class CheckRegistrationJob < ApplicationJob
    queue_as :default

-   def perform(*args)
+   def perform(registration_id)
+     registration = Registration.find(registration_id)
+
+     unless registration.status == "confirmed"
+       registration.status = "cancalled"
+       registration.save!
+     end
+
    end
  end
```

编辑 `app/models/registration.rb`

app/models/registration.rb

```
-  STATUS = ["pending", "confirmed"]
+  STATUS = ["pending", "confirmed", "cancalled"]
```

编辑 `config/locales/zh-CN.yml`

config/locales/zh-CN.yml

```
   registration:
     status:
       pending: 报名尚未完成
       confirmed: 报名成功
+      cancalled: 报名已取消
```

编辑 `app/controllers/registrations_controller.rb`，在新建报名之后，增加这个异步任务，并用 `set` 方法指定延迟时间。另外，重构了 `before_action :set_pending_registration` 检查如果是 cancalled 状态就不能继续填写报名资料。

app/controllers/registrations_controller.rb

```
  class RegistrationsController < ApplicationController

    before_action :find_event
+   before_action :set_pending_registration, :only => [:step1, :step1_update, :step2, :step2_update, :step3, :step3_update]

    def create
      @registration = @event.registrations.new(registration_params)
      @registration.ticket = @event.tickets.find( params[:registration][:ticket_id] )
      @registration.status = "pending"
      @registration.user = current_user
      @registration.current_step = 1

      if @registration.save
+        CheckRegistrationJob.set( wait: 15.minutes ).perform_later(@registration.id)

    # 略...

    def step1
-     @registration = @event.registrations.find_by_uuid(params[:id])
    end

    def step1_update
-     @registration = @event.registrations.find_by_uuid(params[:id])

      # 略

    def step2
-     @registration = @event.registrations.find_by_uuid(params[:id])
    end

    def step2_update
-     @registration = @event.registrations.find_by_uuid(params[:id])

      # 略

    def step3
-     @registration = @event.registrations.find_by_uuid(params[:id])
    end

    def step3_update
-     @registration = @event.registrations.find_by_uuid(params[:id])

    # 略

    protected

+   def set_pending_registration
+     @registration = @event.registrations.find_by_uuid(params[:id])
+
+     if @registration.status == "cancalled"
+       flash[:alert] = "请重新报名"
+       redirect_to event_path(@event)
+     end
+   end

    # 略
```

> 可以暂时改成用 `1.minute` 进行测试

这样就完成了。

# 异步 E-mail 寄信

Rails 的 E-mail 寄信功能，其实也用了异步处理任务，因为寄信会调用第三方的寄信 SMTP 服务器，执行速度上比较慢，因此也适合用异步处理来做。

回想在 24-2 寄送报名完成的 E-mail 是如何寄送的：

```
NotificationMailer.confirmed_registration(@registration).deliver_later
```

这里的 `deliver_later` 方法，就会用这一章设定的异步处理机制去寄信。

如果不要用异步处理，例如我们在 rails console 测试的时候：

```
NotificationMailer.confirmed_registration( Registration.by_status("confirmed").last ).deliver_now
```

这里的 `deliver_now` 方法，就会立即寄出。
