---
layout: post
title: "Rails网站效能"
date: 2017-10-30
tags:
    Rails
    教材
---
| 1. 前言与案例准备                               |      |
| ---------------------------------------- | ---- |
| [**  1-1 前言](https://fullstack.xinshengdaxue.com/posts/1205) |      |
| [**  1-2 法律警告](https://fullstack.xinshengdaxue.com/posts/1206) |      |

| 2. XSS 跨站脚本攻击                            |      |
| ---------------------------------------- | ---- |
| [**  2-1 什么是 XSS 跨站脚本攻击?](https://fullstack.xinshengdaxue.com/posts/1207) |      |
| [**  2-2 如何防御 XSS?](https://fullstack.xinshengdaxue.com/posts/1208) |      |
| [**  2-3 另一个不小心的漏洞](https://fullstack.xinshengdaxue.com/posts/1209) |      |
| [**  2-4 解法办法](https://fullstack.xinshengdaxue.com/posts/1210) |      |
| [**  2-5 小结](https://fullstack.xinshengdaxue.com/posts/1211) |      |

| 3. CSRF 跨站请求伪造                           |      |
| ---------------------------------------- | ---- |
| [**  3-1 什么是 CSRF 跨站请求伪造?](https://fullstack.xinshengdaxue.com/posts/1212) |      |
| [**  3-2 如何防御？](https://fullstack.xinshengdaxue.com/posts/1213) |      |
| [**  3-3 漏网之鱼](https://fullstack.xinshengdaxue.com/posts/1214) |      |
| [**  3-4 如何防御 POST 类型的 CSRF 攻击？](https://fullstack.xinshengdaxue.com/posts/1215) |      |

| 4. SQL Injection 数据库注入攻击                 |      |
| ---------------------------------------- | ---- |
| [**  4-1 什么是 SQL](https://fullstack.xinshengdaxue.com/posts/1216) |      |
| [**  4-2 什么是 SQL Injection 攻击?](https://fullstack.xinshengdaxue.com/posts/1217) |      |
| [**  4-3 如何防御 SQL 注入攻击 ？](https://fullstack.xinshengdaxue.com/posts/1235) |      |
| [**  4-4 漏网之鱼](https://fullstack.xinshengdaxue.com/posts/1218) |      |

| 5. 大量赋值(Mass Assignment)                 |      |
| ---------------------------------------- | ---- |
| [**  5-1 ActiveRecord 赋值功能](https://fullstack.xinshengdaxue.com/posts/1219) |      |
| [**  5-2 大量赋值与 Rails 表单](https://fullstack.xinshengdaxue.com/posts/1220) |      |
| [**  5-3 攻击示范](https://fullstack.xinshengdaxue.com/posts/1221) |      |
| [**  5-4 修补漏洞](https://fullstack.xinshengdaxue.com/posts/1222) |      |

| 6. 破解加密 Cookie-based Session             |      |
| ---------------------------------------- | ---- |
| [**  6-1 什么是加密 Cookie](https://fullstack.xinshengdaxue.com/posts/1223) |      |
| [**  6-2 Rails 的 secret key](https://fullstack.xinshengdaxue.com/posts/1224) |      |
| [**  6-3 破解示范](https://fullstack.xinshengdaxue.com/posts/1225) |      |
| [**  6-4 如何防御?](https://fullstack.xinshengdaxue.com/posts/1226) |      |

| 7. DoS 拒绝服务攻击                            |      |
| ---------------------------------------- | ---- |
| [**  7-1 什么是 DoS 拒绝服务攻击](https://fullstack.xinshengdaxue.com/posts/1227) |      |
| [**  7-2 如何防御?](https://fullstack.xinshengdaxue.com/posts/1228) |      |

| 8. 安全分析工具                                |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  8-1 安装 brakeman 检测代码](https://fullstack.xinshengdaxue.com/posts/1229) |                                          |
| [**  8-2 安装 bundler-audit 检测套件](https://fullstack.xinshengdaxue.com/posts/1230) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1230#task) |

| 9. 密码是如何存储的？                             |      |
| ---------------------------------------- | ---- |
| [**  9-1 认识散列函数](https://fullstack.xinshengdaxue.com/posts/1231) |      |
| [**  9-2 散列函数的用途](https://fullstack.xinshengdaxue.com/posts/1232) |      |

| 10. HTTPS 加密安全连线                         |      |
| ---------------------------------------- | ---- |
| [**  10-1. 认识非对称加密](https://fullstack.xinshengdaxue.com/posts/1233) |      |
| [**  10-2 结语](https://fullstack.xinshengdaxue.com/posts/1234) |      |

# 1-1 前言

为了让大家可以快速开始进行~~攻击~~，请 Fork 这个项目：<https://github.com/growthschool/hackme-app>，然后 Clone 回去。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/RJ7gTIJqTLWOQtFmp3J3_1-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/RJ7gTIJqTLWOQtFmp3J3_1-1.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bsQSwaFnT0SXT38aPK8E_1-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bsQSwaFnT0SXT38aPK8E_1-2.png)

> 因为等会交作业用 Pull Request，所以你需要用 Fork 把项目复制在你的 Github 帐号下，这样修改后才可以 Push 上去，最后用 Pull Request 交作业。

Fork 后，请依序执行：

`git clone git@github.com:你的帐号/hackme-app.git`
`cd hackme-app`
`bin/setup`
`bundle exec rake dev:fake`

在这个项目中，已经装好了 Devise、Bootstrap、RSpec，并且建立好了以下功能：

- 用户登入、登出
- 用户可以浏览不同活动
- 用户可以针对活动留言
- 管理员可以针对特定留言，进行高亮(Highlight)显示
- 用户可以浏览商品
- 用户可以将商品加入购物车

执行 `rails server`

接着打开浏览器 [http://localhost:3000](http://localhost:3000/)

数据库中已经有三个用户：

帐号: `hacker@example.org`
密码: `12345678`
说明: 这是你，超级骇客

帐号: `ihower@gmail.com`
密码: `12345678`
说明: 这是要被骇的路人

帐号: `admin@example.org`
密码: `12345678`
说明: 这是要被骇的网站管理员

请浏览看看前台其中一个活动页面：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/0pC86VofRmLDzD6Zkm3x_1-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/0pC86VofRmLDzD6Zkm3x_1-3.png)

# 1-2 法律警告

本课程的目的是为了让大家能够更好的保护自己，了解骇客是如何攻击的，进而了解 Rails 是如何进行防御的。所谓「害人之心不可有，防人之心不可无」，看到别人家里没锁门，不代表你可以进去破坏或偷东西。这在每个国家都是犯法的行为！你可以善意地提醒人家没锁门，但是千万不要自以为是越过法律的界线喔。

> [中华人民共和国网络安全法](http://www.npc.gov.cn/npc/xinwen/2016-11/07/content_2001605.htm) 第二十七条 任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。

# 2-1 什么是 XSS 跨站脚本攻击?

我们在「百宝箱 13. Rich Editor 编辑器」有介绍过 [XSS](https://zh.wikipedia.org/zh-cn/%E8%B7%A8%E7%BD%91%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A0%81) 跨站脚本攻击：如果用户可以自己张贴内容到网站上，并且网站会显示出来的话，就有可能有 XSS 漏洞。恶意用户会张贴 JavaScript 代码上来，那么这么当其他用户浏览到这一页时，浏览器就会盲目的执行 JavaScript 代码。

让我们攻击看看，请用 `hacker@example.org` 登入，然后针对一则活动留言，贴上以下 JavaScript 代码：

```
<script>
$.ajax({
  url: $(location).attr('href') + "/comments",
  method: "POST",
  data: {  comment : { content: "啊哈哈哈～你看看你！ (σﾟ∀ﾟ)σﾟ∀ﾟ)σﾟ∀ﾟ)σ" } },
  dataType: "JSON"
})
</script>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/spCHxGm0T1a72SvrzZCV_2-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/spCHxGm0T1a72SvrzZCV_2-1.png)

留言完之后，接下来任何人看到这一页，就会执行这段 Ajax 代码，也跟着留言一次。请多重新整理页面几次看看。

你也可以测试看看其他人浏览会怎么样？你可以用另一个浏览器(例如 Safari)，或是用 Chrome 的 Incognito Windows(无痕模式，这会开启一个干净没有 Cookie 的新视窗)，然后改用 `admin@example.org` 登入，然后浏览刚刚那一个活动...

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pVhhnVfpQhORali1KhpE_2-chrome.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pVhhnVfpQhORali1KhpE_2-chrome.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/j0wwOYnhQ8qwc4Nx7rhk_2-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/j0wwOYnhQ8qwc4Nx7rhk_2-2.png)

`admin` 也会自动张贴留言了....

# 2-2 如何防御 XSS?

要防御说起来简单，就是显示每个用户贴文的地方都要脱逸 HTML，打开 `app/views/events/show.html.erb`

app/views/events/show.html.erb

```
-  <%= raw comment.content %>
+  <%= comment.content %>
```

Rails 默认就会脱逸 HTML 了，用 `raw comment.content` 或 `comment.content.html_safe` 反而是告诉 Rails 不要脱逸 HTML。拿掉 `raw` 之后，就会脱逸显示出原代码，例如 `<` 会变成 `&lt;`。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/1GJCqr1cSja2Ogj1Y6Hk_2-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/1GJCqr1cSja2Ogj1Y6Hk_2-3.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ENHZc8s5T66i5qSGpllR_2-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ENHZc8s5T66i5qSGpllR_2-4.png)

不过这样会完全防止任何 HTML 标籤，例如我们张贴以下这张图片：

```
<img src="http://placehold.it/200x200" />
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/TUL929xbQHaN0UknZsg2_2-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/TUL929xbQHaN0UknZsg2_2-5.png)

一样被脱逸了 :(

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/A36zirZfQ7CaOuHabLkL_2-6.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/A36zirZfQ7CaOuHabLkL_2-6.png)

如果我们还是希望用户可以输入 HTML，就像百宝箱 13. Rich Editor 编辑器的需求，请改用 sanitize 白名单过滤，只允许部分的 HTML 标籤：

app/views/events/show.html.erb

```
-  <%= comment.content %>
+  <%= sanitize comment.content %>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/xahFlNcQgGPo1lW4430z_2-7.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/xahFlNcQgGPo1lW4430z_2-7.png)

# 2-3 另一个不小心的漏洞

请点主选单的修改个人资料，这个地方会不会有漏洞呢?

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/OGu6g0GnTimIzv03Wkdb_2-8.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/OGu6g0GnTimIzv03Wkdb_2-8.png)

回到任一个活动页面：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ogGFNIQTjmKqTWzeXt29_2-9.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ogGFNIQTjmKqTWzeXt29_2-9.png)

发现竟然有漏洞，这段 JavaScript 被执行了。

让我们找找看漏洞出现在哪里，原来是在留言显示用户名称的地方，没有做好脱逸 :(

app/views/events/show.html

```
<div class="panel-heading">
  <%= user_avatar_link(comment.author) %>
</div>
```

app/helpers/users_helper.rb

```
require 'digest/md5'

module UsersHelper

  def user_avatar_link(user)
    # https://cn.gravatar.com/

    email_md5 = Digest::MD5.hexdigest(user.email)
    gravatar_url = "https://www.gravatar.com/avatar/#{email_md5}"

    str = "<div class ='user-link'>" + link_to(image_tag(gravatar_url), user_path(user)) + " " + user.display_name + "</div>"

    str.html_safe
  end

end
```

这个 `user_avatar_link` helper 的目的是输出用户的 [Gravater](https://cn.gravatar.com/) 照片的连结，以及用户的显示名称，而问题就出在 `str.html_safe` 太过放纵了。

但是如果你把 `str.html_safe` 这行拿掉，你会发现整个 Helper 的输出都被脱逸了 :( 不是我们想要的结果。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/dNkDDgeuS2euPQwfxWVQ_2-10.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/dNkDDgeuS2euPQwfxWVQ_2-10.png)

这是因为 Rails 会追踪每个字符串是否是安全的，如果不安全的话，输出时会自动脱逸。不安全的字符串 `+` 安全的字符串，会变成不安全的。由于字符串 `"<div class ='user-link'>"` 默认是不安全的，因此后来累加字符串进来，整个 `str` 都是不安全的，所以 Rails 最后会让整个 `str` 都脱逸，造成图片 img 标籤也无法显示。

# 2-4 解法办法

#### 解法办法一

小心翼翼地在不需要脱逸的地方加上 `.html_safe`

app/helpers/users_helper.rb

```
require 'digest/md5'

module UsersHelper

  def user_avatar_link(user)
    # https://cn.gravatar.com/

    email_md5 = Digest::MD5.hexdigest(user.email)
    gravatar_url = "https://www.gravatar.com/avatar/#{email_md5}"

-   str = "<div class ='user-link'>" + link_to(image_tag(gravatar_url), user_path(user)) + " " + user.display_name + "</div>"
-   str.html_safe

+   "<div class ='user-link'>".html_safe + link_to(image_tag(gravatar_url), user_path(user)) + " " + user.display_name + "</div>".html_safe
  end

end
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/w86gvStkTVKo8BkJUMQ0_2-11.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/w86gvStkTVKo8BkJUMQ0_2-11.png)

#### 解法办法二

可以用 Rails 内建的 `content_tag` helper 产生标籤，结果一样，只是写起来会比字符串相加好看一点：

app/helpers/users_helper.rb

```
require 'digest/md5'

module UsersHelper

  def user_avatar_link(user)
    # https://cn.gravatar.com/

    email_md5 = Digest::MD5.hexdigest(user.email)
    gravatar_url = "https://www.gravatar.com/avatar/#{email_md5}"

-   "<div class ='user-link'>".html_safe + link_to(image_tag(gravatar_url), user_path(user)) + " " + user.display_name + "</div>".html_safe

+   content_tag(:div,
      link_to(image_tag(gravatar_url), user_path(user)) + " " + user.display_name ,
      :class => "user-link" )
  end

end
```

# 2-5 小结

由于 Rails 默认会脱逸 HTML 的关系，所以 Rails 对 XSS 是有了基本的防御。如果不是 Rails 这种的框架帮你默认脱逸的话，网页上只要显示用户的输出，都有可能是个安全漏洞。

不过即使有 Rails 的保护，你也有可能在字符串相加的过程中，不小心太过放纵而造成漏洞，就像这一节所示范的。这时候就必须小心处理那些是安全的字符串、那些是用户输入的不安全字符串。

# 3-1 什么是 CSRF 跨站请求伪造?

请用 `admin@example.org` 帐号登入，浏览任一活动：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/xzif4mY0RHSx4CHkXAHg_3-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/xzif4mY0RHSx4CHkXAHg_3-1.png)

管理员可以给留言 Highlight 高亮，这样就会显示黄色背景。

骇客没有办法办法骗管理员去高亮特定文章呢? 如果还有 XSS 漏洞的话，可以用 XSS 攻击，留下一段 JavaScript 代码去触发那个高亮按钮，只要管理员逛到那一页，执行到 JavaScript 的话，也可以办到这件事情。

不过，上一节我们已经防御好 XSS，这一节我们用另一条攻击手法。请先观察你要高亮那一篇留言：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ufxd4fILRnOPoEdRvjon_3-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ufxd4fILRnOPoEdRvjon_3-2.png)

这一篇留言的ID是 522，所以要骗管理员去高亮这篇留言，就是要骗管理员的浏览器去打 `/events/92/comments/522/highlight` 囉，这件事情其实很简单，骇客留言一下：

```
<img src="/events/92/comments/522/highlight">
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/tA2uiHPVR4GsxUU8sbcW_3-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/tA2uiHPVR4GsxUU8sbcW_3-3.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Z9iRHVb0R02iZnVSFpi2_3-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Z9iRHVb0R02iZnVSFpi2_3-4.png)

上一节防止 XSS 时，有用 sanitize 来做白名单的过滤，而 `img` 标籤是一个白名单放行的标籤，因此这个图档浏览器会发送 Request 请求到 `/events/92/comments/522/highlight` 去抓图。当然，我目前的身份是 `hacker@example.org` 是没有权限高亮的，但是已经挖了一个坑准备给管理员跳。

> 在 `app/controllers/comments_controller.rb` 中，我们有用 `before_action :require_admin!, :only => [:highlight]` 检查调用 highlight 方法必须有管理员权限。

接着请切换到管理员 `admin@example.org` 身份，去浏览这一页，然后重新整理页面一次：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/yKUjNFM8SVK4wuRsd4UO_3-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/yKUjNFM8SVK4wuRsd4UO_3-5.png)

这篇文章就被高亮了..... 用管理员的权限去高亮的。浏览器真好骗啊。

这种攻击，就叫做[CSRF 跨站请求伪造](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)，骇客挖坑让有权限的用户去跳。

# 3-2 如何防御？

首先，这个高亮会这么好触发的原因，在于我们把它设计成 `GET` 请求，这样骇客用 `img` 标籤太容易就能诱骗浏览器了。让我们把它改成 `POST` 操作。

```
  resources :events do
    resources :comments do
      member do
-       get :highlight
+       post :highlight
      end
    end
  end
```

以及

app/views/events/show.html.erb

```
-  <%= link_to "Highligh", highlight_event_comment_path(@event, comment), :class => "btn btn-default" %>
+  <%= link_to "Highligh", highlight_event_comment_path(@event, comment), :method => :post, :class => "btn btn-default" %>
```

> 在 Web API 设计实作课程的 [3-2 什么是 REST API](https://fullstack.xinshengdaxue.com/posts/838) 之中，也有讲述到 GET 和 POST 的差异：GET 只能单纯读取资料，不应该修改资料。而 POST 则是执行某个操作，会修改到服务器的资料。

这样的话，用 `img` 标籤就不能攻击了，骇客必须用到 JavaScript 才能让管理员的浏览器去做 POST 请求。但是要用 JavaScript 的话，就必须存在有上一节的 XSS 漏洞才行了。

# 3-3 漏网之鱼

CSRF 之所以危险的地方，在于攻击方可以在其他网站挖坑，只要管理员浏览到那一页，一样可以执行这个攻击。

所以就算上一节我们已经改成 POST 了，而且这个网站也不存在 XSS 漏洞，骇客依然有办法去诱使管理员的浏览器去 POST 操作。例如骇客知道管理员常去看「百度贴吧」，然后假设「百度贴吧」有个 XSS 漏洞可以贴 JavaScript 代码，那么骇客可以贴文：

```
<iframe style="display:none" name="csrf-frame"></iframe>

<form method='POST' action='http://localhost:3000/events/92/comments/522/highlight' target="csrf-frame" id="csrf-form">
  <input type='submit' value='submit'>
</form>

<script>document.getElementById("csrf-form").submit()</script>
```

这段 HTML 和 JavaScript 代码会自动 submit 到隐藏的 iframe 视窗里面，所以管理员是没有感觉的。只要管理员浏览到这段贴文的网页，浏览器就会自动 POST 出去了.... 达成高亮效果。

# 3-4 如何防御 POST 类型的 CSRF 攻击？

那要如何防御呢？我们需要针对所有非 GET 的操作，都加上额外的 token 验证码参数，检查用户浏览器当初真的是从网站上的某个表单送出的，而不是不小心触发的 CSRF 攻击。

这个防御功能 Rails 已经内建了，请修改 `app/controllers/application_controller.rb`，打开 `protect_from_forgery`

app/controllers/application_controller.rb

```
  class ApplicationController < ActionController::Base

    # protect_from_forgery with: :exception
+   protect_from_forgery with: :exception
```

在 Rails 产生的表单中，就有带这个参数 `authenticity_token`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/CWOAeWOaS4pAEApihUoO_3-6.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/CWOAeWOaS4pAEApihUoO_3-6.png)

如果是 Ajax 请求，jQuery 则会去抓 meta 中的 `csrf-token` 参数附加上去：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/kK2BE2SMTJ2qI4NiaSSp_3-7.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/kK2BE2SMTJ2qI4NiaSSp_3-7.png)

透过这种机制，骇客在其他网站挖的坑因为没有这个`authenticity_token`参数，送过来的时候就会被 Rails 阻挡住，会有以下的错误画面：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/7MnnSijMSdCm8zBg47jj_3-8-422.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/7MnnSijMSdCm8zBg47jj_3-8-422.png)

这也是为什么有时候逛 Rails 制作的网站，表单如果放太久才送出，有时候也会出现这个错误画面，因为这个 `authenticity_token` 过期失效了。

# 4-1 什么是 SQL

在 Rails 中我们利用 ActiveRecord 语法来操作数据库的资料，例如查询所有活动：

`@events = Event.all`

这段 Ruby 代码，实际上会被转成数据库语言 [SQL](https://zh.wikipedia.org/zh-cn/SQL) 来对数据库做查询 ：

`SELECT "events".* FROM "events"`

在 Rails log 中，只要对数据库做任何 CRUD 操作，都会是一个 SQL，例如这些都是 SQL

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/2P3yfiytQS6PMtmaHwdb_4-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/2P3yfiytQS6PMtmaHwdb_4-1.png)

> 之后会有数据库课程教各位理解数据库原理和 SQL，理解 SQL 就可以做出比较复杂的数据分析功能，可以把 ActiveRecord 数据查询用的更好。

# 4-2 什么是 SQL Injection 攻击?

在实际的网站应用中，我们会将用户输入的参数，动态地组合出 SQL 来对数据库查询。例如：

`@registrations = Registration.where( :status => params[:status] )`

就会根据用户浏览器传过来的 `params[:status]` 参数不同，而组合出不同的 SQL 句子。假如参数 `params[:status]` 是 `pending`，那这个 SQL 句就会是：

`SELECT "registrations".* FROM "registrations" WHERE "registrations"."status" = 'pending'`

### 实际攻击示范

在本课程的范例中，有一个功能是关键字查询留言，请浏览至任一个活动页面：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/2yEqOPZRuKISZQSStiOz_4-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/2yEqOPZRuKISZQSStiOz_4-2.png)

按下 Search 按钮后，对应的处理代码在 `app/controllers/events_controller.rb` 中的 show action:

app/controllers/events_controller.rb

```
 @comments = @comments.where( "comments.content LIKE '%#{params[:keyword]}%'")
```

这段 ActiveRecord 语法会被转成如以下的 SQL 句：

```
SELECT "comments".* FROM "comments" WHERE "comments"."event_id" = ? AND (comments.content LIKE '%这是搜寻关键字%')  [["event_id", 95]]
```

很不幸的，这种写法存在 SQL Injection 漏洞，用以下的关键字就可以进行攻击，删除所有留言数据：

```
sorry'); DELETE * FROM comments; --
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9rU0g4kwRuOkcbxbQdnE_4-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9rU0g4kwRuOkcbxbQdnE_4-3.png)

按下 Search 按钮后，悲惨的事情就发生了，所有留言都被删除了 😳😳😳😳😳

这是怎么办到的？我们把攻击的关键字代入 SQL 句子，就会变成：

`SELECT "comments".* FROM "comments" WHERE "comments"."event_id" = ? AND (comments.content LIKE '%sorry'); DELETE * FROM comments; --%') [["event_id", 95]]`

这会被数据库解读成三个 SQL 句子：

1. `SELECT "comments".* FROM "comments" WHERE "comments"."event_id" = ? AND (comments.content LIKE '%sorry');`
2. `DELETE * FROM comments;`
3. `--%') [["event_id", 95]]`

其中第二句就达成删除的效果，第三句的 `--` 是 SQL 的注解。

由此可知，SQL Injection 数据库注入攻击可以破坏我们的数据库、修改数据资料、跳过登入密码检查等等，是非常有破坏力的攻击行为。

# 4-3 如何防御 SQL 注入攻击 ？

跟防御 XSS 一样的道理，所有用户传进来要代入 SQL 的参数，都必须加以逸出：

app/controllers/events_controller.rb

```
-  @comments = @comments.where( "comments.content LIKE '%#{params[:keyword]}%'")

+  keyword = ActiveRecord::Base::connection.quote_string( params[:keyword] )
+  @comments = @comments.where( "comments.content LIKE '%#{keyword}%'")
```

不过代入用户参数的情景实在太常见了，在 Rails 会通常会用特别的写法来指定 SQL 条件，让 Rails 能够知道哪一部分需要逸出：

app/controllers/events_controller.rb

```
-  @comments = @comments.where( "comments.content LIKE '%#{params[:keyword]}%'")
+  @comments = @comments.where( "comments.content LIKE ?", "%#{params[:keyword]}%")
```

其中 `?` 代表要代入的参数。

最后的 SQL 句子变成：

```
SELECT "comments".* FROM "comments" WHERE "comments"."event_id" = ? AND (comments.content LIKE '%sorry''); DELETE * FROM comments; --%')  [["event_id", 95]]
```

其中 `sorry')` 变成 `sorry'')` 了，这样数据库就知道这此单引号不是结束的单引号。

> 你可以再测试看看还会不会有这个漏洞，送出后会先看到没有任何资料是正常的，因为查不到任何留言是符合关键字。请回首页再进来，留言还是正常没有被删除掉。

另一种常见的写法是用 Hash，例如

```
@registrations = Registraion.where( "status = '#{params[:status]}' ) # 自己组字符串，这不安全，有 SQL 注入漏洞

@registrations = Registraion.where( :status => params[:status] ) # Hash 写法，这是安全的
@registrations = Registraion.where( "status = ?", params[:status] ) # Array 写法，这是安全的

```

# 4-4 漏网之鱼

上一节中我们示范了在 `where` 语法中，用 Hash 或 Array 写法可以自动做逸出。但是在 ActiveReocrd 中，还有一些方法并没有帮我们做逸出，包括 `order`、`pluck` 等等，详见 [Rails SQL Injection](https://rails-sqli.org/)。

所以当我们需要将用户传过来的参数传进去时，除了逸出之外，也可以采用白名单的过滤方式。

在范例中，可以根据用户指定的顺序来做排序：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/wmMSHd62RnQnxiWbhfKV_4-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/wmMSHd62RnQnxiWbhfKV_4-4.png)

用户可以点不同连结来进行排序，会传不同 `sort` 参数。用户传过来的参数都是不可以信任的，用户大可以直接修改网址就可以传任意参数进来 🙀🙀🙀

请修改 `app/controllers/events_controller.rb`，我们只能允许特定的查询参数：

app/controllers/events_controller.rb

```
-  if params[:sort] # 本来这样有漏洞，你太相信用户传进来的参数了
+  if params[:sort] && ["id DESC", "id ASC"].include?(params[:sort])  # 只有白名单内的参数可以用
    @comments = @comments.order(params[:sort])
  end
```

# 5-1 ActiveRecord 赋值功能

大量赋值(Mass Assignment)是 ActiveRecord 的一个功能，例如以下是新建 Event 的代码：

```
event = Event.new
event.name = "Foo"
event.description = "Bar"
event.save
```

这个 `new` 可以接受 Hash 来做赋值，上述的代码等同于：

```
Event.new( { :name => "Foo", :description => "Bar" } )
```

另外，放在方法参数最后面的 Hash，它的 `{ }` 是可以省略的，因此这又等同于：

```
Event.new( :name => "Foo", :description => "Bar" )
```

这种用法就叫做大量赋值(Mass Assignment)。除了 `new` 之外，`update` 也是一样的，这个我们在做 CRUD 时就有看过，例如：

```
event = Event.first
event.name = "Foo"
event.description = "Bar"
event.save
```

等同于

```
event = Event.first
event.update( :name => "Foo", :description => "Bar" )
```

# 5-2 大量赋值与 Rails 表单

这个功能的主用用途是可以跟 Rails `form_for` 方法产生的表单做配套，在以下的 Event 表单中，Rails 故意将 HTML 输入框 input 的 `name` 命名成 `event[name]` 和 `event[description]`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/gNJTNOwpQUKrR6pgsccI_5-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/gNJTNOwpQUKrR6pgsccI_5-1.png)

这样送出后，Rails 会解析成 `params[:event]` 刚好是一个 Hash，可以跟大量赋值用法配套在一起：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MlJegER3y7OdbjesqaSg_5-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MlJegER3y7OdbjesqaSg_5-2.png)

在早先的 Rails 版本中，可以直接把 `params[:event]` 丢进 `new`或 `update` 中，例如：

`Event.new(params[:event])`

`@event.update( params[:event] )`

不过这样却存在一个大漏洞，用户可以自行修改表单 input 的 name。这很简单你用 Chrome 除错器就可以办到了，点该 input 的 name 就可以改：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/r79h5T4SQ15rSZpoaU7M_5-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/r79h5T4SQ15rSZpoaU7M_5-3.png)

这里改成 `event[user_id]`，送出之后如果直接调用`@event.update( params[:event] )`的话，那就修改到 `user_id` 了 🙀🙀🙀

因此在新版的 Rails 中，必须经过 [Strong Parameters](https://github.com/rails/strong_parameters) 过滤后，才能传进 `new` 或 `update` 之中，以下这段代码大家都熟悉：

```
  def update
    @event = Event.find(params[:id])

    if @event.update(event_params)
      redirect_to admin_events_path
    else
      render "edit"
    end
  end

  protected

  def event_params
    params.require(:event).permit(:name, :description)
  end
```

其中 `params.require(:event).permit(:name, :description)` 就是在做白名单的检查，只能允许 `params[:event][:name]` 和 `params[:event][:description]`

# 5-3 攻击示范

不过即使有 [Strong Parameters](https://github.com/rails/strong_parameters) 的保护，还是可能因为程序员漫不经心而存在漏洞。让我们来攻击看看。

请点选主选单上的修改个人资料，不过我们不是想要修改暱称，我们想要来修改 Role 角色....

1. 透过 Chrome 除错器将暱称 input 的 name 为 `user[role]`
2. 输入框输入 `admin`
3. 按下送出

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ilSd1SFgTTO7pN4W2TvE_5-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ilSd1SFgTTO7pN4W2TvE_5-4.png)

然后 hacker 就变成 admin 了，你现在可以在主选单上点进后台.... 🙀🙀🙀🙀🙀

# 5-4 修补漏洞

让我们看看到底哪里出了漏洞，请打开 `app/controllers/users_controller.rb`，问题出在 `params.require(:user).permit(:nickname, :role)` 这一行太过放纵了，竟然允许用户可以传参数 `role` 进来... :(

虽然在网页表单上面没有 `role` 输入框，但是用户依然可以自己想办法把参数传进来。

让我们修补这个漏洞：

app/controllers/users_controller.rb

```
  def update
    @user = current_user

    if @user.update(user_params)
      redirect_to user_path(@user)
    else
      render "edit"
    end
  end

  protected

  def user_params
-    params.require(:user).permit(:nickname, :role)
+    params.require(:user).permit(:nickname)
  end
```

再测试一次，骇客就不能修改 role 了。在 Rails log 之中，会出现

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/7tNCd9v4ReeoZ4mAaoiq_5-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/7tNCd9v4ReeoZ4mAaoiq_5-5.png)

`Unpermitted parameter: role` 的意思就是用户传了一个 `role`参数进来被过滤掉了。

从这个漏洞我们也可以了解为什么前台、后台的 controller 会拆开的一个原因，就是前后台的 Strong Parameters 参数白名单是不一样的。给前台用户的 `users_controller` 不允许修改 role，但是后台 `admin::users_controller` 是可以允许修改 role 的。如此拆分才会清楚不会搞混造成漏洞。

# 6-1 什么是加密 Cookie

[Cookie](https://zh.wikipedia.org/zh-cn/Cookie) 是浏览器的一个功能，让服务器可以留数据在用户浏览器上，这样 Rails 就可以追踪识别不同登入用户。浏览器每次对服务器的请求，都会附带这个 Cookie 数据。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/8Q50gisARByEBfKgIE2u_6-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/8Q50gisARByEBfKgIE2u_6-1.png)

例如用户登入时，输入帐号、密码，服务器检查没问题后，就会设定该浏览器的一个 Cookie 是 user_id 是 123
接下来用户浏览器对这个网站的任何请求，就会附带这个 Cookie 参数，那么服务器就知道这个浏览器是用户 123

不过，这是简化的版本，相信大家都知道用户是不可以相信的，存在用户端的 Cookie 也是不可以相信的，骇客可以修改 user_id 变成 1，那不就变身为管理员了吗?

因此我们需要针对 Cookie 做加密，用一种叫做[对称密钥加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)的算法，用一把密钥来做加密，并且用这个密钥可以解密回来。

例如，以下是一段用 [DES](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96) 算法加密的 Ruby 代码，将 `{message: "这是密文"}` 进行加密，你可以进 `irb` 实验看看：

```
key = 'baRudSWouiTVfu0jwXfYDg==' # 一段随机数是密钥


# 加密

require 'json'
require 'base64'
require 'openssl'
text = {message: "这是密文"}.to_json
cipher = OpenSSL::Cipher::DES.new("ECB")
cipher.encrypt
cipher.key = Base64.strict_decode64(key)
encrypted = cipher.update(text) + cipher.final
data = Base64.strict_encode64(encrypted)
```

最后得到的 data 是 `"pxsTws7UtD7bOwCl6+FeLQEBJWqNTb3RSo2V84/udL0="` 就是一段加密后的文字。

以下是解密的代码：

```
key = 'baRudSWouiTVfu0jwXfYDg==' # 要同一把密钥才能解开


require 'json'
require 'base64'
require 'openssl'

encrypted_string = Base64.decode64(data)
cipher = OpenSSL::Cipher::DES.new("ECB")
cipher.decrypt
cipher.key = Base64.strict_decode64(key)
result = cipher.update(encrypted_string) + cipher.final
JSON.parse(result)
```

最后就解回 `{message: "这是密文"}` 了。

在不知道密钥的情况下，要破解回本来的秘文是非常困难的，需要耗费非常强大的超级电脑 CPU 运算资源才能破解。

# 6-2 Rails 的 secret key

在 Rails 中，默认的 Session 实际上就是加密的 Cookie，我们在购物车教程中，使用了 `session[:cart_id]` 来储存追踪用户是哪一台购物车。

刚刚我们学到要能解密的关键是那个密钥，而在 Rails 中，这一把密钥就存在 `config/secrets.yml`

```
development:

  secret_key_base: a875bedfd1ba629c6c6039597cfd89a5bfb34fc440a0203d649bbd9e06de3e1939a4a586e1ed893108157688782b86b25223853a5b140aba7a21e5df675bed22


test:

  secret_key_base: 162ffbf8a8079326e46d6f6cf946de5c67a5c2372120a642b10c6d14b413f78fda09870a0697315ac067cf6bb6924b7ae16841894f3919ef09de65238d85f712


# Do not keep production secrets in the repository,

# instead read values from the environment.

production:

  secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>
```

这个 YAML 还根据不同环境区分，本机开发用的密钥，和部署 production 环境用的密钥是不同的。

这把密钥非常重要，不能外洩。知道密钥的话，用户就可以解开 Cookie，偷看里面的内容，甚至修改存回去，这样服务器就会被骗过去....

让我们看看如果外洩会怎么样，例如你把 production 正式环境的密钥 push 到 github 公开的项目....

# 6-3 破解示范

好，，假设我们已经知道密钥是 `a875bedfd1ba629c6c6039597cfd89a5bfb34fc440a0203d649bbd9e06de3e1939a4a586e1ed893108157688782b86b25223853a5b140aba7a21e5df675bed22`

接着打开 Chrome 除错器，复制下 `_hackme-app_session` 这段 Cookie 的值，例如：

```
V0JxRVF2UjQ4ZUx5M0tYMFgxN3ZIK092Yy9aY1RSNGJFZ3FIdDgvbUdOZjJxd0tJWHMyRk12bjRpRmMyRm85Qko1bXAwSThHZVA1TnhhZHhNb0hNL3FJQ0c3cVpGVUJ0VVY3N28zU3l6bkRCQkJXdGQ0LzRqR2tCeVVMSzNYbWtIRm1ycEhIejN2L1FmUTFIMktvNGpmWk8yOHFyQXUxZXlBMXd2SHlkV29RaENUdWwxSWsxdlBHVHF2Q0hTYXFoc0RydUd4MXJJMzQ5dm5ZUS9vYURnaWdubnduc1cwK3ExZldpMFVRSmZkUXZRa0FvR3FqQVplZEordE10MzVqTS0tSUs4NCtsZjNRZGRDMjM1ajVzQkRHQT09--f99ee52c228793955481cf56604ca293c96989a4
```

进 `rails console` 贴上：

```
def decrypt_session_cookie(cookie, key)
  cookie = CGI::unescape(cookie)
  salt         = "encrypted cookie"
  signed_salt  = "signed encrypted cookie"

  key_generator = ActiveSupport::KeyGenerator.new(key, iterations: 1000)
  secret = key_generator.generate_key(salt)
  sign_secret = key_generator.generate_key(signed_salt)

  encryptor = ActiveSupport::MessageEncryptor.new(secret, sign_secret, serializer: ActiveSupport::MessageEncryptor::NullSerializer)
  encryptor.decrypt_and_verify(cookie)
end

key = 'a875bedfd1ba629c6c6039597cfd89a5bfb34fc440a0203d649bbd9e06de3e1939a4a586e1ed893108157688782b86b25223853a5b140aba7a21e5df675bed22'
cookie = 'V0JxRVF2UjQ4ZUx5M0tYMFgxN3ZIK092Yy9aY1RSNGJFZ3FIdDgvbUdOZjJxd0tJWHMyRk12bjRpRmMyRm85Qko1bXAwSThHZVA1TnhhZHhNb0hNL3FJQ0c3cVpGVUJ0VVY3N28zU3l6bkRCQkJXdGQ0LzRqR2tCeVVMSzNYbWtIRm1ycEhIejN2L1FmUTFIMktvNGpmWk8yOHFyQXUxZXlBMXd2SHlkV29RaENUdWwxSWsxdlBHVHF2Q0hTYXFoc0RydUd4MXJJMzQ5dm5ZUS9vYURnaWdubnduc1cwK3ExZldpMFVRSmZkUXZRa0FvR3FqQVplZEordE10MzVqTS0tSUs4NCtsZjNRZGRDMjM1ajVzQkRHQT09--f99ee52c228793955481cf56604ca293c96989a4'

j = decrypt_session_cookie(cookie, key)
```

就会解密出一段 JSON 告诉我们用户 id 是 48，购物车 `cart_id` 是 501。

```
"{\"session_id\":\"744813165ee90c30650c4ab8338d8140\",\"cart_id\":501,\"warden.user.user.key\":[[48],\"$2a$11$tpfEqlcCqD/8JRWPtvZTzu\"],\"_csrf_token\":\"zMPrCyTnxvpsPY0OWhPi8sM2suOa3dUFk4HHDyedbIs=\"}"
```

以下代码会修改 cart_id 并可以加密回去：

```
def encrypt_session_cookie(value, key)
  salt         = "encrypted cookie"
  signed_salt  = "signed encrypted cookie"

  key_generator = ActiveSupport::KeyGenerator.new(key, iterations: 1000)
  secret = key_generator.generate_key(salt)
  sign_secret = key_generator.generate_key(signed_salt)

  encryptor = ActiveSupport::MessageEncryptor.new(secret, sign_secret, serializer: ActionDispatch::Cookies::JsonSerializer)
  encryptor.encrypt_and_sign(value)
end

h = JSON.parse(j)
h["cart_id"] = 1
encrypt_session_cookie(h, key)
```

> 加解密的代码是从 Rails 源代码中挖出来的

最后得到 cookie 值，最后一步就是设定回 Chrome 浏览器。不过 Chrome 默认不允许我们改 Cookie，你可以装一个 extension 是 [Cookie Inspector](https://chrome.google.com/webstore/detail/cookie-inspector/jgbbilmfbammlbbhmmgaagdkbkepnijn)，然后把刚刚改过的 cookie 值设进去，这样就会骗过服务器了。

# 6-4 如何防御?

最基本的当然是不要外洩密钥，如果外洩了，请马上换一个密钥。换密钥会强迫所有用户登出，因为大家的 Cookie 都会因为无法解密回来而失效。

如果你的网站需要非常高的安全性，则不建议使用 Cookie 加密来做 Session。在 Rails 可以更换 Session 存储的方式，例如换成 [Active Record's Session Store](https://github.com/rails/activerecord-session_store)。这会将 Session 数据存在数据库中，而不是 Cookie 之中，这样骇客就完全无从下手了。

打开 `config/initializers/session_store.rb` 观察看看：

config/initializers/session_store.rb

```
Rails.application.config.session_store :cookie_store, key: '_hackme-app_session'
```

这个设定档就是在设定 Session 的 cookie key 叫做 `_hackme-app_session`，而且使用 `cookie_store` 机制来存储。

# 7-1 什么是 DoS 拒绝服务攻击

想像你今天开一间书店，恶意的对手找了跑腿100人在你的店门口只看不买，这一种攻击就叫做 [DoS 拒绝服务攻击](https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A)。不像前几章，骇客的目的是窃取资料或是修改资料，DoS 攻击的目的是让你做不成生意，让你的网站无法服务正常用户。

攻击的手法就是暴力，只要不断地发送 HTTP 请求让服务器忙不过来即可。用浏览器不断重新整理太慢了，让我们安装一个 [wrk](https://github.com/wg/wrk)，这是一个量测 HTTP 服务器效能的压力测试工具：

执行 `brew install wrk`

执行 `wrk -t12 -c400 -d30s http://localhost:3000/products`

这会在 30 秒内，同时平行发送 12 个 HTTP 请求，并保持 400 个 HTTP 连线不中断的速度，进行 `http://localhost:3000/products` 的压力测试。

```
Running 30s test @ http://localhost:3000/products
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   468.83ms  168.30ms 888.55ms   63.89%
    Req/Sec     3.12      3.07    10.00     65.31%
  50 requests in 30.06s, 1.30MB read
  Socket errors: connect 0, read 319, write 0, timeout 14
  Non-2xx or 3xx responses: 4
Requests/sec:      1.66
Transfer/sec:     44.25KB
```

本机跑的 `rails server` 超不耐打的，这个网站基本上是废了，你用浏览器已经无法正常浏览 `http://localhost:3000` 了。

> 强烈警告，对自己的网站打叫做"压力测试"，对别人的网站打可是"干扰他人网络正常功能"，是犯法的行为。请不要以身试法。

# 7-2 如何防御?

DoS 其实是不太好防御的攻击，因为并不是因为网站有什么漏洞造成的。大方向只能想办法去辨识攻击方的样态，然后进行封锁。实务上需要临场反应，碰到了见招拆招。

封锁攻击方的 IP 网络地址是最基本的手法，问题就出在样态可能很多种，例如 DDoS (分布式DoS)就是利用很多台被骇客控制的中毒电脑，同时进行攻击，那么来源 IP 就很多，防御方就不容易判断哪一些是正常用户流量、哪一些是恶意的。

在 Rails 中，可以安装 [rack-attack](https://github.com/kickstarter/rack-attack) gem，这可以设定当特定 IP 位址就某一段时间内存取太多次的话，自动进行封锁：

> 不过困难点在于太多次是多少次，设太低会阻挡到正常用户，例如有些公司组织很可能是很多人共享同一个 IP 位址来上网的，透过 VPN 科学上网的话，来源 IP 也是很多人共享的。但是设太高又没效果。

编辑 `Gemfile`

```
+  gem 'rack-attack'
```

执行 `bundle`

编辑 `config/application.rb`

config/application.rb

```
+     config.middleware.use Rack::Attack
```

新增 `config/initializers/rack-attack.rb`

config/initializers/rack-attack.rb

```
class Rack::Attack

  throttle('req/ip', :limit => 180, :period => 1.minutes) do |req|
    req.ip
  end

  ### Prevent Brute-Force Login Attacks ###


  # The most common brute-force login attack is a brute-force password

  # attack where an attacker simply tries a large number of emails and

  # passwords to see if any credentials match.

  #

  # Another common method of attack is to use a swarm of computers with

  # different IPs to try brute-forcing a password for a specific account.


  # Throttle POST requests to /login by IP address

  #

  # Key: "rack::attack:#{Time.now.to_i/:period}:logins/ip:#{req.ip}"

  throttle('logins/ip', :limit => 5, :period => 20.seconds) do |req|
    if req.path == '/users/sign_in' && req.post?
      req.ip
    end
  end

  # Throttle POST requests to /login by email param

  #

  # Key: "rack::attack:#{Time.now.to_i/:period}:logins/email:#{req.email}"

  #

  # Note: This creates a problem where a malicious user could intentionally

  # throttle logins for another user and force their login requests to be

  # denied, but that's not very common and shouldn't happen to you. (Knock

  # on wood!)

  throttle("logins/email", :limit => 5, :period => 20.seconds) do |req|
    if req.path == '/users/sign_in' && req.post?
      # return the email if present, nil otherwise

      req.params['email'].presence
    end
  end

end
```

重启服务器。以上设定包括：

1. 一分钟内，一个 IP 位址只能存取 180 次
2. 针对 `/users/sign_in` 这个登入网址，20 秒内只能尝试登入 5 次
3. 针对 `/users/sign_in` 这个网址，同一 email 在 20 秒内只能尝试登入 5 次

另外可以做的事情就是，改进网站效能：假如你有一个页面效能很烂，需要跑好几秒，这么这就是网站 DoS 的弱点，因为骇客只要去打这个页面就有最好的攻击效果。

如果真的面临大量的DDoS 攻击，就不是Rails 应用层级可以处理得了，必须购买专门的网络防火墙，例如[百度安全](http://anquan.baidu.com/pages/ddos.html)、[云盾DDoS高防IP](https://intl.aliyun.com/zh/product/ddos-pro)等等云服务商的产品。

# 8-1 安装 brakeman 检测代码

[brakeman](https://github.com/presidentbeef/brakeman) 是一个 Rails 的工具可以分析代码，找出可能有漏洞的地方。

修改 `Gemfile`

```
  group :development do
+    gem 'brakeman'
```

执行 `bundle`

执行 `brakeman`，就会分析你的代码，列出"可能"有漏洞的地方：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FKULBIUCTemz0A82LlO2_8-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FKULBIUCTemz0A82LlO2_8-1.png)

> brakeman 报表结果仅供参考，不表示必然有漏洞。需要一条一条实际检查看看。

# 8-2 安装 bundler-audit 检测套件

除了自己写的代码有可能有漏洞之外，安装的 gem 也有可能爆出安全性漏洞。透过 bundler-audit 这个 gem 可以帮忙检查有没有套件有已知的漏洞需要升级。

修改 `Gemfile`

```
  group :development do
+    gem 'bundler-audit'
```

执行 `bundle`

执行 `bundle-audit`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5zgyzSq5REaICSpf5OXf_8-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5zgyzSq5REaICSpf5OXf_8-2.png)

目前没有需要升级的套件。如果有的话，请执行 `bundle update 套件名称` 就可以进行升级。

#### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/56)：[作业](https://fullstack.xinshengdaxue.com/tasks/324)

已有 10 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/324/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/324)

请 Fork 这个项目：<https://github.com/growthschool/hackme-app>，然后 Clone 回去，修好以下漏洞：

1. 修好 XSS
2. 修好 CSRF
3. 修好 SQL injection
4. 修好 Mass Assignment
5. 安装 breakman 和 bundler-audit

最后用 Pull Request 交作业，请贴上 Github Pull Request 的网址。

# 9-1 认识散列函数

散列函数是一种能将数据变成摘要(digest)的算法，执行 `irb`，然后输入以下代码实验看看：

```
require 'digest'
Digest::SHA1.hexdigest '12345678'
```

得到 `"7c222fb2927d828af22f592134e8932480637c0d"`

散列函数有一些特性：

1. 相同的数据，每次都会得到一样的摘要
2. 是单向的，无法逆推：只知道摘要的话，没有办法能够透过计算知道本来的数据长怎样。例如给你 `7c222fb2927d828af22f592134e8932480637c0d`，没有算法可以逆推回来。除非有一个对照的字典。

# 9-2 散列函数的用途

[散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)非常有用，可以拿来快速比较两个文档是否相同，而不需要实际比较文档内容，例如：

1. Git 每次的 commit，都会有一个摘要。不同的摘要就代表 commit 内容不同。Git 用这个摘要值当作每次 commit 的唯一识别 ID。
2. 网络传档的时候，透过比较这个摘要，就可以知道下载了完整正确的档案。
3. 在 Rails 中，Asset pipeline 会将 CSS 和 JavaScript 压缩，档名就是透过散列函数产生的。这是因为浏览器会缓存静态档案，如果 CSS/Javascript 内容有修改的话，用户浏览器可能不知道有新版而使用到旧的 CSS/JS 档案。但是因为档名用了散列函数的关系，内容一改档名就会变得不一样，那么浏览器就会下载新的档案了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/4zxGcrmNRCG4BgiySHAo_9-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/4zxGcrmNRCG4BgiySHAo_9-3.png)

1. 存储用户密码。大家已经会用 Devise 在 Rails 中实做 User Model，在 users table 中实际的字段是 `encrypted_password`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/8UURspY6Rc2nBum563xr_9-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/8UURspY6Rc2nBum563xr_9-1.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/m7jUkAkFRtuW7ZIZmre4_9-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/m7jUkAkFRtuW7ZIZmre4_9-2.png)

用户注册时输入的密码，在实际存储进数据库时，会先经过散列函数，变成摘要值。数据库里面没有存用户的明码，而是存密码摘要后的值。

而下次用户要登入的时候，将用户输入的密码摘要一次，与数据库中存的密码摘要进行比对，就可以知道密码对不对了。

这样的好处是什么呢?

1. 数据库不会存用户的明码，所以即使是数据库管理员，也不会知道用户真正的密码是什么。知道 `encrypted_password` 并没有什么用，因为我们无法逆推。也无法用这个 `encrypted_password` 做登入。
2. 万一数据库整个外洩了，骇客也无法知道用户的密码

不过，目前是市面上仍有很多网站是直接存储用户明码，这会造成用户隐私很大的危害。因为管理员或骇客(如果数据库外洩)可以直接看到你密码，然后很多人在不同网站中，会沿用一样的密码。

要怎么判断一个网站有没有存明码呢？只要试试看忘记密码程序即可，如果网站直接将你的密码寄给你，那就代表他的
数据库存明码。如果网站要求你重新设定密码(就像 Devise 一样)，就表示这网站有安全意识。

# 10-1. 认识非对称加密

近年来由于上网安全意识的提升，越来越多的网站使用 HTTPS 加密连线，网址像这样：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FQaKnbDVTyaoqrilCA3M_10-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FQaKnbDVTyaoqrilCA3M_10-1.png)

这个原理是什么呢? 浏览器和服务器之间，是如何安全连线的？如何保障中间传输的过程，不会被人偷听、被人修改内容。

> 没有加密的 HTTP 连线，可以透过监听网络封包，就可以知道浏览器传输的内容。例如在咖啡厅上网，骇客可以透过监听无线网络，看到你上网的一举一动。有些咖啡厅可以在网页中置入广告 Banner，就是因为连线是走 HTTP 未加密的关系，所以很容易就可以修改网页内容。

我们在 6-1 教过什么是[对称密钥加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)算法，透过密钥就可以传输密文。

但是对称密钥加密方法，在浏览器和服务器连线的情境，有个致命的缺点，就是一开始连线时如何交换密钥。双方都要知道密钥，才能知道对方讲了什么话。

既然一开始连线就是不安全的，在把密钥告诉对方的过程中，这个密钥也就外洩了...

所幸聪明的数学家发明了[非对称加密](https://zh.wikipedia.org/zh-cn/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)，可以在不交换密钥的情况下，解决这个问题。

在非对称加密算法中，会有两把钥匙，一把叫做公钥、一把叫做密钥。

- 透过公钥加密的密文，只有密钥能够解开
- 透过密钥加密的密文，只有公钥能够解开

服务器会将公钥公开给浏览器知道，浏览器会用公钥加密内容，传给服务器，服务器用密钥解开。反之服务器用密钥加密，浏览器用公钥解开。如此就解决了一开始密钥交换的问题。

> 这种方式也用在 SSH 连线认证和加密连线 1. 在部署 Linux 服务器时，我们会将自己的公钥放在服务器上，这样登入的时候就不需要打帐号密码，服务器就能认证你 2. 在 Git 之中，我们会将自己的公钥放在 Github 上，这样 git push 和 pull 时，Github 就能做认证。

剩下信任问题，我们怎么知道这个公钥真的代表这个网站主？这就是为什么我们需要申请或购买网站安全凭证(SSL certificate)的原因。网站主需要向权威机构购买申请或购买，经过一些认证程序后，才能获得 HTTPS 需要的安全凭证。而用户的浏览器中，在出场时就会默认相信一些权威机构所核发的安全凭证，以此建构出信任鍊。

上述是简化的说明，详细可以参考以下文章：

- [也许，这样理解HTTPS更容易](http://showme.codes/2017-02-20/understand-https/)
- [HTTPS科普扫盲帖](https://segmentfault.com/a/1190000004523659)
- [HTTPS工作原理](https://cattail.me/tech/2015/11/30/how-https-works.html)

那么要如何在服务器上安装 HTTPS 呢? 步骤会比较复杂，我们会在进阶的部署教程再说以说明。

> [Heroku: Announcing Free and Automated SSL Certs For All Paid Dynos](https://blog.heroku.com/announcing-automated-certificate-management) Heroku 的付费用户可以免费得到SSL Certs

# 10-2 结语

希望本课程可以有效提供大家网站安全意识，「害人之心不可有，防人之心不可无」，再次提醒大家切勿以身试法。

对网络安全有兴趣的朋友，推荐阅读阿里巴巴的网络安全专家所写的入门书：[白帽子讲Web安全](https://book.douban.com/subject/10546925/)这本书。
