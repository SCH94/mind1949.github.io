---
layout: post
title: "Ajax交互式网页应用"
date: 2017-10-30
tags:
    Rails
    教材
---
#Ajax交互式页面应用

| 1. jQuery 101 预计学习时间: 2小时以内              |      |
| ---------------------------------------- | ---- |
| [**  1-1 什么是 jQuery 和 DOM](https://fullstack.xinshengdaxue.com/posts/938) |      |
| [**  1-2 新增练习网页](https://fullstack.xinshengdaxue.com/posts/939) |      |
| [**  1-3 如何动态增加内容到网页上](https://fullstack.xinshengdaxue.com/posts/940) |      |
| [**  1-4 如何除错?](https://fullstack.xinshengdaxue.com/posts/941) |      |
| [**  1-5 document.ready 事件解说](https://fullstack.xinshengdaxue.com/posts/942) |      |
| [**  1-6 如何隐藏和打开内容](https://fullstack.xinshengdaxue.com/posts/943) |      |
| [**  1-7 鼠标移过去自动打开和隐藏内容](https://fullstack.xinshengdaxue.com/posts/944) |      |
| [**  1-8 如何替换和移除内容](https://fullstack.xinshengdaxue.com/posts/945) |      |
| [**  1-9 如何改变 class 属性](https://fullstack.xinshengdaxue.com/posts/946) |      |
| [**  1-10 jQuery 小结](https://fullstack.xinshengdaxue.com/posts/947) |      |

| 2. Ajax on Rails 预计学习时间: 3小时以内           |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  2-1 Ajax 简介](https://fullstack.xinshengdaxue.com/posts/948) |                                          |
| [**  2-2 目标](https://fullstack.xinshengdaxue.com/posts/949) |                                          |
| [**  2-3 建立 Models](https://fullstack.xinshengdaxue.com/posts/950) |                                          |
| [**  2-4 浏览贴文和产生假资料](https://fullstack.xinshengdaxue.com/posts/951) |                                          |
| [**  2-5 新增和删除贴文](https://fullstack.xinshengdaxue.com/posts/952) |                                          |
| [**  2-6 Ajax 删除](https://fullstack.xinshengdaxue.com/posts/953) |                                          |
| [**  2-7 Ajax 新增](https://fullstack.xinshengdaxue.com/posts/954) |                                          |
| [**  2-8 Ajax 新增: 清空表单和错误处理](https://fullstack.xinshengdaxue.com/posts/955) |                                          |
| [**  2-9 制作按赞功能](https://fullstack.xinshengdaxue.com/posts/956) |                                          |
| [**  2-10 Ajax 按讚](https://fullstack.xinshengdaxue.com/posts/959) |                                          |
| [**  2-11 显示和更新多少人按讚](https://fullstack.xinshengdaxue.com/posts/957) |                                          |
| [**  2-12 Ajax 小结](https://fullstack.xinshengdaxue.com/posts/958) | 共3个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/958#task) |

| 3. Turbolinks 解说 预计学习时间: 1小时以内           |      |
| ---------------------------------------- | ---- |
| [**  3-1 Turbolinks 坑](https://fullstack.xinshengdaxue.com/posts/960) |      |
| [**  3-2 拆除 Turbolinks](https://fullstack.xinshengdaxue.com/posts/961) |      |

| 4. Ajax on Rails (进阶篇) 预计学习时间: 2小时以内     |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  4-1 前言](https://fullstack.xinshengdaxue.com/posts/992) |                                          |
| [**  4-2 把删除改成自行绑事件](https://fullstack.xinshengdaxue.com/posts/993) |                                          |
| [**  4-3 贴文无限捲轴](https://fullstack.xinshengdaxue.com/posts/994) |                                          |
| [**  4-4 使用核选方块(checkbox)做开关](https://fullstack.xinshengdaxue.com/posts/995) |                                          |
| [**  4-5 浏览器 Bubble Up 事件模型](https://fullstack.xinshengdaxue.com/posts/996) |                                          |
| [**  4-6 使用 jQuery Traversing 走访元素](https://fullstack.xinshengdaxue.com/posts/997) |                                          |
| [**  4-7 使用下拉选单(select)分类贴文](https://fullstack.xinshengdaxue.com/posts/998) |                                          |
| [**  4-8 Ajax 动画效果](https://fullstack.xinshengdaxue.com/posts/999) |                                          |
| [**  4-9 jQuery Plugin 整合示范](https://fullstack.xinshengdaxue.com/posts/1000) |                                          |
| [**  4-10 jQuery Plugin 整合示范(cont)](https://fullstack.xinshengdaxue.com/posts/1001) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1001#task) |

| 5. Unobtrusive JavaScript 解说 预计学习时间: 半小时以内 |      |
| ---------------------------------------- | ---- |
| [**  jquery-ujs](https://fullstack.xinshengdaxue.com/posts/1002) |      |

# 1-1 什么是 jQuery 和 DOM

[jQuery](https://jquery.com/)是一套最多人使用的 JavaScript 函式库，可以撰写各种网页效果，有丰富的社区和各种 Plugins 外挂。

它的主要作用是操纵网页的 DOM(Document Object Model)：浏览器会解析 HTML 然后显示在画面上，这个解析出来的结构就叫做 DOM，在浏览器内部这是一个树状的资料结构：

```
html
  - head
    - title
     - a web page
  - body class="home"
    - h1 id="header"
     - a headline
    - p
     - some
     - span
      - text
     - text
```

浏览器提供了 DOM API 让开发者可以操纵这些结构，透过 jQuery 我们可以很方便地从 HTML 取得要操纵的 HTML 元素，并在 DOM 里面进行插入、修改、删除元素，这样浏览器的画面就会跟着变化了。

# 1-2 新增练习网页

jQuery 在 Rails 5.0 以前的版本默认就有安装，你可以在 Gemfile 里面看到 `gem 'jquery-rails'` 以及在 `app/assets/javascripts/application.js` 里面看到 `//= require jquery`。

> 在 Gemfile 前几行可以看到你 Rails 的版本。如果你是 Rails 5.1，请在 Gemfile 补上 `gem 'jquery-rails'`，然后执行 `bundle`，接着在 `app/assets/javascripts/application.js` 里面拿掉 `//= require rails-ujs` 换成 `//= require jquery` 跟 `//= require jquery_ujs`

让我们新增一个专案，并新增一些页面来进行示范：

`rails new ajax-posting-app`

`cd ajax-posting-app`

`git init`

`rails g controller pages`

编辑 `config/routes.rb`

config/routes.rb

```
get "/jquery-1" => "pages#jquery_1"
get "/jquery-2" => "pages#jquery_2"
get "/jquery-3" => "pages#jquery_3"
get "/jquery-4" => "pages#jquery_4"
get "/jquery-5" => "pages#jquery_5"

root "pages#jquery_1"
```

编辑 `app/views/layouts/application.html.erb`

app/views/layouts/application.html.erb

```
   <body>
+    <%= link_to "jQuery 练习一", jquery_1_path %> |
+    <%= link_to "jQuery 练习二", jquery_2_path %> |
+    <%= link_to "jQuery 练习三", jquery_3_path %> |
+    <%= link_to "jQuery 练习四", jquery_4_path %> |
+    <%= link_to "jQuery 练习五", jquery_5_path %>
```

安装 [bootstrap-sass](https://github.com/twbs/bootstrap-sass) (步骤省略，之后的截图是有安装 Bootstrap，画面比较漂亮，没做不影响功能)

启动服务器 `rails server`

(请接着做下一节再打开浏览器)

# 1-3 如何动态增加内容到网页上

目标：点击一个 HTML 元素后，动态置换一段内容

新增 `app/views/pages/jquery_1.html.erb`

```
<p>
  <a id="my-click">Click Me</a>
</p>

<div id="foo" style="border: 1px solid red;">
  <p>bar</p>
</div>

<script>
  $("#my-click").click(function(){
    $("#foo").html('<h1>zoo</h1>');
  })
</script>
```

浏览 `http://localhost:3000/jquery-1`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/6MKTXNchSfSt6YMinFiK_1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/6MKTXNchSfSt6YMinFiK_1.png)

点击 Click Me 连结的话，你会发现 `<p>bar</p>` 就动态置换成 `<h1>zoo</h1>` 了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/X6DsK83eQqOrdYTjXuH9_2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/X6DsK83eQqOrdYTjXuH9_2.png)

解说：

- `<script>...</script>` 包起来的部分就是写 JavaScript 的地方
- 这个钱号 $ 等同于 jQuery
- `$("#my-click")` 是 jQuery 的选择器用法，会挑出 id 是 `my-click` 的元素，在这里就是指 Click Me 的超连结。在 HTML 上 id 是唯一的，不能有重复的 id。
- `.click( function(){...} )` 会绑订一个点击(click)事件在该元素上面，当用户点击这个元素时，就会执行里面的 function
- `$("#foo").html('<h1>zoo</h1>')` 会把 #foo 这个元素的内容置换成 `<h1>zoo</h1>`

请试试看把 `html` 换成以下用法，观察看看有什么差别：

- `text` 文字替换
- `prepend` 把内容插在指定元素里面的最前面
- `append` 把内容插在指定元素里面的最后面
- `before` 把内容插在指定元素的前面
- `after` 把内容插在指定元素的后面

请先搭配看下一节如何除错。

# 1-4 如何除错?

请使用 Chrome 开发者工具：在 HTML 画面上按右键，点 Inspect，就会看到以下画面：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9qkFqQi5QMKpl8xwKxpY_3-debug.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9qkFqQi5QMKpl8xwKxpY_3-debug.png)

如果 JavaScript 写错的话，在 Console 可以看到错误，例如我们把 `click` 拼错成 `clickk` 的话：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/qgWeEcpRdK8tHhTxh5KA_4-debug.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/qgWeEcpRdK8tHhTxh5KA_4-debug.png)

> 从错误的地方开始，以下的 JavaScript 程序都不会执行喔

想在 JavaScript 程序中观察变量的话，可以用 `alert` 或 `console.log` 语法，例如：

```
  $("#my-click").click(function(){
    alert("test");
  })
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/PNwSIeZqRE2uQYM2EgvY_5-debug.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/PNwSIeZqRE2uQYM2EgvY_5-debug.png)

不过跳 alert 有时候太恼人了，可以改用 `console.log` 就会出现在开发者工具的 Console 里面：

```
 console.log("checkpoint A");

  $("#my-click").click(function(){
    console.log("checkpoint C");
  })

  console.log("checkpoint B");
```

就会出现：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/J3Eu05hHSgSSTIiZfuR5_6-debug.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/J3Eu05hHSgSSTIiZfuR5_6-debug.png)

# 1-5 document.ready 事件解说

在用 `$("xxxx")` jQuery 选择器的时候，HTML 必须先加载完，jQuery 才能够找得到元素。因此我们刚刚是先写 HTML 在上，把 `script` 写在下面。如果倒过来的话：

```
<script>
  $("#my-click").click(function(){
    $("#foo").html('<h1>zoo</h1>');
  })
</script>

<p>
  <a id="my-click">Click Me</a>
</p>

<div id="foo" style="border: 1px solid red;">
  <p>bar</p>
</div>
```

你会发现没有效果，点了没反应，因为 `click`事件并没有顺利绑在超连结上。

但是传统上我们习惯将 JavaScript 放在 HTML 上方加载，例如写在 `app/assets/javascripts/application.js` 里面，因此这时候我们需要用 `$(document).ready` 把程序包起来，也就是改成：

```
  <script>
+ // 这是 javascript 注解
+ // 也可以缩写成 $(function() {
+ $(document).ready(function(){
    $("#my-click").click(function(){
      $("#foo").html('<h1>zoo</h1>');
    })
+ })
  </script>

  <p>
    <a id="my-click">Click Me</a>
  </p>

  <div id="foo" style="border: 1px solid red;">
    <p>bar</p>
  </div>
```

`$(document).ready` 是一个浏览器的事件，会在加载 HTML 完成之后，才执行里面的 function，就可以解决这个问题。

# 1-6 如何隐藏和打开内容

目标：点击一个元素后，动态隐藏和打开一段内容

新增 `app/views/pages/jquery_2.html.erb`

```
<p>
  <a id="my-open-click">Open</a>
</p>

<div id="foo" style="border: 1px solid red;">
  <a id="my-hide-click">Hide</a>
  <p>bar</p>
</div>


<script>
  $("#foo").hide();

  $("#my-open-click").click(function(){
    $("#foo").show();
  })

  $("#my-hide-click").click(function(){
    $("#foo").hide();
  })
</script>
```

浏览 `http://localhost:3000/jquery-2`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/A8kZpbE2RhuU8Abav4Ol_7-hide.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/A8kZpbE2RhuU8Abav4Ol_7-hide.png)

点击 Open

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Dj5ejPATbSZslH3EGwnV_8-show.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Dj5ejPATbSZslH3EGwnV_8-show.png)

再点击 Hide 就会隐藏起来了。

请试试看把 `hide` 和 `show` 分别改成

- `fadeOut` 和 `fadeIn`
- `slideUp` 和 `slideDown`

会有不同的动画效果。

# 1-7 鼠标移过去自动打开和隐藏内容

目标：鼠标移过去，就会自动打开和隐藏一段内容

新增 `app/views/pages/jquery_3.html.erb`

```
<p>
  <a id="my-toggle-click">Toggle</a>
</p>

<div id="foo" style="border: 1px solid red;">
  <p>bar</p>
</div>

<script>
  $("#foo").hide();   // 先马上藏起来

  $("#my-toggle-click").hover(function(){
    $("#foo").toggle();   // 移过去会有开关的效果
  })

</script>
```

浏览 `http://localhost:3000/jquery-3`

鼠标移过去就会打开内容，鼠标移走内容就会隐藏起来。

解说：

这里我们改用 `hover` 事件，这会在鼠标移过去和移出去的时候，都会触发。然后搭配 `toggle` 方法就可以一开一关了。

jQuery 支援了非常多的[浏览器事件](https://www.w3schools.com/jquery/jquery_events.asp)，从鼠标单点、双点、移过去、移出去，到键盘输入哪一个按键等等，在浏览器里面发生的事情都可以绑事件上去。

最后，请试试看把 `toggle` 改成

- `slideToggle`
- `fadeToggle`

会有不同的动画效果。

# 1-8 如何替换和移除内容

目标：点击一个元素后，动态替换和删除内容

新增 `app/views/pages/jquery_4.html.erb`

```
<p>
  <a id="my-replace-click">Replace</a>
  <a id="my-remove-click">Remove</a>
  <a id="my-remove-all-click">Remove All</a>
</p>

<div id="foo" style="border: 1px solid red;">
  <p>bar</p>
</div>

<div class="zoo"><p>a</p></div>
<div class="zoo"><p>b</p></div>
<div class="zoo"><p>c</p></div>

<script>
  $("#my-replace-click").click(function(){
    $("#foo").replaceWith('<div id="foo" style="border:1px solid green"><p>foo</p></div>');
  })

  $("#my-remove-click").click(function(){
    $("#foo").remove();
  })

  $("#my-remove-all-click").click(function(){
    $(".zoo").remove();
  })
</script>
```

浏览 `http://localhost:3000/jquery-4`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cDDCsqm5TKWHX7uAAvGY_9.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cDDCsqm5TKWHX7uAAvGY_9.png)

点击 Replace

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/2oVKMzN0R7uPSqLZTXAf_10-replace.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/2oVKMzN0R7uPSqLZTXAf_10-replace.png)

解说：`replaceWith` 会连同指定元素一起置换掉，因此整个 `#foo` 包含 `<div>` 都一起被换掉了。

点击 Remove 移除一个元素：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/zITaXYjRoKS2XHZbVwlr_11-remove.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/zITaXYjRoKS2XHZbVwlr_11-remove.png)

点击 Remove All 移除 a,b,c 三个元素：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/hFLME8DwR8O04ETxfyJg_12-remove-all.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/hFLME8DwR8O04ETxfyJg_12-remove-all.png)

解说：这里我们改用 `$(".zoo")` 选择器来挑选出所有 class 里面有 `zoo` 的元素。跟 id 不同，一份 HTML 上可以有多个重复的 class。

# 1-9 如何改变 class 属性

目标：点击一个元素后，动态替换元素的 class，这样就会套用不同的 CSS 来改变外观

新增 `app/views/pages/jquery_5.html.erb`

```
<style>
  .error {
    color: red;
  }
  .success {
    color: green;
  }
</style>

<p>
  <a id="my-add-class-click">Add Class</a>

  <a id="my-remove-class-click">Remove Class</a>
</p>

<div id="foo">
  <h1>bar</h1>
</div>

<script>
  $("#my-add-class-click").click(function(){
    $("#foo").removeClass('error');
    $("#foo").addClass('success');
  })

  $("#my-remove-class-click").click(function(){
    $("#foo").removeClass('success');
    $("#foo").addClass('error');
  })
</script>

```

浏览 `http://localhost:3000/jquery-5`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/KSyQmOkRmey4nBZmdQSR_13-class.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/KSyQmOkRmey4nBZmdQSR_13-class.png)

点击 Add Class

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/EiAAw6KTJuJF31ns3B2H_14.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/EiAAw6KTJuJF31ns3B2H_14.png)

点击 Remove Class

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/mLwXUn7HQh28w0aHqlLF_15.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/mLwXUn7HQh28w0aHqlLF_15.png)

jQuery 也有 API 可以[直接改 CSS](http://api.jquery.com/css/)。

# 1-10 jQuery 小结

这章示范的就是最常见的 jQuery 使用套路了，包括：

- 用选择器 Selector 选取出目标元素，我们学到最简单的可以用 id 或 class 来选，例如 `$("#某个ID")` 和 `$(".某个class")`。
- 绑定一个事件(Event)上去，例如 `click` 和 `hover` 事件
- 当事件被触发的时候，执行某个 DOM 操作来改变 HTML，可能是改变元素的属性、插入新内容、新增或移除 class 属性等等。目前学到的用法有：
  - `html`
  - `append`
  - `prepend`
  - `before`
  - `after`
  - `remove`
  - `replaceWith`
  - `toggle`
  - `addClass` 和 `removeClass`

其实大部分的 jQuery 代码的工作就是去新增内容、改变 HTML、调整 CSS 等方式操控网页，例如跳出选单、轮播广告、滑动标题图片等等，这些就是执行上述步骤。

# 2-1 Ajax 简介

回想之前的超连结或是表单送出，浏览器会整页替换：

例如点超连结时，浏览器会用 GET 送出，然后整个浏览器刷新到下一页：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cfoF9h32Qp6KLN3oXxsb_1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cfoF9h32Qp6KLN3oXxsb_1.png)

如果用表单送出的话，浏览器会先用 POST 送出，Rails 服务器处理完之后，通常我们会用 `redirect` 语法来回传 HTTP 状态码 301，当浏览器看到 301 后就会送 GET 去抓下一页。(为何这样设计?请参考「Web API 设计实作」教程的 [3-2 什么是 REST API](https://fullstack.xinshengdaxue.com/posts/838))

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/OUlDWbULTz5PwYLf5YO6_2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/OUlDWbULTz5PwYLf5YO6_2.png)

接下来要介绍的 Ajax(Asynchronous JavaScript and XML) 异步的JavaScript与XML技术，则可以不需要整页替换，只更新部分网页，这可以大大的改进 UI 反应速度。目前已经不流行用 XML 了，因此常见的回传会用 JSON 和 Script 格式：

用 JSON 格式，必须写自定义的 JavaScript 去处理 Ajax 的发送和接收处理。JavaScript 强者或团队中有前端工程师会偏好这种方式。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/IlmXqvNRTOKY0dR53iiA_3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/IlmXqvNRTOKY0dR53iiA_3.png)

另一种是用 Script 格式，服务器回传 JavaScript，浏览器拿到后直接执行即可。这种方式 Rails 有内建 [jquery-ujs](https://github.com/rails/jquery-ujs) gem，会帮我们绑好事件去处理 Ajax 发送和接收。这是比较简单的作法，对 jQuery 技能的要求也比较低。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9inQIiFTXKrjJ6vDFXT6_4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9inQIiFTXKrjJ6vDFXT6_4.png)

这一章我们会示范用 Script 的方式来做 Ajax。

# 2-2 目标

制作一个可以分享内容，用户可以按讚的的网站。User Story 包括：

- 用户可以贴文
- 用户可以浏览所有贴文
- 用户可以删除自己的贴文
- 用户可以针对贴文按讚，每篇贴文只能按讚一次

非功能性的要求是，利用 Ajax 技术改善 UI，让操作的反应变成神速。

# 2-3 建立 Models

首先来安装 Devise 产生 User Model

编辑 `Gemfile` 加上 `gem "devise"`

执行 `bundle`，然后重启服务器

执行 `rails g devise:install`

执行 `rails g devise user`

编辑 `app/views/layouts/application.html.erb`，插入：

app/views/layouts/application.html.erb

```
  <body>
+   <% if flash[:notice] %>
+     <%= flash[:notice] %>
+   <% end %>

+   <% if flash[:alert] %>
+     <%= flash[:alert] %>
+   <% end %>

+  <% if current_user %>
+     <%= link_to('登出', destroy_user_session_path, :method => :delete) %>
+    <%= link_to('修改密码', edit_registration_path(:user)) %>
+  <% else %>
+    <%= link_to('注册', new_registration_path(:user)) %> |
+    <%= link_to('登入', new_session_path(:user)) %>
+   <% end %>

...(略)
```

执行 `rails g model post content:text user_id:integer`

编辑 `app/models/user.rb`，加上 posts 关联，以及一个 `display_name` 方法来显示用户名称。

app/models/user.rb

```
 class User < ApplicationRecord

+   has_many :posts

+   def display_name
+     # # 取 email 的前半来显示，如果你也可以另开一个字段是 nickname 让用户可以自己编辑显示名称
+     self.email.split("@").first
+   end

...(略)
```

编辑 `app/models/post.rb`，加上 user 关联

app/models/post.rb

```
  class Post < ApplicationRecord
+   validates_presence_of :content
+   belongs_to :user

...(略)
```

执行 `rake db:migrate`

# 2-4 浏览贴文和产生假资料

编辑 `config/routes.rb`

config/routes.rb

```
+ resources :posts

- root "pages#jquery_1"
+ root "posts#index"
```

执行 `rails g controller posts`

编辑 `app/controllers/posts_controller.rb`

app/controllers/posts_controller.rb

```
+  def index
+    @posts = Post.order("id DESC").all    # 新贴文放前面
+  end
```

新增 `app/views/posts/index.html.erb`

```
<% @posts.each do |post| %>

<div class="panel panel-default">
  <div class="panel-heading"><%= post.user.display_name %></div>
  <div class="panel-body">
    <%= post.content %>
  </div>
</div>

<% end %>
```

没有资料就不好玩了，除了进 `rails console` 自己新增之外，我们也可以自己写一个小程序来产生一堆假资料。

[Faker](https://github.com/stympy/faker) 这个 gem 可以随机产生假文，编辑 Gemfile 加上：

```
 group :development do
+   gem 'faker'

  # (略)
```

执行 `bundle install`

写个 rake 程序来产生假资料，新增 `lib/tasks/dev.rake`，放在这个目录下的 rake 档案是用来编写任务脚本，让我们在 Terminal 中可以执行它：

lib/tasks/dev.rake

```
namespace :dev do

  task :fake => :environment do
    users = []
    10.times do
      users << User.create!( :email => Faker::Internet.email, :password => "12345678")
    end

    50.times do |i|
      post = Post.create!( :content => Faker::Lorem.paragraph,
                            :user_id => users.sample.id )

    end
  end

end
```

执行 `rake dev:fake` 就会执行这个任务，产生 10 笔假用户和 50 笔文章。

浏览 `http://localhost:3000` 可以看到贴文一览了：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/dlQZRTQCT3WrW16fq5ql_16-posts.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/dlQZRTQCT3WrW16fq5ql_16-posts.png)

> 请自行安装 Bootstrap 画面才会漂亮喔，不装也没关系不影响学习 Ajax

# 2-5 新增和删除贴文

在做 Ajax 效果之前，请先完成基本功能，接下来制作新增和删除。

编辑 `app/controllers/posts_controller.rb`

app/controllers/posts_controller.rb

```
  class PostsController < ApplicationController

+   before_action :authenticate_user!, :only => [:create, :destroy]

+   def create
+     @post = Post.new(post_params)
+     @post.user = current_user
+     @post.save
+
+     redirect_to posts_path
+   end
+
+   def destroy
+     @post = current_user.posts.find(params[:id]) # 只能删除自己的贴文
+     @post.destroy
+
+     redirect_to posts_path
+   end
+
+   protected
+
+   def post_params
+     params.require(:post).permit(:content)
+    end

  end
```

编辑 `app/views/posts/index.html.erb`

```
+ <%= form_for Post.new do |f| %>
+   <div class="form-group">
+     <%= f.text_area :content, :class => "form-control" %>
+   </div>
+   <div class="form-group">
+     <%= f.submit :class => "btn btn-primary" %>
+   </div>
+ <% end %>

  <% @posts.each do |post| %>

  <div class="panel panel-default">
    <div class="panel-heading"><%= post.user.display_name %></div>
    <div class="panel-body">
      <%= post.content %>

+     <% if current_user && post.user == current_user %>
+       <p class="text-right">
+         <%= link_to "Delete", post_path(post), :method => :delete, :class => "btn btn-danger" %>
+       </p>
+     <% end %>
    </div>
  </div>

  <% end %>
```

测试看看新增贴文和删除，要先注册登入才能贴文喔：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/0a4AgJKBRdiduR13OMku_17-new.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/0a4AgJKBRdiduR13OMku_17-new.png)

# 2-6 Ajax 删除

接下来是本课程的重点戏 Ajax。首先我们要让 Delete 删除的超连结变成 Ajax 送出。

编辑 `app/views/posts/index.html.erb`

```
-  <%= link_to "Delete", post_path(post), :method => :delete, :class => "btn btn-danger" %>
+  <%= link_to "Delete", post_path(post), :method => :delete, :remote => true, :class => "btn btn-danger" %>
```

透过 `:remote => true` 就会变成 Ajax 送出了，不需要自己写 `$("xxx").click` 去绑事件。

接着编辑 `app/controllers/posts_controller.rb`

app/controllers/posts_controller.rb

```
  def destroy
    @post = current_user.posts.find(params[:id])
    @post.destroy

-   redirect_to posts_path
+   render :js => "alert('ok');"
  end
```

这里改成返回一段 JavaScript 字串代码，内容是 `alert('ok');`，实际测试看看，点删除：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/QylsbXhJQqKgPNZsUqlo_18-ajax-delete.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/QylsbXhJQqKgPNZsUqlo_18-ajax-delete.png)

服务器回传了 `alert('ok');` 字串，浏览器拿到之后就去执行，于是跳出一个 alert 视窗。

> 这一招又叫做 Remote JavaScript (RJS)，把远端的 JavaScript 代码抓回来执行。

做到这里，那一笔贴文虽然在数据库中已经被删除了，但因为是 Ajax 没有整页重新整理，所以那一笔贴文看起来还在网页上面，如果你重新整理画面的话，那一笔才会不见。

我们希望的 UI 效果是立即移除画面上的那一笔贴文，这时候得用到上一章 jQuery 学到的 `$("xxxx").remove()` 用法：

因为要在 controller 里面放 JavaScript 字串是很痛苦的，接下来改成用 erb 样板的方式来写 JavaScript：

再次编辑 `app/controllers/posts_controller.rb`，把 `render :js` 砍掉：

app/controllers/posts_controller.rb

```
  def destroy
    @post = current_user.posts.find(params[:id])
    @post.destroy

-   render :js => "alert('ok');"
  end
```

编辑 `app/views/posts/index.html.erb`，针对每一笔贴文 div 补上一个 id 来做定位：

```
-  <div class="panel panel-default">
+  <div id="post-<%= post.id %>" class="panel panel-default">
```

新增 `app/views/posts/destroy.js.erb` 样板：

```
 $("#post-<%= @post.id %>").remove();
```

解说：

- 针对要被移除的 `<div>` 区块，我们补上了一个 id，例如 `<div id="post-123">`，这样等会 jQuery 要移除的时候，就可以直接抓到要移除哪一个元素了
- 一个 action 如果没有写明 `redirect` 或 `render` 的话，就会默认去找 action 名称的样板。于是这里就会去找 `destroy.js.erb`
- `destroy.js.erb` 里面要写回传的 JavaScript 代码，这个档案也是 erb 样板，所以可以用 `<%= XXX %>` 内嵌 Ruby 语法

再次测试看看删除，你会发现删除的操作变成超级神速。

#### Ajax 要如何除错?

由于前端没有换页，所以就算代码写错了，按钮按下去也不会有任何反应。这时候请看 `rails server` 的 log，或是打开 Chrome 开发者模式的 Network 进行观察：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Qhr7AlW0QcUQup9OBG46_19.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Qhr7AlW0QcUQup9OBG46_19.png)

这截图说明了服务器回传 `$("#post-76").remove();` JavaScript 字串，浏览器去执行这个字串就把 id post-76 这个 div 给移除了。

# 2-7 Ajax 新增

除了 `link_to`、`button_to` 可以加上 `:remote => true` 变成 Ajax 之外。`form_for` 也可以用这招。接下来做做看新增贴文：

编辑 `app/views/posts/index.html.erb`

app/views/posts/index.html.erb

```
-  <%= form_for Post.new do |f| %>
+  <%= form_for Post.new, :remote => true do |f| %>
```

编辑 `app/controllers/posts_controller.rb`，把 `redirect_to` 砍掉：

app/controllers/posts_controller.rb

```
  def create
    @post = Post.new(post_params)
    @post.user = current_user
    @post.save

-   redirect_to posts_path

  end
```

这时候如果你新增的话，按下送出网页看起来没有反应，其实数据库已经插入这一笔，重新整理就会出现。

我们希望的 UI 效果是在 HTML 上插入一整个新贴文的内容，也就是得在 `app/views/posts/create.js.erb` 用 `$("XXX").prepend("YYY")` 的语法来达成。问题是 XXX 跟 YYY 要填什么？

先来解决 XXX，我们预期新的贴文放在本来贴文的上方，所以要在 HTML 上定位出本来的贴文区块，请编辑 `app/views/posts/index.html.erb` 用一个 div 整个包起来

app/views/posts/index.html.erb

```
+  <div id="post-list">
  <% @posts.each do |post| %>
    # 略...
  <% end %>
+ </div>
```

接着是 YYY，这个要插入的 HTML 字串跟目前在 `index.html.erb` 样板上面的贴文 HTML 是一模一样的，这时候想到来用 partial 样板，再次编辑 `app/views/posts/index.html.erb`，把整块贴文的部分搬去 partial:

app/views/posts/index.html.erb

```
  <div id="post-list">
   <% @posts.each do |post| %>
-    <div id="post-<%= post.id %>" class="panel panel-default">
-      <div class="panel-heading"><%= post.user.display_name %></div>
-      <div class="panel-body">
-      <%= post.content %>
-
-        <% if current_user && post.user == current_user %>
-        <p class="text-right">
-          <%= link_to "Delete", post_path(post), :method => :delete, :class => "btn btn-danger", :remote => true %>
-        </p>
-        <% end %>
-      </div>
-   </div>

+   <%= render :partial => "post", :locals => { :post => post } %>
  <% end %>
</div>
```

新增 `app/views/posts/_post.html.erb` 这个 Partial 样板：

```
<div id="post-<%= post.id %>" class="panel panel-default">
  <div class="panel-heading">
    <%= post.user.display_name %>
  </div>
  <div class="panel-body">
    <%= post.content %>

    <% if current_user && post.user == current_user %>
      <p class="text-right">
        <%= link_to "Delete", post_path(post), :method => :delete, :class => "btn btn-danger", :remote => true %>
      </p>
    <% end %>
  </div>
</div>
```

重新整理 index 画面应该还是正常的。

接着可以写 `app/views/posts/create.js.erb` 了

```
$("#post-list").prepend("<%=j render :partial => "post", :locals => { :post => @post } %>");
```

就一行，这样就可以重复利用 partial 样板，把整个 partial 变成一个 JavaScript 字串，然后塞入 `<div id="#post-list">` 里。

其中 `j` 等同于 `escape_javascript`，这会做逸出好让 partial 字串可以变成合法的 JavaScript 字串：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/QcmYyZxnQg2RZJYbrcHL_20-create.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/QcmYyZxnQg2RZJYbrcHL_20-create.png)

如果你把 j 拿掉，会变成以下这样，浏览器是无法正确执行这段 JavaScript 代码的：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ZE9qr5mR1mMrWK7kU2ag_21.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ZE9qr5mR1mMrWK7kU2ag_21.png)

# 2-8 Ajax 新增: 清空表单和错误处理

接下来还有两个小地方可以改进，第一是送出后，输入框应该清空。

修改`app/views/posts/create.js.erb`，新增一行 `$("#post_content").val("");`

```
   $("#post-list").prepend("<%=j render :partial => "post", :locals => { :post => @post } %>");
+  $("#post_content").val("");
```

用 `.val("")` 就可以把输入框的值设定为空。

第二是储存失败的情况处理，假设贴文是空的，那么 @post 会储存失败，这时候应该有错误讯息提示。修改`app/views/posts/create.js.erb`

```
+ <% if @post.valid? %>
  $("#post-list").prepend("<%=j render :partial => "post", :locals => { :post => @post } %>");
  $("#post_content").val("");
+ <% else %>
+   alert("贴文失败");
+ <% end %>
```

增加一个 if else 的情况区分，当 `valid?` 成功时，插入新贴文，当储存失败时，跳一个 alert 视窗。

# 2-9 制作按赞功能

接下来制作用户可以针对贴文按讚，先来做一个基本版没有 Ajax 效果的版本：

一个用户可以针对很多贴文按讚，一篇贴文可以有很多用户按讚，这是一个多对多的模型，让我们新增一个 Like model：

执行 `rails g model like`

编辑 `db/migrate/201703XXXXXXXX_create_likes.rb`

db/migrate/201703XXXXXXXX_create_likes.rb

```
  class CreateLikes < ActiveRecord::Migration[5.0]
    def change
      create_table :likes do |t|
+       t.integer :user_id, :index => true
+       t.integer :post_id, :index => true
        t.timestamps
      end
    end
  end
```

在终端执行 `rake db:migrate`

编辑 `app/models/like.rb`，加上关联

app/models/like.rb

```
+  belongs_to :user
+  belongs_to :post
```

编辑 `app/models/post.rb`，加上关联和一个 `find_like` 方法：由于一个用户只能针对一篇贴文按一个讚，所以透过用户ID和贴文ID，就可以找到唯一的 Like，等会我们会用这个方法来判断一个用户不能重复按讚。

app/models/post.rb

```
   belongs_to :user

+  has_many :likes, :dependent => :destroy
+  has_many :liked_users, :through => :likes, :source => :user

+  def find_like(user)
+    self.likes.where( :user_id => user.id ).first
+  end
```

编辑 `app/models/user.rb`，加上关联

app/models/user.rb

```
   has_many :posts

+  has_many :likes, :dependent => :destroy
+  has_many :liked_posts, :through => :likes, :source => :post
```

> 因为已经有了 `has_many :posts`，所以这里要取不同名称 `:liked_posts`，也因为取了不同名称，需要额外指定 source。详细在 [2017/2/16 的直拨](https://fullstack.xinshengdaxue.com/posts/431) 有解说

编辑 `config/routes.rb`

config/routes.rb

```
-  resources :posts
+  resources :posts do
+    member do
+      post "like" => "posts#like"
+      post "unlike" => "posts#unlike"
+    end
+  end
```

编辑 `app/views/posts/_post.html.erb` 加上按讚的按钮：

app/views/posts/_post.html.erb

```
  <div class="panel-body">
     <%= post.content %>

+    <div class="text-right">
+
+      <% if post.liked_users.any? %>
+        <%= post.liked_users.map{ |u| u.display_name }.join(",") %> 点了赞
+      <% end %>
+
+      <% if current_user # 有登入才可以按讚 %>
+        <% if post.find_like(current_user) %>
+          <%= link_to "-1", unlike_post_path(post), :method => :post, :class => "btn btn-primary" %>
+        <% else %>
+          <%= link_to "+1", like_post_path(post), :method => :post, :class => "btn btn-primary" %>
+        <% end %>
+      <% end %>

      # (略，删除按钮在这里)

+    </div>
  </div>
```

最后是 controller，请编辑 `app/controllers/posts_controller.rb`，加上 like 和 unlike 方法：

app/controllers/posts_controller.rb

```
+  def like
+    @post = Post.find(params[:id])
+    unless @post.find_like(current_user)  # 如果已经按讚过了，就略过不再新增
+      Like.create( :user => current_user, :post => @post)
+    end
+
+    redirect_to posts_path
+  end
+
+  def unlike
+    @post = Post.find(params[:id])
+    like = @post.find_like(current_user)
+    like.destroy
+
+    redirect_to posts_path
+  end
+
```

实际测试看看按讚 +1 和取消按讚 -1

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/4khabC9NTb5cK0xvJQpR_21-like.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/4khabC9NTb5cK0xvJQpR_21-like.png)

# 2-10 Ajax 按讚

接着改进为神速 Ajax 按讚，流程是：

1. 把本来的 +1 和 -1 按钮，改成 `:remote => true` 用 Ajax 送出
2. 服务器会新建或删除 Like 资料进数据库
3. 服务器回传的 JavaScript 要替换掉整块按讚的 HTML 部分，包括 XXX 按了讚，以及把 +1 改成 -1 按钮或 -1 改成 +1 按钮。

这里又需要用到 Partial 样板了，这样才能在一开始显示 HTML 时，以及在 Ajax 中去重复使用同一份 erb 代码。

编辑 `app/views/posts/_post.html.erb` 把本来整块的按讚 HTML 搬到 Partial 去，并用一个 span 包起来，方便等会定位：

app/views/posts/_post.html.erb

```
-   <% if post.liked_users.any? %>
-     <%= post.liked_users.map{ |u| u.display_name }.join(",") %> 点了赞
-   <% end %>
-
-   <% if current_user # 有登入才可以按讚 %>
-     <% if post.find_like(current_user) %>
-       <%= link_to "-1", unlike_post_path(post), :method => :post, :class => "btn btn-primary" %>
-     <% else %>
-       <%= link_to "+1", like_post_path(post), :method => :post, :class => "btn btn-primary" %>
-     <% end %>
-   <% end %>

+    <span id="post-like-<%= post.id %>">
+      <%= render :partial => "like", :locals => { :post => post } %>
+    </span>
```

新增 `app/views/posts/_like.html.erb`，并在本来的 like 和 unlike 按钮上加上 `:remote => true` 变成 Ajax：

```
<% if post.liked_users.any? %>
  <%= post.liked_users.map{ |u| u.display_name }.join(",") %> 点了赞
<% end %>

<% if current_user # 有登入才可以按讚 %>
  <% if post.find_like(current_user) %>
    <%= link_to "取消讚", unlike_post_path(post), :method => :post, :remote => true, :class => "btn btn-primary" %>
  <% else %>
    <%= link_to "讚", like_post_path(post), :method => :post, :remote => true, :class => "btn btn-primary" %>
  <% end %>
<% end %>
```

编辑 `app/controllers/posts_controller.rb`，把 like 和 unlike 里面的 `redirect_to` 拿掉：

app/controllers/posts_controller.rb

```
  def like
    # (略)
-   redirect_to posts_path
  end

  def unlike
    # (略)
-   redirect_to posts_path
+   render "like"
  end
```

不管 like 或 unlike，反正我们都会把整块 `<span id="post-like-XXX">` 替换掉。因此 unlike 里面我们用 `render "like"` 重复使用同一个 `like.js.erb` 样板。

新增 `app/views/posts/like.js.erb`

```
str = "<%=j render :partial => "like", :locals => { :post => @post } %>";
$("#post-like-<%= @post.id %>").html(str);
```

测试看看，现在可以神速按讚了。

# 2-11 显示和更新多少人按讚

接下来我们想额外在画面上显示总共有多少人按讚，像这样：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Q7XdZvNSTFue1STvg67N_22.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Q7XdZvNSTFue1STvg67N_22.png)

编辑 `app/views/posts/_post.html.erb`

```
   <div class="panel-body">
+    <span id="post-thumbsup-<%= post.id %>" class="label label-success"><%= post.likes.count %> 👍</span>
```

修改 `app/views/posts/like.js.erb` 除了替换按讚的区块，也需要同时更新上述的 👍 数量：

```
   str = "<%=j render :partial => "like", :locals => { :post => @post } %>";
   $("#post-like-<%= @post.id %>").html(str);

+  $("#post-thumbsup-<%= @post.id %>").html("<%= @post.likes.count %>" + " 👍");
```

这样就可以同时更新 HTML 上的两个地方。

# 2-12 Ajax 小结

Ajax 是一种增强 UI 的方式，我们会先把基本功能完成，再根据需要改成 Ajax 效果。

这一章练习了删除、按讚、新增贴文，画面上比较单纯的按钮型操作，最适合用 Ajax 效果，例如删除、按讚、收藏、加入购物车等等。
如果是比较复杂的填表单操作，要做 Ajax 效果就会比较费工，因为需要考虑错误处理(储存失败)的情况。

Rails 内建透过 `:remote => true` 的方式，就可以很快制作出 Ajax 效果。
再稍后的章节中，我们会示范进阶的用法：在一些情况下，我们必须手写 jQuery 去绑事件送 Ajax，取得 JSON 回传并更新 DOM。

### 本节作业

##### [Ajax 作业](https://fullstack.xinshengdaxue.com/assignments/43)：[作业一](https://fullstack.xinshengdaxue.com/tasks/285)

已有 51 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/285/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/285)

请将完成的贴文新增、删除和按讚画面，用 gif 截图上来。

##### [Ajax 作业](https://fullstack.xinshengdaxue.com/assignments/43)：[作业二: 加入购物车](https://fullstack.xinshengdaxue.com/tasks/286)

已有 31 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/286/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/286)

请回头将 jdstore 商店的加入购物车功能，改造成 Ajax 效果

##### [Ajax 作业](https://fullstack.xinshengdaxue.com/assignments/43)：[作业三: 加入收藏](https://fullstack.xinshengdaxue.com/tasks/287)

已有 39 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/287/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/287)

用户可以点 ❤ 收藏贴文，并且用 Ajax 效果改进 UI。

# 3-1 Turbolinks 坑

[Turbolinks](https://github.com/turbolinks/turbolinks) 是一个 Rails 内建的页面加速工具，在 `Gemfile` 和 `application.js` 可以发现它的踪迹。这是一个 Javascript 套件会在换页的时候，不重新载入 HTML 的 `head`，只载入新的 `body`，来加速换页。

虽然有加速的效果，但是却很干扰其他 `javascript` 源码的载入：

#### 第一个坑

网上所有 jQuery 的教学文章，都是用`$(document).ready(function(){...})` 或`$(function(){...})`，在 HTML 载入完毕后执行 js 源码。但是用了 Turbolink 只会触发第一次而已，换页时不会再执行。

在 1-4 中我们示范了 `$(document).ready` 用法，如果你点超连结去别的页面，然后再点回来，会发现那段 JavaScript 就不会执行了。

解法：有用到 `$(document).ready(function(){...})` 的地方都要改成用 `$(document).on("turbolinks:load", function(){...})`

#### 第二个坑

单页(page-specific)才用到的 javascript 代码，如果写在 `body` 里面，跳页回来时，会触发两次。某些 js code 重复执行两次没关系，但有些会有问题。

解法一：关掉 Turbolinks 的缓存功能，把 `<meta name="turbolinks-cache-control" content="no-cache">` 放到 layout 的 `head` 里面。

解法二：把layout 的`<body>` 改成`<body id="<%= "#{controller_name}-#{action_name}"%>">`，这样就可以在全局载入的`application.js` 中指定只有这一页才执行的js code，例如：

```
  $(document).on("turbolinks:load", function() {
    if ( $("#products-show").length > 0 ) {
      console.log("product-show");
    }
  })
```

如果同学们还没有写到 jQuery 效果或用到 jQuery Plugins 的话，可能还没感觉。

如果你不想处理或无法理解这两个坑的原因，我建议你拆除 Turbolinks 来回避这些坑。

# 3-2 拆除 Turbolinks

如果你的 JavaScript 有以下症状：

症状一: 重新整理 JavaScript 就正常，点别页再点回来，就不正常(没加载执行或重复执行两遍)

症状二: 照「Refactor & 效能提升」教程，把[将 CSS 放在最顶层，将 JavaScript 放在最底层](https://fullstack.xinshengdaxue.com/posts/731)的话，这会跟 Turbolinks 的设计冲突。造成如[这篇讨论](https://forum.qzy.camp/t/turbolink-js/1016)的问题：重新整理后，JavaScript 会不正常。

请进行拆除 Turbolinks 的步骤：

修改 `Gemfile`，拿掉 turbolinks：

Gemfile

```
-  # Turbolinks makes navigating your web application faster. Read more: https://github.com/turbolinks/turbolinks
-  gem 'turbolinks', '~> 5'
```

修改 `app/assets/javascripts/application.js`，拿掉 turbolinks 的加载：

app/assets/javascripts/application.js

```
-  //= require turbolinks
```

修改 `app/views/layout/application.html.erb`，拿掉 turbolinks 属性：

app/views/layout/application.html.erb

```
-  <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
+  <%= javascript_include_tag 'application' %>
```

执行 `bundle`，重启服务器。

# 4-1 前言

这一章将示范直接用 jQuery 的 Ajax 功能，而不使用 Rails 的 `:remote => true` 方法来做 Ajax 效果。

这是因为 Rails 的 `:remote => true` 功能只能放在超连结或表单上，因此不属于这两种情形的需求，就需要自行绑事件上去，触发时送 Ajax Request 到服务器。

这一章将示范：

- 将删除改成自行绑事件
- 贴文无限捲轴
- 使用核选方块(checkbox)做开关
- 使用下拉选单(select)分类贴文

另外，搭配 jQuery Plugin 的话，也必须自己写 Ajax 代码。这章最后也会示范使用 jQuery Raty - A Star Rating Plugin 来做评等。

# 4-2 把删除改成自行绑事件

上一章我们用 Rails 内建的 `:remote => true` 来帮我们送 Ajax，这背后的原理其实就是自己去绑定事件，然后送 Ajax。

接下来我们来改写看看如何自行绑事件送 Ajax，首先修改 `_post.html.erb`，删掉本来的 :method 和 :remote 行为，补上一个 delete-post class 让我们等会绑事件上去：

app/views/posts/_post.html.erb

```
- <%= link_to "Delete", post_path(post), :method => :delete, :class => "btn btn-danger", :remote => true %>
+ <%= link_to "Delete", post_path(post), :class => "delete-post btn btn-danger" %>
```

然后在 `app/views/posts/index.html.erb` 下方加入：

app/views/posts/index.html.erb

```
+  <script>
+   // 这会绑 click 事件到所有有 `.delete-post` class 的元素上，也就是所有的删除按钮
+   $(".delete-post").click(function(evt){
+     // `evt` 是浏览器的事件物件，evt.preventDefault(); 会终止这个元素的默认行为：
+     // 超连结 a 的默认行为是跳到下一页，如果没有这行的话，送出 ajax 后会跳去 show page
+     evt.preventDefault();
+     // this 是个特别的变量，代表触发事件的元素。使用 attr 可以读取元素的属性，这里要拿到超连结的网址
+     var url = $(this).attr("href");
+
+     // 送出 Ajax
+     $.ajax({
+       url: url,
+       method: 'DELETE',
+       dataType: 'script' // 要求服务器回传 javascript
+     })
+   })
+  </script>
```

一但需要自己在前端绑事件，就会觉得把 JavaScript 代码集中在前端的话，责任区分会比较清楚。因此我们来改成用 JSON 格式吧，把 `dataType` 改成 JSON，然后加一个 success 的回呼，服务器回传资料后，就会触发 success 的函式：

app/views/posts/index.html.erb

```
  <script>
    $(".delete-post").click(function(evt){
      evt.preventDefault();
      var url = $(this).attr("href");

      // 送出 Ajax
      $.ajax({
        url: url,
        method: 'DELETE',
-       dataType: 'script'
+       dataType: 'json', // 要求服务器回传 json
+       success: function(data){   // data 就是服务器回传的 JSON 资料
+         $("#post-" + data["id"]).remove();
+       }
      })
    })
  </script>
```

修改 `app/controllers/posts_controller.rb` 改成直接回传 JSON

app/controllers/posts_controller.rb

```
   def destroy
     @post = current_user.posts.find(params[:id])
     @post.destroy

+    render :json => { :id => @post.id }
   end
```

接着删除 `app/views/posts/destroy.js.erb` 样板，我们不需要 Remote JavaScript 了。

如果团队中有专门的前端工程师，也会偏好这种方式。这样前后端的工作可以拆分的比较清楚。
后端处理数据库和回传 JSON 资料即可，页面怎么变化全由前端工程师负责。

# 4-3 贴文无限捲轴

目标：实作贴文的无限捲轴 (Endless Page)，当用户捲到画面最下方时，自动加载更早的资料。

这个任务需要侦测浏览器捲轴的行为，没办法用 `:remote => true` 了，需要自己去绑定事件，侦测用户捲到视窗最下面。

编辑`app/views/posts/index.html.erb`

app/views/posts/index.html.erb

```
  <script>
+  // 记下目前画面最小的贴文 ID
+  var current_post_id = <%= @posts.last.id %>;
+
+  // 当捲轴动的时候，会触发这个事件
+  $(window).scroll(function(){
+    // 当捲到最下面的时候
+    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
+      var url = "/posts?max_id=" + current_post_id;
+      if (url) {
+        $.ajax({
+          method: "GET",
+          url: url,
+          dataType: "script"
+        })
+      } else {
+        console.log("data ended")
+      }
+    }
+  })
  </script>
```

修改 `app/controllers/posts_controller.rb`，跟之前做分页一样，我们继续沿用了 index action，只是会根据 `params[:max_id]` 回传更早的资料：

app/controllers/posts_controller.rb

```
   def index
-    @posts = Post.order("id DESC").all
+    @posts = Post.order("id DESC").limit(20)
+
+    if params[:max_id]
+      @posts = @posts.where( "id < ?", params[:max_id])
+    end
+
+    respond_to do |format|
+      format.html  # 如果客户端要求 HTML，则回传 index.html.erb
+      format.js    # 如果客户端要求 JavaScript，回传 index.js.erb
+    end
   end
```

`respond_to` 可以让 Rails 根据 request 请求的格式(在 $ajax 中我们有指定了 dataType)，来回传不同格式。

新增 `app/views/posts/index.js.erb`

```
<% @posts.each do |post| %>
  $("#post-list").append("<hr>")
  $("#post-list").append("<%=j render :partial => "post", :locals => { :post => post } %>");
<% end %>

<% if @posts.any? %>
var current_post_id = <%= @posts.last.id %>;
<% end %>
```

这样画面捲到最下方时，就会自动加载，并且更新 `current_post_id` 的值，这样下次再抓就会抓到更早的资料。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DUUZhNl4QhGQ2m9qFxFN_endless-page.gif)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DUUZhNl4QhGQ2m9qFxFN_endless-page.gif)

# 4-4 使用核选方块(checkbox)做开关

目标：做一个勾选的核选方块，管理员可以打勾标记成垃圾。

执行 `rails g migration add_flag_to_posts`

编辑 `db/migrate/201704XXXXXXXX_add_flag_to_posts.rb`

201704XXXXXXXX_add_flag_to_posts.rb

```
 class AddFlagToPosts < ActiveRecord::Migration[5.0]
   def change
+    add_column :users, :role, :string
+    add_column :posts, :flag_at, :datetime
   end
 end
```

执行 `rake db:migrate`

编辑 `app/models/user.rb`

app/models/user.rb

```
+  def is_admin?
+    role == "admin"
+  end
```

执行 `rails console` 新增一个管理员帐号

```
 User.create!( :email => "admin@example.org", :password => "123456", :role => "admin" )
```

然后改用这个帐号登入。

编辑 `config/routes.rb` 新增一个 `toggle_flag` 路由：

config/routes.rb

```
   resources :posts do
     member do
       post "like" => "posts#like"
       post "unlike" => "posts#unlike"
+      post "toggle_flag" => "posts#toggle_flag"
     end
   end
```

编辑 `app/views/posts/_post.html.erb` 加上 checkbox 核选方块，以及显示标记时间：

app/views/posts/_post.html.erb

```
  <div class="panel-body">
    # (略)
  </div>

+  <div class="panel-footer">
+    <% if current_user && current_user.is_admin? %>
+      <label>
+      <%= check_box_tag "mark_flag[#{post.id}]", 1, post.flag_at.present?,
+            :data => { :url => toggle_flag_post_path(post) }, :class => "toggle-flag" %> 标记为垃圾
+        <span id="post-flag-<%= post.id %>"><%= post.flag_at %></span>
+      </label>
+    <% end %>
+  </div>
```

编辑 `app/views/posts/index.html.erb` 绑上 click 事件送出 Ajax 请求：

app/views/posts/index.html.erb

```
   <script>
+  $(".toggle-flag").on('change', function(){
+    var url = $(this).data("url");
+
+    $.ajax({
+      url: url,
+      method: "POST",
+      dataType: "json",
+      success: function(data){
+        if ( data["flag_at"] ) {
+          $("#post-flag-" + data["id"]).html(data["flag_at"]);
+        } else {
+          $("#post-flag-" + data["id"]).html("");
+        }
+      }
+    });
+  });
   </script>
```

解说:

- `$("XXXX").on` 是绑事件的语法，之前学过的 `$("XXX").click(function(){...}` 可以改写成 `$("XXX").on("click", function(){...})` 是一样的。这里用的事件名称是 `change`，表示输入框有变动的话，就会触发。
- 在 HTML 元素属性上的 `data-XXX`，在 jQuery 中可以用 `.data("XXX")` 去读取到它的值

最后编辑 `app/controllers/posts_controller.rb` 新增一个 toggle_flag action 接收处理：

app/controllers/posts_controller.rb

```
+  def toggle_flag
+    @post = Post.find(params[:id])
+
+    if @post.flag_at
+      @post.flag_at = nil
+    else
+      @post.flag_at = Time.now
+    end
+
+    @post.save!
+
+    render :json => { :message => "ok", :flag_at => @post.flag_at, :id => @post.id }
+  end
```

最后成果：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/m2mG2tXHQgqSgNClVM0X_ajax-checkbox.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/m2mG2tXHQgqSgNClVM0X_ajax-checkbox.png)



# 4-5 浏览器 Bubble Up 事件模型

前述的删除和打勾的例子，有个大 Bug，就是刚新增的贴文没作用。你可以试试看先新增一笔贴文，然后点点看删除和打勾，会发现竟然没作用。

这是怎么回事呢? 这是因为浏览器并不会为新增的元素自动绑事件上去。所以后来 Ajax 新增上去的贴文是没有事件的。

那要怎么解决呢? 我们需要了解一下浏览器的事件机制，假设有以下 HTML:

```
<body>
  <div>
     <p>
        <a>XXX</a>
     </p>
  </div>
</body>
```

当我们 click 点击 XXX 时，浏览器不只会触发 a 元素的 click 事件，也会往外层一路触发，包括 p 的 click 事件、div 的 click 事件、body 的 click 事件。这叫做 Bubble Up 事件模型。

了解这个模型之后，我们就可以将事件绑在可靠的上一层元素上，这里也就是 #post-list 的 div 上，反正点击里面的元素，最终都会 Bubble Up 上来触发。

请修改 `app/views/posts/index.html.erb`

app/views/posts/index.html.erb

```
-  $(".delete-post").click(function(evt){
+  $("#post-list").on('click', ".delete-post", function(evt){

   // 略

-  $(".toggle-flag").on('change', function(){
+  $("#post-list").on('change', ".toggle-flag", function(){`
```

一样是用 `on` 语法，但是改成绑在 `#post-list` 上，以及重点是多了第二个参数可以过滤出真正触发的元素，在这里也就是 `.delete-post` 和 `.toggle-flag`。

# 4-6 使用 jQuery Traversing 走访元素

上述的范例中，有用到 `this` 可以知道是哪一个元素被点击了，所以我们才可以用 `$(this).data("url")`去读取到该元素的 data 属性。

既然已经知道是哪一个元素被点击了，那其实可以利用 jQuery 的 [Traversing](https://api.jquery.com/category/traversing/) API，就可以进行定位：

例如我们可以这样修改删除：

app/views/posts/index.html.erb

```
  $("#post-list").on('click', ".delete-post",function(evt){
    evt.preventDefault();
    var url = $(this).attr("href");
+   var that = this;

    $.ajax({
      url: url,
      method: 'DELETE',
      dataType: 'json',
      success: function(data){
-       $("#post-" + data["id"]).remove();
+       $(that).closest(".panel").remove();
      }
    })
    //return false;
  })
```

解说：

- 由于 success 是个异步的回呼，里面的 `this` 不等同于外层的 `this`。所以我们得先在外层记下 `that` 是触发事件的元素。
- `closest` 会找最近的上一层元素，这里就会找到包住整个贴文的 class 是 panel 的 div 区块。

继续修改 checkbox 开关：

app/views/posts/index.html.erb

```
  $("#post-list").on('change', ".toggle_flag",function(){
    var url = $(this).data("url");
+   var that = this;

    $.ajax({
      url: url,
      method: "POST",
      dataType: "json",
      success: function(data){
        if ( data["flag_at"] ) {
-         $("#post-flag-" + data["id"]).html(data["flag_at"]);
+         $(that).closest("label").find("span").html(data["flag_at"]);
        } else {
-         $("#post-flag-" + data["id"]).html("");
+         $(that).closest("label").find("span").html("");
        }
      }
    });
  });
```

解说：

`find` 会找下层的元素。一个常见的技巧是，先往上层找到共同的祖先是`label`，然后往里层找目标`span`。

这样做的好处是什么呢? 这样写我们就不需要额外塞 post id 到 div 上来定位了。透过点击的元素，我们就可以走访到要操作的 DOM 上。

# 4-7 使用下拉选单(select)分类贴文

目标：做一个下拉选单可以分类，选了就立即生效，不需要再点送出

让我们产生一个分类 Category model，让 Post 贴文属于一种分类：

执行 `rails g model category`

编辑 `db/migrate/201704XXXXXXXX_create_categories.rb`

db/migrate/201704XXXXXXXX_create_categories.rb

```
 class CreateCategories < ActiveRecord::Migration[5.0]
    def change
      create_table :categories do |t|
+       t.string :name
        t.timestamps
      end

+     add_column :posts, :category_id, :integer
+     add_index :posts, :category_id
    end
  end
```

执行 `rake db:migrate`

编辑 `app/models/post.rb`

app/models/post.rb

```
  class Post < ApplicationRecord
+   belongs_to :category, :optional => true

    # (略)
  end
```

编辑 `app/models/category.rb`

app/models/category.rb

```
  class Category < ApplicationRecord

+   has_many :posts

  end
```

执行 `rails c` 新增一些分类资料：

```
 Category.create!( :name => "Ruby" )
 Category.create!( :name => "JavaScript" )
 Category.create!( :name => "PHP" )
 Category.create!( :name => "Java" )
 Category.create!( :name => "Python" )
```

编辑 `app/views/posts/_post.html.erb` 加上下拉选单：

app/views/posts/_post.html.erb

```
  <div class="panel-footer">
    <% if current_user && current_user.is_admin? %>
+      <%= select_tag "category_id[#{post.id}]", options_for_select(Category.all.map{ |x| [x.name, x.id]}, post.category_id),
+                     :data => { :url => post_path(post) }, :prompt => "请选择分类", :class => "select_category" %>
```

编辑 `app/views/posts/index.html.erb` 绑上事件：

app/views/posts/index.html.erb

```
  <script>
+   $("#post-list").on('change', ".select_category", function(){
+     var url = $(this).data("url");
+
+     $.ajax({
+       url: url,
+       method: "PATCH",
+       dataType: "json",
+       data: {
+         post: {
+           category_id: $(this).val()
+         }
+       }
+     });
+   });
  </script>
```

其中 `$ajax` 里面的 `data` 就是要送出去的参数，透过 `$(this).val()` 可以抓到选单的值。

编辑 `app/controllers/posts_controller.rb` 加上 `update` action：

app/controllers/posts_controller.rb

```
+  def update
+    @post = Post.find(params[:id])
+    @post.update!( post_params )
+
+    render :json => { :id => @post.id, :message => "ok"}
+  end

   #(略)

   def post_params
-    params.require(:post).permit(:content)
+    params.require(:post).permit(:content, :category_id)
   end
```

最后成果：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DxAxOgKVQgibPeGaUjsH_ajax-select0.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DxAxOgKVQgibPeGaUjsH_ajax-select0.png)

# 4-8 Ajax 动画效果

上一节的下拉选单送出 Ajax 后，虽然数据库已经更新了，但是并没有任何视觉回馈，用户可能会感到疑惑到底成功了没有。所以通常我们还会制作一些动画效果，好告诉用户操作确实完成了。

让我们找一张动画图片，在 [http://loading.io](http://loading.io/) 可以产生和下载git 图片，或用这张动图[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cuin0cnOSEeorE6v3jlp_ajax-loader.gif)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cuin0cnOSEeorE6v3jlp_ajax-loader.gif)

（请按右键另存新档)，请将动图请放在`public/images/` 目录下，并命名为 `ajax-loader.gif`。

修改 `app/views/posts/index.html.erb`

app/views/posts/index.html.erb

```
  <script>
  $("#post-list").on('change', ".select_category",function(){
    var url = $(this).data("url");
+   var that = this;

    $.ajax({
        url: url,
        method: "PATCH",
        dataType: "json",
        data: {
          post: {
            category_id: $(this).val()
          }
-       }
+       },
+       beforeSend: function(){
+         $(that).after( $(' <img src="/images/ajax-loader.gif" id="ajax-loading"> ') );
+       },
+       complete: function(){
+         $("#ajax-loading").remove();
+       }
      });
    });
  </script>
```

其中 `beforeSend` 会在 Ajax 送出前触发，而`complete` 会在完成后触发。分别是插入这张动画 gif 图片，以及在 Ajax 完成后移除图片。

因为是本地开发，感觉可能会一闪而过，我们可以暂时故意地在 action 做延迟：

app/controllers/posts_controller.rb

```
  def update
+   sleep(1)
    # (略 )
  end
```

但这只是看看效果，试完请移除掉。

最后成果：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/0tbJNgwpTFSNHaWpskQH_ajax-select.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/0tbJNgwpTFSNHaWpskQH_ajax-select.png)

# 4-9 jQuery Plugin 整合示范

目标: 使用 [jQuery Raty](http://www.sahmeran.nl/nieuw/modules/rating_raty/) 这个 jQuery Plugin，进行贴文的星星评等，并计算平均分数。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/uGSkOAIFR3C0UZz0PXeY_star-rating.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/uGSkOAIFR3C0UZz0PXeY_star-rating.png)

前往 <https://github.com/wbotelhos/raty> 点选 "Clone or download" 按钮，然后点 Download ZIP 下载回来。

解压缩后：

- 将 lib/jquery.raty.css 放到 vendor/assets/stylesheets/ 目录下
- 将 lib/jquery.raty.js 放到 vendor/assets/javascripts/ 目录下
- 将 images 下的图片，放在 public/images 目录下

修改 `app/assets/javascript/application.js`，

app/assets/javascript/application.js

```
+    //= require jquery.raty
     //= require_tree .
```

修改 `app/assets/stylesheets/application.scss`

```
  @import "bootstrap-sprockets";
  @import "bootstrap";
+ @import "jquery.raty";
```

> 如果你没装 Bootstrap 的话，这里是 application.css 写 `//=require jquery.raty`

修改 `app/views/posts/_post.html.erb`

```
   <div class="panel-body">
     <span id="post-thumbsup-<%= post.id %>" class="label label-success"><%= post.likes.count %> 👍</span>

+    <div class="raty"></div>
```

修改 `app/views/posts/index.html.erb`

```
  <script>
+   $(".raty").raty( { path: '/images/' } );
  </script>
```

浏览画面，应该就会看看星星了，也可以点点看。但是目前还没串好数据库。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/HyCmuNYERxy3hmfIU5V1_rating1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/HyCmuNYERxy3hmfIU5V1_rating1.png)

接下来希望点了星星评等，会实际纪录进数据库。

# 4-10 jQuery Plugin 整合示范(cont)

一个用户可以针对很多贴文评分，一篇贴文也可以有多人评分，让我们新增一个 PostScore model 来纪录分数：

执行 `rails g model post_score`

修改 `db/migrate/201704XXXXXXXX_create_post_scores.rb

db/migrate/201704XXXXXXXX_create_post_scores.rb

```
 class CreatePostScores < ActiveRecord::Migration[5.0]
    def change
      create_table :post_scores do |t|
+       t.integer :post_id, :index => true
+       t.integer :score
+       t.integer :user_id
        t.timestamps
      end
    end
  end
```

执行 `rake db:migrate`

编辑 `app/models/post_score.rb`

app/models/post_score.rb

```
 class PostScore < ApplicationRecord
+
+   belongs_to :post
+   belongs_to :user
+
  end
```

编辑 `app/models/post.rb`

app/models/post.rb

```
+  has_many :scores, :class_name => "PostScore"
+
+  def find_score(user)
+    user && self.scores.where( :user_id => user.id ).first
+  end
+
+
+  def average_score
+    self.scores.average(:score)
+  end
```

编辑 `config/routes.rb`

config/routes.rb

```
   resources :posts do
     member do
       post "like" => "posts#like"
       post "unlike" => "posts#unlike"
       post "toggle_flag" => "posts#toggle_flag"
+      post "rate" => "posts#rate"
     end
   end
```

再次修改 `app/views/posts/_post.html.erb`，加上平均分数，以及 data 属性包括用户给的分数 score 和打分的 url，好让 jQuery 可以处理。

```
   <div class="panel-body">
     <span id="post-thumbsup-<%= post.id %>" class="label label-success"><%= post.likes.count %> 👍</span>

-    <div class="raty"></div>
+    <span class="average-score"><%= post.average_score %></span>
+    <div class="raty" data-score="<%= post.find_score(current_user).try(:score) || 0 %>" data-score-url="<%= rate_post_path(post) %>"></div>
+
```

修改 `app/views/posts/index.html.erb`

```
  <script>
-   $(".raty").raty( { path: '/images/' } );
+   $(".raty").raty({
+     path: '/images/',
+     score: function() { return $(this).data('score'); },
+     click: function(score) {
+       var that = this;
+       $.ajax({
+         url: $(this).data("score-url"),
+         method: "POST",
+         data: { score: score },
+         dataType: "json",
+         success: function(data){
+           $(that).closest(".panel-body").find(".average-score").html( data["average_score"] );
+         }
+       })
+     }
+   });
  </script>
```

根据 raty 的文档，其中：

- `score` 是初始函式，我們已經用 `data-score` 属性将用户之前的评分放上去，這裡再用 `$(this).data('score');` 抓到值。
- `click` 是当用户点击星星时，会触发的函式。这里就是会送出 Ajax 请求。

编辑 `app/controllers/posts_controller.rb` 加上接收的 action：

app/controllers/posts_controller.rb

```
+  def rate
+    @post = Post.find(params[:id])
+
+    existing_score = @post.find_score(current_user)
+    if existing_score
+      existing_score.update( :score => params[:score] )
+    else
+      @post.scores.create( :score => params[:score], :user => current_user )
+    end
+
+    render :json => { :average_score => @post.average_score }
+  end
```

最后成果：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/sDFUTBQNqNwgUTm91xgI_rating2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/sDFUTBQNqNwgUTm91xgI_rating2.png)

### 本节作业

##### [Ajax 作业](https://fullstack.xinshengdaxue.com/assignments/43)：[作业四](https://fullstack.xinshengdaxue.com/tasks/300)

已有 37 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/300/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/300)

请将完成的贴文标记垃圾、选择分类和打星画面，用 git 截图上来。

# 5-1 jquery-ujs

Rails 的 `:remote => true` 的这个功能，在 Rails 是透过 [jquery-ujs](https://github.com/rails/jquery-ujs) 这个 gem 所提供的，你可以在 `Gemfile` 中找到它，以及在 `app/assets/javascripts/application.js` 里面加载了 `//= require jquery_ujs`。

之所以叫 UJS 是因为全名叫做 Unobtrusive JavaScript。那么什么是 Unobtrusive 呢？用个范例来说吧，以下代码会将超连结改成用表单DELETE送出，并且用一个提示视窗来作确认：

```
link_to 'Remove', post_path(1), :method => :delete, :data => { :confirm => "Sure?" }
```

在 Rails 3 以前的版本，会输出：

```
<a onclick="if (confirm('Sure?')) { var f = document.createElement('form'); f.style.display = 'none'; this.parentNode.appendChild(f); f.method = 'POST'; f.action = this.href;var m = document.createElement('input'); m.setAttribute('type', 'hidden'); m.setAttribute('name', '_method'); m.setAttribute('value', 'delete'); f.appendChild(m);f.submit(); };return false;" href="/events/1">Remove</a>
```

看起来有点复杂，其实只是透过 onclick 属性把 JavaScript 代码写在里面。

在 Rails 3 之后，则会输出：

```
<a rel="nofollow" data-confirm="Sure?" data-method="delete" class="delete" href="/events/1">Remove</a>
```

然后在 jquery_ujs 的 JavaScript 库里面会检查 DOM 里面有 `data-confirm` 和 `data-method` 的超连结，再去绑订事件。

Unobtrusive 的概念就是将 JavaScript 代码与 HTML 分开，除了可以让 HTML 码干净之外，也可以支援更换不同的 JavaScript 库。

jquery-ujs 的功能包括了：

- 让超连结可以用 :method 参数支援非 GET 方法
- 用超连结、按钮和表单可以用 `:remote => true` 支援 Ajax
- 超连结、按钮和表单可以用 `:data => { :confirm => "Are you sure? }` 参数，跳出确认对话视窗
- 送出按钮可以用 `:data => { :disable_with => "Please wait..." }` 参数在送出表单时暂时关闭按钮避免重复送出
- 在 Layout 的 head 中有输出一段 `<%= csrf_meta_tag %>` 的作用也是搭配给 UJS 使用的，这会让 jQuery 的 $ajax 送出时附带 CSRF 表单安全验证码，我们会在之后的网络安全一章讨论到什么是CSRF。

总之，如果 jquery-ujs 没有顺利加载的话，不只 `:remote => true` 不能用，所有非 GET 方法的超连结会坏掉，会变成 GET 出去。另外还有 Devise 的登出按钮因为用了 `:method => :delete` 也会无法作用。
