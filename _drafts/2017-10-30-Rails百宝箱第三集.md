---
layout: post
title: "Rails百宝箱第三集"
date: 2017-10-30
tags:
    Rails
    教材
---
#Rails百宝箱第三集

| 15. 自订列表顺序                               |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  15-1 需求和 Model 设计](https://fullstack.xinshengdaxue.com/posts/1144) |                                          |
| [**  15-2 传统 UI](https://fullstack.xinshengdaxue.com/posts/1145) |                                          |
| [**  15-3 Ajax UI](https://fullstack.xinshengdaxue.com/posts/1146) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1146#task) |

| 16. 多步骤表单                                |      |
| ---------------------------------------- | ---- |
| [**  16-1 需求和 Model 设计](https://fullstack.xinshengdaxue.com/posts/1147) |      |
| [**  16-2 建立报名表单](https://fullstack.xinshengdaxue.com/posts/1148) |      |
| [**  16-3 多步骤表单](https://fullstack.xinshengdaxue.com/posts/1149) |      |
| [**  16-4 第一步的表单](https://fullstack.xinshengdaxue.com/posts/1150) |      |
| [**  16-5 第二步的表单](https://fullstack.xinshengdaxue.com/posts/1151) |      |
| [**  16-6 第三步的表单](https://fullstack.xinshengdaxue.com/posts/1152) |      |
| [**  16-7 回到上一步](https://fullstack.xinshengdaxue.com/posts/1153) |      |
| [**  16-8 有条件的表单验证](https://fullstack.xinshengdaxue.com/posts/1154) |      |

| 17. 显示资料验证错误讯息                           |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  17-1 显示资料验证的错误讯息](https://fullstack.xinshengdaxue.com/posts/1155) |                                          |
| [**  17-2 内联式(inline)错误讯息](https://fullstack.xinshengdaxue.com/posts/1156) |                                          |
| [**  17-3 自订义资料验证的错误显示](https://fullstack.xinshengdaxue.com/posts/1157) |                                          |
| [**  17-4 HTML5 前端资料验证](https://fullstack.xinshengdaxue.com/posts/1158) |                                          |
| [**  17-5 前端套件资料验证](https://fullstack.xinshengdaxue.com/posts/1159) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1159#task) |

| 18. 资料筛选和搜寻                              |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  18-1 制作后台管理报名资料](https://fullstack.xinshengdaxue.com/posts/1160) |                                          |
| [**  18-2 分页机制](https://fullstack.xinshengdaxue.com/posts/1161) |                                          |
| [**  18-3 筛选资料(单选)](https://fullstack.xinshengdaxue.com/posts/1162) |                                          |
| [**  18-4 筛选资料(多选)](https://fullstack.xinshengdaxue.com/posts/1163) |                                          |
| [**  18-5 时间区间筛选](https://fullstack.xinshengdaxue.com/posts/1164) |                                          |
| [**  18-6 资料比对筛选](https://fullstack.xinshengdaxue.com/posts/1165) |                                          |
| [**  18-7 关键字搜寻，使用 Ransack](https://fullstack.xinshengdaxue.com/posts/1166) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1166#task) |
| [**  18-8 前台的活动状态筛选](https://fullstack.xinshengdaxue.com/posts/1167) |                                          |

| 19. 软删除和版本控制                             |      |
| ---------------------------------------- | ---- |
| [**  19-1 需求说明](https://fullstack.xinshengdaxue.com/posts/1168) |      |
| [**  19-2 安装使用 paper_trail](https://fullstack.xinshengdaxue.com/posts/1169) |      |
| [**  19-3 编修纪录的 UI 和复原](https://fullstack.xinshengdaxue.com/posts/1170) |      |

| 20. 数据汇出                                 |      |
| ---------------------------------------- | ---- |
| [**  20-1 汇出 CSV 档案](https://fullstack.xinshengdaxue.com/posts/1171) |      |
| [**  20-2 汇出 Excel 档案](https://fullstack.xinshengdaxue.com/posts/1172) |      |

# 15-1 需求和 Model 设计

情境：在后台可以自定义活动列表的显示顺序

目前在前后台的 events index action，我们并没有指定用什么顺序。
如果要指定顺序，可以用 `order`，例如根据新建的顺序递降 `Event.order("id DESC")` 或递增 `Event.order("id")`。

接下来我们想做的功能，就是可以用管理员可以自定义顺序，例如让需要曝光的活动放在前面、不重要的活动放在后面。

需要的 Model 设计很简单，就是增加一个整数字段来存「位置」。这种列表顺序的功能，有两个 gem 可以用：

- [acts_as_list](https://github.com/swanandp/acts_as_list)
- [ranked-model](https://github.com/mixonic/ranked-model)

这些 gem 提供了方法，帮助我们快速修改这个位置数字。

这里介绍用 ranked-model，两个 gem 大同小异。

装 Gemfile

Gemfile

```
+  gem 'ranked-model'
```

编辑 `app/models/event.rb`

app/models/event.rb

```
  class Event < ApplicationRecord

+   include RankedModel
+   ranks :row_order
```

执行 `bundle`，重启服务器

执行 `rails g migration add_row_order_to_events`

编辑 `db/migrate/20170427130106_add_row_order_to_events.rb`，增加一个 `row_order` 字段到 `events` 上。

> 这是因为 ranked-model 默认的位置字段命名是 `row_order`

20170427130106_add_row_order_to_events.rb

```
  class AddRowOrderToEvents < ActiveRecord::Migration[5.0]

    def change
+     add_column :events, :row_order, :integer
+
+     # 因为要改用这个 row_order 来做排序，而数据库已经有的 events 默认是 nil
+     # 因此这里要设定 row_order 的值，其中 `:last` 是 ranked-model
+     Event.find_each do |e|
+       e.update( :row_order_position => :last )
+     end
+
+     add_index :events, :row_order
    end

  end
```

执行 `rake db:migrate`

修改 `app/controllers/events_controller.rb`，改成用 `rank(:row_order)` 方法来做排序。

```
   class EventsController < ApplicationController

     def index
-      @events = Event.all
+      @events = Event.rank(:row_order).all
     end
```

修改 `app/controllers/admin/events_controller.rb`

```
   class Admin::EventsController < AdminController

     def index
-      @events = Event.all
+      @events = Event.rank(:row_order).all
     end
```

重新浏览看看，应该一切正常没有变化。

我们可以实验看看这个 gem 的作用，请执行 `rails console`

`e = Event.last`
`e.row_order_position = :up`
`e.save!`

重新浏览看看，本来放最后的活动，应该顺序往前一笔。

`e.row_order_position = :first`
`e.save!`

重新浏览看看，这一笔应该会移动到第一笔。

> row_order_position 不是数据库的字段，而是一个方法会转换输入的字符串到 row_order (这是整数)，例如 e.row_order_position = :first 实际作用是让 e.row_order = 一个最小的数字

接着，重头戏是如何让管理员可以编辑这个排序，有两种 UI 解法：

- 传统 UI：提供往上、往下、移到顶端、移到尾端 等四个按钮
- Ajax UI：直接用鼠标进行拖拉排序

# 15-2 传统 UI

所谓的传统 UI，就是提供往上、往下、移到顶端、移到尾端 等四个按钮，让我们来实作看看。

编辑 `config/routes.rb`

config/routes.rb

```
resources :events do
  resources :tickets, :controller => "event_tickets"

+     member do
+       post :reorder
+     end
```

编辑 `app/views/admin/events/index.html.erb`，加上四个按钮：

app/views/admin/events/index.html.erb

```
<td>
+     <%= link_to "上移", reorder_admin_event_path(event, :position => :up), :method => :post, :class => "btn btn-default" %>
+     <%= link_to "下移", reorder_admin_event_path(event, :position => :down), :method => :post, :class => "btn btn-default" %>
+     <%= link_to "置顶", reorder_admin_event_path(event, :position => :first), :method => :post, :class => "btn btn-default" %>
+     <%= link_to "置底", reorder_admin_event_path(event, :position => :last), :method => :post, :class => "btn btn-default" %>

  <%= link_to "Tickets", admin_event_tickets_path(event), :class => "btn btn-default" %>
```

> 在路由方法 `reorder_admin_event_path` 中，我们额外传了 `:position` 参数，等会在 controller 中就可以接收到 `params[:position]` 代表移动的方式

编辑 `app/controllers/admin/events_controller.rb`

app/controllers/admin/events_controller.rb

```
+  def reorder
+    @event = Event.find_by_friendly_id!(params[:id])
+    @event.row_order_position = params[:position]
+    @event.save!
+
+    redirect_to admin_events_path
+  end
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/lnbTx58XRue6tEloQpCz_15-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/lnbTx58XRue6tEloQpCz_15-1.png)

这样就完成了。

# 15-3 Ajax UI

所谓的 Ajax 拖拉 UI，就是直接用鼠标进行拖拉排序，这种方式对用户来说操作速度更快。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pWQxNtMMTraSX1DTW0nH_15-2.gif)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pWQxNtMMTraSX1DTW0nH_15-2.gif)

拖拉的 UI 需要额外的前端套件，这里介绍 jQuery UI 的 [Sortable Plugin](http://api.jqueryui.com/sortable/)，并直接使用 [jquery-ui-rails](https://github.com/joliss/jquery-ui-rails) 这个 gem 来安装

编辑 `Gemfile`

Gemfile

```
+  gem 'jquery-ui-rails'
```

编辑 `app/assets/javascripts/admin.js`

app/assets/javascripts/admin.js

```
  //= require bootstrap-datepicker/core
  //= require bootstrap-datepicker/locales/bootstrap-datepicker.zh-CN
  //= require ckeditor/init
+ //= require jquery-ui
```

编辑 `app/assets/stylesheets/admin.scss`，其中 `.sortable_icon` 是给画面中可被拖拉的 ☰ 的样式

app/assets/stylesheets/admin.scss

```
+  @import "jquery-ui";
+
+  .sortable .sortable_icon {
+   border: none;
+   color: #ECECEC;
+   font-size: 20px;
+   cursor: move;
+   padding-right: 10px;
+  }
```

执行 `bundle`，重启服务器

编辑 `app/views/admin/events/index.html.erb`

app/views/admin/events/index.html.erb

```
   <table class="table">
+  <thead>
   <tr>
     <th><%= check_box_tag "全选", "1", false, :id => "toggle_all" %></th>
     <th>Event Name</th>
     <th>Actions</th>
   </tr>
+  </thead>
+  <tbody class="sortable">
   <% @events.each do |event| %>
-    <tr>
+    <tr data-reorder-url="<%= reorder_admin_event_path(event) %>">
       <td>
         <%= check_box_tag "ids[]", event.id %>
       </td>
-      <td><%= link_to event.name, admin_event_path(event) %></td>
+      <td>
+        <span class="sortable_icon">☰</span>
+        <%= link_to event.name, admin_event_path(event) %>
+      </td>
       <td>
-        <%= link_to "上移", reorder_admin_event_path(event, :position => :up), :method => :post, :class => "btn btn-default" %>
-        <%= link_to "下移", reorder_admin_event_path(event, :position => :down), :method => :post, :class => "btn btn-default" %>
         <%= link_to "置顶", reorder_admin_event_path(event, :position => :first), :method => :post, :class => "btn btn-default" %>
         <%= link_to "置底", reorder_admin_event_path(event, :position => :last), :method => :post, :class => "btn btn-default" %>
         <%= link_to "Tickets", admin_event_tickets_path(event), :class => "btn btn-default" %>
         <%= link_to "Edit", edit_admin_event_path(event), :class => "btn btn-default" %>
         <%= link_to "Delete", admin_event_path(event), :method => "delete", :data => { :confirm => "Are you sure?" }, :class => "btn btn-danger" %>
     </tr>
   <% end %>
+  </tbody>
   </table>
     <p>
     <%= select_tag :event_status, options_for_select( Event::STATUS.map{ |s| [t(s, :scope => "event.status"), s] }), :class => "form-control" %>
     <%= submit_tag t(:bulk_update), :class => "btn btn-primary" %>
     <%= submit_tag t(:bulk_delete), :class => "btn btn-danger", :data => { :confirm => "Are you sure?" } %>
     </p>
   <% end %>

   <script>
     $("#toggle_all").click(function(){
       if ( $(this).prop("checked") ) {
         $("input[name='ids[]']").prop("checked", false);
       }
     })

+  $( ".sortable" ).sortable({
+    axis: 'y',       // 限制只能上下拖拉
+    items: 'tr',     // 拖拉整个 tr
+    cursor: 'move',  // 变更拖拉时的 icon
+    handle: ".sortable_icon",  // 限制只有点 ☰ 才能开始拖拉，砍掉这行的话，会是整个 tr 都可以进行拖拉，你可以试试看
+    stop: function(e, ui){     // 当拖拉结束时，会调用这个方法
+      ui.item.children('td').effect('highlight', {}, 1000)
+    },
+    update: function(e, ui) {   // 当拖拉结束并且 DOM 上的位置变更时，会调用这个方法
+      reorder_url = ui.item.data('reorder-url')
+      position = ui.item.index()  // 取得顺序
+      $.ajax({
+       type: 'POST',
+       url: reorder_url,
+       dataType: 'json',
+       data: { position: position }
+      })
+    }
+  });
   </script>
```

设计解说：

1. 我们将整个 tr 包在 tbody 之中，好让 `$( ".sortable" ).sortable` 将 tbody 标籤内的 tr 都变成可以拖拉，而不会拖拉到标题列 thead 中的 tr。
2. 因为每个活动的 reorder 网址都不同，所以我们将网址放在 `data-reorder-url="<%= reorder_admin_event_path(event) %>` 之中，这样在 jQuery 里面透过 `reorder_url = ui.item.data('reorder-url')` 就可以取得 Ajax 要送去的网址。

编辑 `app/controllers/admin/events_controller.rb`

app/controllers/admin/events_controller.rb

```
  def reorder
    @event = Event.find_by_friendly_id!(params[:id])
    @event.row_order_position = params[:position]
    @event.save!

-    redirect_to admin_events_path
+    respond_to do |format|
+      format.html { redirect_to admin_events_path }
+      format.json { render :json => { :message => "ok" }}
+    end
  end
```

> `respond_to` 可以让 Rails 根据 request 请求的格式(在 $ajax 中我们有指定了 dataType 是 json)，来回传不同格式。

这样就完成了。

#### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/54)：[作业一](https://fullstack.xinshengdaxue.com/tasks/317)

已有 32 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/317/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/317)

请在任一个项目中，实作 Ajax 拖拉排序的功能。请上传 gif 动图结果。

# 16-1 需求和 Model 设计

接下来要制作的功能是：用户可以报名活动，也就是 event has_many registrations。

首先建立 Registration model

执行 `rails g model registration`

编辑 `db/migrate/20170429152604_create_registrations.rb`

20170429152604_create_registrations.rb

```
  class CreateRegistrations < ActiveRecord::Migration[5.0]
    def change
      create_table :registrations do |t|
+       t.string :status, :default => "pending"
+       t.string :uuid
+       t.integer :event_id, :index => true
+       t.integer :ticket_id, :index => true
+       t.integer :user_id, :index => true
+       t.string :name
+       t.string :email
+       t.string :cellphone
+       t.string :website
+       t.text :bio
+       t.timestamps
      end

+     add_index :registrations, :uuid,  :unique => true
    end
  end
```

执行 `rake db:migrate`

编辑 `app/models/registration.rb`

app/models/registration.rb

```
class Registration < ApplicationRecord

  STATUS = ["pending", "confirmed"]
  validates_inclusion_of :status, :in => STATUS
  validates_presence_of :status, :ticket_id

  belongs_to :event
  belongs_to :ticket
  belongs_to :user, :optional => true

  before_validation :generate_uuid, :on => :create

  def to_param
    self.uuid
  end

  protected

  def generate_uuid
    self.uuid = SecureRandom.uuid
  end

end
```

> 这里设计了 status 状态字段，以及在新建的时候乱数产生一个 UUID 来当作网址 ID。

编辑 `app/models/event.rb`

app/models/event.rb

```
+  has_many :registrations, :dependent => :destroy
```

编辑 `app/models/ticket.rb`

app/models/ticket.rb

```
+  has_many :registrations
```

编辑 `app/models/user.rb`

app/models/user.rb

```
+  has_many :registrations
```

接下来要制作 UI，我们示范两个解法：

- 单一表单
- 多步骤表单

# 16-2 建立报名表单

编辑 `config/routes.rb`

config/routes.rb

```
-  resources :events
+  resources :events do
+    resources :registrations
+  end
```

执行 `rails g controller registrations`

编辑 `app/controllers/registrations_controller.rb`

app/controllers/registrations_controller.rb

```
class RegistrationsController < ApplicationController

  before_action :find_event

  def new
  end

  def create
    @registration = @event.registrations.new(registration_params)
    @registration.ticket = @event.tickets.find( params[:registration][:ticket_id] )
    @registration.status = "confirmed"
    @registration.user = current_user

    if @registration.save
      redirect_to event_registration_path(@event, @registration)
    else
      render "new"
    end
  end

  def show
    @registration = @event.registrations.find_by_uuid(params[:id])
  end

  protected

  def registration_params
    params.require(:registration).permit(:ticket_id, :name, :email, :cellphone, :website, :bio)
  end

  def find_event
    @event = Event.find_by_friendly_id(params[:event_id])
  end

end
```

> 这里针对 ticket 额外用 `@event.tickets.find` 再检查确定这个票种属于这个活动

编辑 `app/views/events/show.html.erb` 加上一个按钮去报名表单

app/views/events/show.html.erb

```
+ <p><%= link_to "开始报名", new_event_registration_path(@event), :class => "btn btn-primary" %></p>
```

![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/kw3BL9m1Q96poKVl2Jyx_16-1.png)

新增 `app/views/registrations/new.html.erb` 报名页面

app/views/registrations/new.html.erb

```
<h1><%= @event.name %></h1>

<%= form_for [@event, Registration.new] do |f| %>

  <div class="form-group">
    <%= f.label :ticket_id %>
    <%= f.select :ticket_id, @event.tickets.map{ |t| [t.name, t.id] }, {}, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :name %>
    <%= f.text_field :name, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :email %>
    <%= f.email_field :email, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :cellphone %>
    <%= f.text_field :cellphone, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :website %>
    <%= f.url_field :website, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :bio %>
    <%= f.text_area :bio, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.submit "Submit", :class => "btn btn-primary" %>
  </div>

<% end %>
```



[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/aPCTXvkzQxmi0MxYDVZj_16-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/aPCTXvkzQxmi0MxYDVZj_16-2.png)

新增 `app/views/registrations/show.html.erb` 报名成功页面

app/views/registrations/show.html.erb

```
<h1><%= @event.name %></h1>

<h2>报名资料</h2>

<dl>
  <dt>状态</dt>
  <dd><%= t(@registration.status, :scope => "registration.status") %></dd>
  <dt>姓名</dt>
  <dd><%= @registration.name %></dd>
  <dt>E-mail</dt>
  <dd><%= @registration.email %></dd>
  <dt>电话</dt>
  <dd><%= @registration.cellphone %></dd>
  <dt>网站</dt>
  <dd><%= @registration.website %></dd>
  <dt>自我介绍</dt>
  <dd><%= simple_format @registration.bio %></dd>
</dl>
```

编辑 `config/locales/zh-CN.yml` 新增状态的翻译

```
  "zh-CN":
+   registration:
+     status:
+       pending: 报名尚未完成
+       confirmed: 报名成功
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/6FYL6hxLSyOGyYT1vXDe_16-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/6FYL6hxLSyOGyYT1vXDe_16-3.png)

这样就完成了。如果只是这样就太小看大家了，让我们继续看下去...

# 16-3 多步骤表单

接下来的重头戏是制作多步骤的表单(Multi Step Form，又叫做 Wizards)

> Protip: 记得这些英文名词对 google 是有帮助的，google "wizards rails" 就可以找到如何做这个功能的教程

什么时候会用到呢? 当表单很复杂的时候，我们不希望一次就把所有字段显示出来，这样会吓跑用户。而是会拆成步骤一、步骤二、步骤三.... 一步一步让用户~~掉入这个坑~~完成表单，以增加表单完成的成功率。

要制作的 UI 将拆分成三个表单：

- 第一个表单: 选票种
- 第二个表单: 填姓名、E-mail、电话
- 第三个表单: 填个人网站URL、填自我介绍

其中第二个表单和第三个表单，除了有下一步之外，也可以回到上一步进行修改。如果用户中途离开，下次再进来也可以继续编辑。

> 另一种纯前端的做法，例如 [jQuery Steps](http://www.jquery-steps.com/)，则是只用特效的方式拆成不同步骤，而没有将过程储存进到数据库，如果中离就毫无纪录。本章的做法是中间过程都会存进数据库。

首先，让我们修改路由 `config/routes.rb`，分别是三个步骤的表单页面和修改动作：

config/routes.rb

```
   resources :events do
-    resources :registrations
+    resources :registrations do
+      member do
+        get "steps/2" => "registrations#step2", :as => :step2
+        patch "steps/2/update" => "registrations#step2_update", :as => :update_step2
+        get "steps/3" => "registrations#step3", :as => :step3
+        patch "steps/3/update" => "registrations#step3_update", :as => :update_step3
+      end
     end
   end
```

没有特别看到 step1 是因为 registrations controller 本来的 new action 和 create action 就是新增时的第一步。

# 16-4 第一步的表单

修改 `app/views/registrations/new.html.erb` 报名页面，只留下选票种：

app/views/registrations/new.html.erb

```
   <h1><%= @event.name %></h1>
+  <h2>Step 1</h2>

   <%= form_for [@event, Registration.new] do |f| %>

     <div class="form-group">
       <%= f.label :ticket_id %>
       <%= f.select :ticket_id, @event.tickets.map{ |t| [t.name, t.id] }, {}, :class => "form-control" %>
     </div>

-    <div class="form-group">
-      <%= f.label :name %>
-      <%= f.text_field :name, :class => "form-control" %>
-    </div>
-
-    <div class="form-group">
-      <%= f.label :email %>
-      <%= f.email_field :email, :class => "form-control" %>
-    </div>
-
-    <div class="form-group">
-      <%= f.label :cellphone %>
-      <%= f.text_field :cellphone, :class => "form-control" %>
-    </div>
-
-    <div class="form-group">
-      <%= f.label :website %>
-      <%= f.url_field :website, :class => "form-control" %>
-    </div>
-
-    <div class="form-group">
-      <%= f.label :bio %>
-      <%= f.text_area :bio, :class => "form-control" %>
-    </div>
-
     <div class="form-group">
-      <%= f.submit "Submit", :class => "btn btn-primary" %>
+      <%= f.submit "Save and Next", :class => "btn btn-primary" %>
     </div>

   <% end %>
```

编辑 `app/controllers/registrations_controller.rb`

app/controllers/registrations_controller.rb

```
   def create
     @registration = @event.registrations.new(registration_params)
     @registration.ticket = @event.tickets.find( params[:registration][:ticket_id] )
-    @registration.status = "confirmed"
+    @registration.status = "pending"
     @registration.user = current_user

     if @registration.save
-      redirect_to event_registration_path(@event, @registration)
+      redirect_to step2_event_registration_path(@event, @registration)
     else
       render "new"
     end
   end
```

本来进 create action 就完成了，现在要改成进 step2 action。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/99yUP3WTTNXOapkC2JGW_16-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/99yUP3WTTNXOapkC2JGW_16-4.png)

# 16-5 第二步的表单

接着要编辑第二步：

编辑 `app/controllers/registrations_controller.rb`

app/controllers/registrations_controller.rb

```
+  def step2
+    @registration = @event.registrations.find_by_uuid(params[:id])
+  end
+
+  def step2_update
+    @registration = @event.registrations.find_by_uuid(params[:id])
+
+    if @registration.update(registration_params)
+      redirect_to step3_event_registration_path(@event, @registration)
+    else
+      render "step2"
+    end
+  end
```

新增 `app/views/registrations/step2.html.erb`

app/views/registrations/step2.html.erb

```
<h1><%= @event.name %></h1>

<h2>Step 2</h2>

<%= form_for @registration, :url => update_step2_event_registration_path(@event, @registration) do |f| %>

  <div class="form-group">
    <%= f.label :name %>
    <%= f.text_field :name, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :email %>
    <%= f.email_field :email, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :cellphone %>
    <%= f.text_field :cellphone, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.submit "Save & Next", :class => "btn btn-primary" %>
  </div>

<% end %>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/AGM93TCSdSDcRLPcgZgg_16-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/AGM93TCSdSDcRLPcgZgg_16-5.png)

# 16-6 第三步的表单

接着要编辑第三步：

编辑 `app/controllers/registrations_controller.rb`

app/controllers/registrations_controller.rb

```
+  def step3
+    @registration = @event.registrations.find_by_uuid(params[:id])
+  end
+
+  def step3_update
+    @registration = @event.registrations.find_by_uuid(params[:id])
+    @registration.status = "confirmed"
+
+    if @registration.update(registration_params)
+      flash[:notice] = "报名成功"
+      redirect_to event_registration_path(@event, @registration)
+    else
+      render "step3"
+    end
+  end
```

新增 `app/views/registrations/step3.html.erb`

app/views/registrations/step3.html.erb

```
<h1><%= @event.name %></h1>

<h2>Step 3</h2>

<%= form_for @registration, :url => update_step3_event_registration_path(@event, @registration) do |f| %>

  <div class="form-group">
    <%= f.label :website %>
    <%= f.url_field :website, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :bio %>
    <%= f.text_area :bio, :class => "form-control" %>
  </div>

  <div class="form-group">
    <%= f.submit "Submit", :class => "btn btn-primary" %>
  </div>

<% end %>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/IWc3nfDgRAOAda0zrmq4_16-6.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/IWc3nfDgRAOAda0zrmq4_16-6.png)

这样基本上就完成了，在 step3_update action 中，最后成功后会转去 show 成功画面。

# 16-7 回到上一步

接下来让我们加上「回到上一步」的按钮。

首先是第三步回第二步，修改 `app/views/registrations/step3.html.erb`

app/views/registrations/step3.html.erb

```
   <div class="form-group">
+    <%= link_to "Previous", step2_event_registration_path(@event, @registration), :class => "btn btn-default" %>
     <%= f.submit "Submit", :class => "btn btn-primary" %>
   </div>
```

这个简单，一个连结回去 step2 即可。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/kr1KcA3gR1aI9QC5XMmn_16-7.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/kr1KcA3gR1aI9QC5XMmn_16-7.png)

接下来是第二步回到第一步，编辑 `config/routes.rb`

config/routes.rb

```
   resources :events do
     resources :registrations do
       member do
+        get "steps/1" => "registrations#step1", :as => :step1
+        patch "steps/1/update" => "registrations#step1_update", :as => :update_step1
         get "steps/2" => "registrations#step2", :as => :step2
         patch "steps/2/update" => "registrations#step2_update", :as => :update_step2
         get "steps/3" => "registrations#step3", :as => :step3
         patch "steps/3/update" => "registrations#step3_update", :as => :update_step3
       end
     end
   end
```

修改 `app/views/registrations/step2.html.erb`

app/views/registrations/step2.html.erb

```
   <div class="form-group">
+    <%= link_to "Previous", step1_event_registration_path(@event, @registration), :class => "btn btn-default" %>
     <%= f.submit "Save & Next", :class => "btn btn-primary" %>
   </div>
```

这里就很不一样了，当初新增时的第一步是 `new_event_registration_path`，而不是这里写的 `step1_event_registration_path`。这是因为如果已经开始编辑了，那么「回头编辑时」的第一步跟「新增当时」的第一步，虽然表单长得一样，但是其实是不同页面，操作也不一样，前者是更新资料(update_step1 action)，后者新建资料(create action)。

接着让我们新增「回头编辑时」的第一步动作，请编辑 `app/controllers/registrations_controller.rb`

app/controllers/registrations_controller.rb

```
+  def step1
+    @registration = @event.registrations.find_by_uuid(params[:id])
+  end
+
+  def step1_update
+    @registration = @event.registrations.find_by_uuid(params[:id])
+
+    if @registration.update(registration_params)
+      redirect_to step2_event_registration_path(@event, @registration)
+    else
+      render "step1"
+    end
+  end
```

新增 `app/views/registrations/step1.html.erb`

app/views/registrations/step1.html.erb

```
<h1><%= @event.name %></h1>
<h2>Step 1</h2>

<%= form_for [@event, @registration], :url => update_step1_event_registration_path(@event, @registration) do |f| %>

  <%= render :partial => "step1_form", :locals => { :f => f } %>

<% end %>
```

因为 `new.html.erb` 和 `step1.html.erb` 的表单是一模一样的，所以让我们拆出来 partial 样板：

新增 `app/views/registrations/_step1_form.html.erb`

app/views/registrations/_step1_form.html.erb

```
<div class="form-group">
  <%= f.label :ticket_id %>
  <%= f.select :ticket_id, @event.tickets.map{ |t| [t.name, t.id] }, {}, :class => "form-control" %>
</div>

<div class="form-group">
  <%= f.submit "Save & Next", :class => "btn btn-primary" %>
</div>
```

编辑 `app/views/registrations/new.html.erb`，改用这个 partial 样板。

app/views/registrations/new.html.erb

```
   <h1><%= @event.name %></h1>
   <h2>Step 1</h2>

   <%= form_for [@event, Registration.new] do |f| %>

-    <div class="form-group">
-      <%= f.label :ticket_id %>
-      <%= f.select :ticket_id, @event.tickets.map{ |t| [t.name, t.id] }, {}, :class => "form-control" %>
-    </div>

-    <div class="form-group">
-      <%= f.submit "Save and Next", :class => "btn btn-primary" %>
-    </div>

+    <%= render :partial => "step1_form", :locals => { :f => f } %>
   <% end %>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/C8EaXqIERKOtVh9ph1lS_16-8.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/C8EaXqIERKOtVh9ph1lS_16-8.png)

你可以试试看这个上一步的功能了。

# 16-8 有条件的表单验证

接下来加上一些资料验证好了，编辑 `app/models/registration.rb`

app/models/registration.rb

```
+  validates_presence_of :name, :email, :cellphone, :bio
```

乍看之下没有问题，但是你会发现我们连第一步都做不下去。因为第一步的表单只有选票种，而没有其他资料。这样存储时验证会失败。

怎么办呢？Rails 可以根据条件来做表单验证，叫做 Conditional Validations。我们需要根据用户实际在做哪一步，来决定要启用哪些验证。

再次编辑 `app/models/registration.rb`

app/models/registration.rb

```
-  validates_presence_of :name, :email, :cellphone, :bio

+  attr_accessor :current_step
+  validates_presence_of :name, :email, :cellphone, :if => :should_validate_basic_data?
+  validates_presence_of :name, :email, :cellphone, :bio, :if => :should_validate_all_data?

  # 略

   protected

+  def should_validate_basic_data?
+    current_step == 2  # 只有做到第二步需要验证
+  end
+
+  def should_validate_all_data?
+    current_step == 3 || status == "confirmed"  # 做到第三步，或最后状态是 confirmed 时需要验证
+  end
```

解说：

- `:if` 这个参数可以设定调用那一个方法来决定要不要启用这个验证，回传 true 就是要，回传 false 就是不要
- 透过 `attr_accessor :current_step` 我们增加一个虚拟属性(也就是数据库中并没有这个字段)来代表目前做到哪一步

编辑 `app/controllers/registrations_controller.rb`

```
   def create
     @registration = @event.registrations.new(registration_params)
     @registration.ticket = @event.tickets.find( params[:registration][:ticket_id] )
     @registration.status = "pending"
     @registration.user = current_user
+    @registration.current_step = 1

   # 略

   def step1_update
     @registration = @event.registrations.find_by_uuid(params[:id])
+    @registration.current_step = 1

   # 略

   def step2_update
     @registration = @event.registrations.find_by_uuid(params[:id])
+    @registration.current_step = 2

   # 略

   def step3_update
     @registration = @event.registrations.find_by_uuid(params[:id])
     @registration.status = "confirmed"
+    @registration.current_step = 3

   # 略
```

我们在每次调用 `save` 存进数据库前，设定一下 `current_step` 的值，这样就可以有条件的触发对应的资料验证了。

# 17-1 显示资料验证的错误讯息

上一章实作的报名的表单，如果资料验证没有通过的话，目前没有显示任何错误讯息，让我们补上错误讯息。

编辑 `app/views/registrations/step2.html.erb`

app/views/registrations/step2.html.erb

```
   <h2>Step 2</h2>

+  <% if @registration.errors.any? %>
+    <ul>
+    <% @registration.errors.full_messages.each do |error| %>
+      <li><%= error %></li>
+    <% end %>
+    </ul>
+  <% end %>
```

编辑 `app/views/registrations/step3.html.erb`

app/views/registrations/step3.html.erb

```
   <h2>Step 3</h2>

+  <% if @registration.errors.any? %>
+    <ul>
+    <% @registration.errors.full_messages.each do |error| %>
+      <li><%= error %></li>
+    <% end %>
+    </ul>
+  <% end %>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/euQ9ojlaS2aXxfSTsX6f_16-9.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/euQ9ojlaS2aXxfSTsX6f_16-9.png)

不过，这样的 UI 只是用起来简单，但是对用户并不是很友善，因为眼睛需要上上下下跑，才能找到底出错的字段是哪一个。

因此目前公认推荐比较好 UI 作法，是将错误讯息放在输入框旁边...

# 17-2 内联式(inline)错误讯息

像这样直接把字段的错误讯息，显示在输入框旁边，就非常一目了然了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Dup1NC6Tmmr5K9WCbTzV_16-10.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Dup1NC6Tmmr5K9WCbTzV_16-10.png)

编辑 `app/views/registrations/step2.html.erb`

app/views/registrations/step2.html.erb

```
- <% if @registration.errors.any? %>
-   <ul>
-   <% @registration.errors.full_messages.each do |error| %>
-     <li><%= error %></li>
-   <% end %>
-   </ul>
- <% end %>

  <%= form_for @registration, :url => update_step2_event_registration_path(@event, @registration) do |f| %>
-   <div class="form-group">
+   <div class="form-group <%= (f.object.errors[:name].any?)? "has-error" : "" %>">
-     <%= f.label :name %>
+     <%= f.label :name, "姓名", :class => "control-label" %>
      <%= f.text_field :name, :class => "form-control" %>

+     <% if f.object.errors[:name] %>
+       <span class="help-block"><%= safe_join(f.object.errors[:name], "、") %></span>
+     <% end %>
    </div>

-   <div class="form-group">
+   <div class="form-group <%= (f.object.errors[:email].any?)? "has-error" : "" %>">
-     <%= f.label :email %>
+     <%= f.label :email, "E-mail", :class => "control-label" %>
      <%= f.email_field :email, :class => "form-control" %>

+     <% if f.object.errors[:email] %>
+       <span class="help-block"><%= safe_join(f.object.errors[:email], "、") %></span>
+     <% end %>
    </div>

-   <div class="form-group">
+   <div class="form-group <%= (f.object.errors[:cellphone].any?)? "has-error" : "" %>">
-     <%= f.label :cellphone %>
+     <%= f.label :cellphone, "电话", :class => "control-label" %>
      <%= f.text_field :cellphone, :class => "form-control" %>

+     <% if f.object.errors[:cellphone] %>
+       <span class="help-block"><%= safe_join(f.object.errors[:cellphone], "、") %></span>
+     <% end %>
    </div>
```

解说：

- `f.object` 指的是这个 `form_for` 表单的 model 物件，也就是 `@registration`
- `f.object.errors[字段名称]` 是个数组储存了这个字段的错误讯息
- `has-error` 和 `help-block` 是 Bootstrap 提供的样式，这里配合使用。

# 17-3 自订义资料验证的错误显示

内联式(inline)错误讯息有个小问题，就是有些错误不属于表单上的某个输入字段。例如我们来自定义一个资料验证：如果活动的状态是 draft 草稿，则不允许新增报名。

编辑 `app/models/registration.rb`

app/models/registration.rb

```
+  validate :check_event_status, :on => :create

   # (略)

   protected

+  def check_event_status
+    if self.event.status == "draft"
+      errors.add(:base, "活动尚未开放报名")
+    end
+  end
```

解说：

- `validate` 可以增加自定义的资料验证，后面的 `:on => :create` 参数可以指定只有新建才会验证(默认是新建跟修改都会验证)
- 验证不通过时，会用`errors.add` 增加错误讯息，第一个参数是字段名称，第二个参数是错误讯息
- 因为表单上并没有 `event_id` 这个输入框，所以就算写成 `errors.add(:event_id, "活动尚未开放报名")` 也没有地方显示出来。依照惯例，任何不属于某个字段的错误，我们会放在 `:base` 上。

那怎么把显示 `errors[:base]` 显示出来？有两种方法：

#### 方法一：同 17-1 的作法

透过循环 `@registration.errors[:base]` 把错误讯息印出来，例如：

```
<% if @registration.errors[:base].any? %>
  <ul>
  <% @registration.errors[:base].each do |error| %>
    <li><%= error %></li>
  <% end %>
  </ul>
<% end %>
```

#### 方法二：用 flash

flash 一般用在 redirect 跳转页面前后，用来传递提示讯息。这里也可以沿用 flash 的样式来显示资料验证的错误。

编辑 `app/controllers/registrations_controller.rb`

app/controllers/registrations_controller.rb

```
  def create
    @registration = @event.registrations.new(registration_params)
    @registration.ticket = @event.tickets.find( params[:registration][:ticket_id] )
    @registration.status = "pending"
    @registration.user = current_user
    @registration.current_step = 1

    if @registration.save
      redirect_to step2_event_registration_path(@event, @registration)
    else
+     flash.now[:alert] = @registration.errors[:base].join("、")
      render "new"
    end
  end
```

本来的 `flash` 搭配的是 `redirect`，这会在跳转后清空 flash 讯息(所以只会显示一次)。
这里因为并不是 `redirect` 跳转，而是用 `render` 显示页面，这种情况要改用 `flash.now`。

> 有研究精神的话，你可以试试看在这里用 `flash[:alert]`，你会发现出现错误讯息之后，再点一次其他页面，错误讯息还会多重复出现一次。

另外，顺便修理一下目前的 flash 样式以配合 Bootstrap。

app/views/layout/application.html.erb

```
-  <p class="notice"><%= notice %></p>
+  <% if notice %>
+    <p class="notice alert-success"><%= notice %></p>
+  <% end %>

-  <p class="alert"><%= alert %></p>
+  <% if alert %>
+    <p class="alert alert-danger"><%= alert %></p>
+  <% end %>
```

请挑一个状态是 draft 的活动，然后新增报名就会看到以下错误了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DnVkBZVOQsaCtAVyIgeS_16-11.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DnVkBZVOQsaCtAVyIgeS_16-11.png)

# 17-4 HTML5 前端资料验证

不过无论是 17-1 或 17-2 的作法，都是属于服务器端(server-side)的验证，这种方式的优缺点是：

- 优点：保证资料会被验证后，才会存进数据库
- 缺点：用户一定要按下送出，资料经过服务器验证，才会看到错误讯息，因此反应速度比较慢

但有些简单的验证，前端就可以做了，例如检查必填，这种事情根本不需要后端做，在前端就可以办到了。

在 HTML5 就有定义了一些常见的验证方式，让我们加上去：

编辑 `app/views/registrations/step2.html.erb`

app/views/registrations/step2.html.erb

```
-    <%= f.text_field :name, :class => "form-control" %>
+    <%= f.text_field :name, :class => "form-control", :required => true, :autofocus => true %>

     # (略)

-    <%= f.email_field :email, :class => "form-control" %>
+    <%= f.email_field :email, :class => "form-control", :required => true %>

     # (略)

-    <%= f.text_field :cellphone, :class => "form-control" %>
+    <%= f.text_field :cellphone, :class => "form-control", :required => true %>
```

透过 `required` 就可以让浏览器做必填的资料验证了，按下送出会看到以下画面。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Mn2s0ZreSw6X7X464u5t_16-12.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Mn2s0ZreSw6X7X464u5t_16-12.png)

实际产生出来的 HTML 源码是这样：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9T3wJMq4QEOa9cCFu37I_16-13.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9T3wJMq4QEOa9cCFu37I_16-13.png)

透过 `input` 的 `required="required"` 属性，浏览器就会检查必填了，这个错误讯息的样式是浏览器自带的。

> Protip: `:autofocus => true` 可以在进到这一页时，自动将光标锁定在这一个输入框，这样用户就可以马上~~入坑~~开始填写。一个页面只能有一个输入框用 autofocus。

另外 Email 这个输入框，我们也不是用 `f.text_field :email`，而是用 `f.email_field :email`，这是 HTML5 新的输入类型：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/P26Y3bSKTpmu8CUzHOzY_16-15.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/P26Y3bSKTpmu8CUzHOzY_16-15.png)

外观看起来跟一般文字输入框一模一样，但会让浏览器检查 E-mail 格式：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/kDQNlAuXRGKySsnl9t85_16-14.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/kDQNlAuXRGKySsnl9t85_16-14.png)

最后，第三步表单的 Website 字段，注意到我们是用 `f.url_field :website` 而不是 `f.text_field :website`，这会让浏览器检查输入的文字必须是网址格式。

# 17-5 前端套件资料验证

上述的 HTML5 验证是浏览器内建的，如果想要更漂亮的特效，我们可以考虑安装其他前端的套件，参考 [10 jQuery Form Validation Plugins](https://www.sitepoint.com/10-jquery-form-validation-plugins/) 我们挑一套 [Bootstrap Validator](http://1000hz.github.io/bootstrap-validator/) 来试试看。

这个前端套件没有包好的 Gem 可以安装，请手动下载 [validator.min.js](https://raw.githubusercontent.com/1000hz/bootstrap-validator/master/dist/validator.min.js) 这个 javascript 档案，放在 `vendor/assets/javascripts/` 目录下。

然后修改 `app/assets/javascripts/application.js` 加载它

app/assets/javascripts/application.js

```
+  //= require validator.min
   //= require_tree .
```

编辑 `app/views/registrations/step2.html.erb`

app/views/registrations/step2.html.erb

```
  <h2>Step 2</h2>

+ <% if @registration.errors.any? %>
+   <ul>
+   <% @registration.errors.full_messages.each do |error| %>
+     <li><%= error %></li>
+   <% end %>
+   </ul>
+ <% end %>

  <%= form_for @registration, :url => update_step2_event_registration_path(@event, @registration) do |f| %>

-   <div class="form-group <%= (f.object.errors[:name].any?)? "has-error" : "" %>">
+   <div class="form-group">
      <%= f.label :name, "姓名", :class => "control-label" %>
      <%= f.text_field :name, :class => "form-control", :required => true, :autofocus => true %>

-     <% if f.object.errors[:name] %>
-       <span class="help-block"><%= safe_join(f.object.errors[:name], "、") %></span>
-     <% end %>
+     <div class="help-block with-errors"></div>
    </div>

-   <div class="form-group <%= (f.object.errors[:email].any?)? "has-error" : "" %>">
+   <div class="form-group">
      <%= f.label :email, "E-mail", :class => "control-label" %>
      <%= f.email_field :email, :class => "form-control", :required => true %>

-     <% if f.object.errors[:email] %>
-       <span class="help-block"><%= safe_join(f.object.errors[:email], "、") %></span>
-     <% end %>
+     <div class="help-block with-errors"></div>
    </div>

-   <div class="form-group <%= (f.object.errors[:cellphone].any?)? "has-error" : "" %>">
+   <div class="form-group">
      <%= f.label :cellphone, "电话", :class => "control-label" %>
     <%= f.text_field :cellphone, :class => "form-control", :required => true %>

-     <% if f.object.errors[:cellphone] %>
-       <span class="help-block"><%= safe_join(f.object.errors[:cellphone], "、") %></span>
-     <% end %>
+     <div class="help-block with-errors"></div>
    </div>

    <div class="form-group">
      <%= link_to "Previous", step1_event_registration_path(@event, @registration), :class => "btn btn-default" %>
      <%= f.submit "Save & Next", :class => "btn btn-primary" %>
    </div>

  <% end %>

+ <script>
+   $("form").validator();
+ </script>
```

以下是最后成果，这个前端套件的作法更为精致，它会编辑完一个输入框就验证一次，而不是最后按送出才验证。反应速度非常好。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5y4GXq4ySl2rGnKnmtQt_16-16.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5y4GXq4ySl2rGnKnmtQt_16-16.png)

解说：

- 因为内联式(inline)错误讯息改成用前端套件来处理，因此这里拆掉 17-2 做的。
- 前端验证是不可靠的，用户只要关闭浏览器的 JavaScript 就可以跳过前端验证。以防万一，我们还是把传统的错误讯息方式加回来，如果前端验证失效时，至少还可以看到错误讯息。

剩下 Step 3，请编辑 `app/views/registrations/step3.html.erb`

app/views/registrations/step3.html.erb

```
   <div class="form-group">
     <%= f.label :website %>
     <%= f.url_field :website, :class => "form-control" %>

+    <div class="help-block with-errors"></div>
   </div>

   <div class="form-group">
     <%= f.label :bio %>
-    <%= f.text_area :bio, :class => "form-control" %>
+    <%= f.text_area :bio, :class => "form-control", :required => true %>

     <div class="help-block with-errors"></div>
   </div>

  # (略)

  <script>
    $("form").validator();
  </script>
```

#### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/54)：[作业二](https://fullstack.xinshengdaxue.com/tasks/318)

已有 28 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/318/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/318)

请在任一个项目中，实作内联式(inline)错误讯息，或是安装前端套件资料验证。请显示表单错误的截图。

# 18-1 制作后台管理报名资料

接下来制作报名资料的后台管理页面。

编辑 `config/routes.rb`，增加后台用的 registrations 路由：

config/routes.rb

```
   namespace :admin do
     root "events#index"
     resources :events do
+      resources :registrations, :controller => "event_registrations"
```

修改 `app/views/admin/events/index.html.erb`，加上一个连结可以前往 registration index 页面。

app/views/admin/events/index.html.erb

```
+      <%= link_to "Registrations", admin_event_registrations_path(event), :class => "btn btn-default" %>
       <%= link_to "Tickets", admin_event_tickets_path(event), :class => "btn btn-default" %>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/TpsBcIDfRIKe9YT0WlwO_18-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/TpsBcIDfRIKe9YT0WlwO_18-1.png)

执行 `rails g controller admin::event_registrations`

编辑 `app/controllers/admin/event_registrations_controller.rb`，新增 index 和 destroy action

app/controllers/admin/event_registrations_controller.rb

```
  class Admin::EventRegistrationsController < AdminController

+   before_action :find_event
+
+   def index
+     @registrations = @event.registrations.includes(:ticket).order("id DESC")
+   end
+
+   def destroy
+     @registration = @event.registrations.find_by_uuid(params[:id])
+     @registration.destroy
+
+     redirect_to admin_event_registrations_path(@event)
+   end
+
+   protected
+
+   def find_event
+     @event = Event.find_by_friendly_id!(params[:event_id])
+   end
+
+   def registration_params
+     params.require(:registration).permit(:status, :ticket_id, :name, :email, :cellphone, :website, :bio)
+   end

  end
```

新增 `app/views/admin/event_registrations/index.html.erb`

index.html.erb

```
<h1><%= @event.name %> / Registrations</h1>

<p class="text-right">
<%= link_to "New Registration", new_admin_event_registration_path(@event), :class => "btn btn-primary" %>
</p>

<table class="table">
<tr>
  <th>ID</th>
  <th>Ticket</th>
  <th>Name</th>
  <th>Status</th>
  <th>E-mail</th>
  <th>建立时间</th>
  <th>Actions</th>
</tr>
<% @registrations.each do |registration| %>
  <tr>
    <td><%= registration.id %></td>
    <td><%= registration.ticket.name %></td>
    <td><%= registration.name %></td>
    <td><%= t( registration.status, :scope => "registration.status") %></td>
    <td><%= registration.email %></td>
    <td><%= registration.created_at %></td>
    <td>
      <%= link_to "Edit", edit_admin_event_registration_path(@event, registration), :class => "btn btn-default" %>
      <%= link_to "Delete", admin_event_registration_path(@event, registration), :method => "delete", :data => { :confirm => "Are you sure?" }, :class => "btn btn-danger" %>
  </tr>
<% end %>
</table>
```

> 这里就不练习做新增和编辑了，你应该做了100遍了。

没有资料不好玩，让我们新增一些假资料。请编辑 `lib/tasks/dev.rake` 新增一个任务

lib/tasks/dev.rake

```
  namespace :dev do

+   task :fake_event_and_registrations => :environment do
+     event = Event.create!( :status => "public", :name => "全栈营 Meetup", :friendly_id => "fullstack-meetup")
+     t1 = event.tickets.create!( :name => "Guest", :price => 0)
+     t2 = event.tickets.create!( :name => "VIP 第一期", :price => 199)
+     t3 = event.tickets.create!( :name => "VIP 第二期", :price => 199)
+
+     1000.times do |i|
+       event.registrations.create!( :status => ["pending", "confirmed"].sample,
+                                    :ticket => [t1,t2,t3].sample,
+                                    :name => Faker::Cat.name, :email => Faker::Internet.email,
+                                    :cellphone => "12345678", :bio => Faker::Lorem.paragraph,
+                                    :created_at => Time.now - rand(10).days - rand(24).hours )
+     end
+
+     puts "Let's visit http://localhost:3000/admin/events/fullstack-meetup/registrations"
+   end
```

执行 `rake dev:fake_event_and_registrations`，就会新建一个活动，会有三种票和随机产生1000位报名人。

浏览 `http://localhost:3000/admin/events/fullstack-meetup/registrations`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/qnwMfSqq2QjrSc8WogtE_18-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/qnwMfSqq2QjrSc8WogtE_18-2.png)

# 18-2 分页机制

回想看看为什么要做分页呢？让我们想想看：

- 数据库的资料会存在硬盘上，当我们用 Ruby 程序从数据库读出来时，就会放在内存，内存的读取速度比硬盘快非常非常多。所有正在执行的程序，都会放到内存。内存是有限的，例如大家的 Macbook 可能有 8G，但是硬盘空间很大，例如 (SSD)可能有 256G，传统(磁盘式)硬盘的话现在已经发展到 1T、2T 以上，如果把硬盘的数据都读出来放到内存上，不但放不下也很浪费。
- 用户下载所有资料需要传输时间，浏览器加载也需要时间，如果资料很多，就会花很久时间才能看到画面。

因此，如果资料量多达数万笔时，就一定要制作分页的功能，避免调用 `.all` 方法。

我们已经教过用 [will_paginate](https://github.com/mislav/will_paginate) gem 来做分页功能，这里示范用另一套也是非常热门的分页套件 [kaminari](https://github.com/kaminari/kaminari)，两者大同小异。可依照~~个人~~公司偏好选择。

编辑 `Gemfile`

Gemfile

```
+  gem 'kaminari'
```

执行 `bundle`，重启服务器。

执行 `rails g kaminari:views bootstrap3`，这会产生搭配 Bootstrap 样式的样板

编辑 `app/controllers/admin/event_registrations_controller.rb`

app/controllers/admin/event_registrations_controller.rb

```
   def index
-    @registrations = @event.registrations.includes(:ticket).order("id DESC")
+    @registrations = @event.registrations.includes(:ticket).order("id DESC").page(params[:page])
   end
```

> 要指定一页有多少笔的话，使用 `per` 方法，例如 `@event.registrations.includes(:ticket).order("id DESC").page(params[:page]).per(10)`

编辑 `app/views/admin/event_registrations/index.html.erb`，在最下方放上分页的超连结。

app/views/admin/event_registrations/index.html.erb

```
  </table>

+  <%= paginate @registrations %>
```

最后结果：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pXpNPJ3SaewzmqO44LGk_18-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pXpNPJ3SaewzmqO44LGk_18-3.png)

# 18-3 筛选资料(单选)

需求：可以点选状态或票种(单选)来筛选出报名人资料

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/sok6CT6sScmADqu0EqLe_18-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/sok6CT6sScmADqu0EqLe_18-4.png)

编辑 `app/views/admin/event_registrations/index.html.erb`，加上两组 Bootstrap 样式的按钮：

app/views/admin/event_registrations/index.html.erb

```
  <h1><%= @event.name %> / Registrations</h1>

  <p class="text-right">
  <%= link_to "New Registration", new_admin_event_registration_path(@event), :class => "btn btn-primary" %>
  </p>

+  <div class="submenu">
+    <div class="btn-group">
+      <%= link_to "全部 (#{@event.registrations.size})", admin_event_registrations_path(registration_filters(:status =>   nil)), :class => "btn btn-success btn-group #{(params[:status].blank?) ? "active" : ""}" %>
+      <% Registration::STATUS.each do |s| %>
+        <%= link_to t(s, :scope => "registration.status") + " (#{@event.registrations.by_status(s).size})",   admin_event_registrations_path(registration_filters(:status => s)), :class => "btn btn-success btn-group #{(  params[:status] == s) ? "active" : ""}" %>
+        <% end %>
+    </div>
+
+    <div class="btn-group">
+      <%= link_to "全部 (#{@event.registrations.size})", admin_event_registrations_path(registration_filters(:ticket_id =>   nil)), :class => "btn btn-default btn-group #{(params[:ticket_id].blank?) ? "active" : ""}" %>
+      <% @event.tickets.each do |t| %>
+        <%= link_to t.name + " (#{@event.registrations.by_ticket(t).size})", admin_event_registrations_path(  registration_filters(:ticket_id => t.id)), :class => "btn btn-default btn-group #{(params[:ticket_id].to_i == t.id)   ? "active" : ""}" %>
+      <% end %>
+    </div>
+  </div>
```

修改 `app/helpers/admin/event_registrations_helper.rb`，新增 `registration_filters` 方法

app/helpers/admin/event_registrations_helper.rb

```
   module Admin::EventRegistrationsHelper
+
+   def registration_filters(options)
+     params.permit(:status, :ticket_id).merge(options)
+   end
+
  end
```

这个 `registration_filters` 方法的目的，在于建构按钮超连结的参数。当点了状态再点票种，或是点了票种再点状态时，要同时套用两个参数。

修改 `app/models/registration.rb` 加上两个 scope

app/models/registration.rb

```
+  scope :by_status, ->(s){ where( :status => s ) }
+  scope :by_ticket, ->(t){ where( :ticket_id => t ) }
```

修改 `app/controllers/admin/event_registrations_controller.rb`，如果有传参数进来，则进行筛选：

app/controllers/admin/event_registrations_controller.rb

```
   def index
    @registrations = @event.registrations.includes(:ticket).order("id DESC").page(params[:page])

+   if params[:status].present? && Registration::STATUS.include?(params[:status])
+     @registrations = @registrations.by_status(params[:status])
+   end

+   if params[:ticket_id].present?
+     @registrations = @registrations.by_ticket(params[:ticket_id])
+   end
```

> scope 的作用是将常用的查询条件宣告起来，方便重复使用

修改 `app/assets/stylesheets/admin.scss`，调整一下间距。

app/assets/stylesheets/admin.scss

```
+ .submenu {
+   margin-bottom: 10px;
+ }
```

这样就完成了。

# 18-4 筛选资料(多选)

需求：可以用核选方块(多选)状态和票种，来筛选出报名人资料

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FzTn62HlT02YpVnOHp04_18-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/FzTn62HlT02YpVnOHp04_18-5.png)

> 实务上，单选和多选的作法不太会混用，所以这里会注解掉上一节的单选接口让画面清楚一点。

再次编辑 `app/views/admin/event_registrations/index.html.erb`，加上核选方块的表单，以及一个送出筛选的按钮：

app/views/admin/event_registrations/index.html.erb

```
+  <% if false %>
   <div class="submenu">
     # 略
   </div>
+  <% end %>

+ <%= form_tag admin_event_registrations_path(@event), :method => :get do %>
+
+   <p><% Registration::STATUS.each do |s| %>
+     <label><%= check_box_tag "statuses[]", s, Array(params[:statuses]).include?(s) %> <%= t(s, :scope => + "registration.status") %> (<%= @event.registrations.by_status(s).size %>)</label>
+   <% end %></p>
+
+   <p><% @event.tickets.each do |t| %>
+     <label><%= check_box_tag "ticket_ids[]", t.id, Array(params[:ticket_ids]).include?(t.id.to_s) %> <%= t.name %> (<%= + @event.registrations.where( :ticket_id => t.id ).size %>)</label>
+   <% end %></p>
+
+   <p class="text-right">
+     <%= submit_tag "送出筛选", :class => "btn btn-primary" %>
+   </p>
+ <% end %>
```

> Protip: 样板中如果有大范围暂时需要注解，可以用 `<% if false %>` .... `<% end %>` 包起来。

修改 `app/controllers/admin/event_registrations_controller.rb`，如果有传参数进来，则进行筛选：

app/controllers/admin/event_registrations_controller.rb

```
   def index
    @registrations = @event.registrations.includes(:ticket).order("id DESC").page(params[:page])

+   if Array(params[:statuses]).any?
+     @registrations = @registrations.by_status(params[:statuses])
+   end

+   if Array(params[:ticket_ids]).any?
+     @registrations = @registrations.by_ticket(params[:ticket_ids])
+   end
```

这样就完成了。

# 18-5 时间区间筛选

需求：可以输入报名日期区间来筛选出报名人资料

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bQ70K7vmQXe0SUA27c8Q_18-6.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bQ70K7vmQXe0SUA27c8Q_18-6.png)

编辑 `app/views/admin/event_registrations/index.html.erb`，加上日期输入框：

app/views/admin/event_registrations/index.html.erb

```
+  <p>
+    报名日期：<%= date_field_tag :start_on, params[:start_on] %>～<%= date_field_tag :end_on, params[:end_on] %>
+  </p>

  <p class="text-right">
    <%= submit_tag "送出筛选", :class => "btn btn-primary" %>
  </p>
```

修改 `app/controllers/admin/event_registrations_controller.rb`，如果有传参数进来，则进行筛选：

app/controllers/admin/event_registrations_controller.rb

```
   def index
    @registrations = @event.registrations.includes(:ticket).order("id DESC").page(params[:page])

+   if params[:start_on].present?
+     @registrations = @registrations.where( "created_at >= ?", Date.parse(params[:start_on]).beginning_of_day )
+   end

+   if params[:end_on].present?
+     @registrations = @registrations.where( "created_at <= ?", Date.parse(params[:end_on]).end_of_day )
+   end
```

> 输入的是日期，但是数据库中存的是 UTC 时间，因此这里需要调用 `beginning_of_day` 和 `end_of_day`才会转换成正确的时间。例如北京时区的 2017/4/30 这一天，对数据库中存 UTC 时间的字段来说，正确的区间是 2017-04-30 16:00:00 UTC 到 2017-05-01 15:59:59 UTC。

这样就完成了。

# 18-6 资料比对筛选

需求：可以输入报名编号搜寻报名人资料

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Dn4ij3ZIT9WwlQwuQCYO_18-7.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Dn4ij3ZIT9WwlQwuQCYO_18-7.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/W4EVfeFFSzuCH0fpgkIM_18-8.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/W4EVfeFFSzuCH0fpgkIM_18-8.png)

编辑 `app/views/admin/event_registrations/index.html.erb`，加上文字输入框：

app/views/admin/event_registrations/index.html.erb

```
  <%= form_tag admin_event_registrations_path(@event), :method => :get do %>
+   <p><%= text_field_tag :registration_id, params[:registration_id], :placeholder => "报名编号，可用,号区隔", :class => "form-control" %></p>
```

修改 `app/controllers/admin/event_registrations_controller.rb`，如果有传参数进来，则进行筛选：

app/controllers/admin/event_registrations_controller.rb

```
   def index
    @registrations = @event.registrations.includes(:ticket).order("id DESC").page(params[:page])

+   if params[:registration_id].present?
+     @registrations = @registrations.where( :id => params[:registration_id].split(",") )
+   end
```

这样又完成了。

# 18-7 关键字搜寻，使用 Ransack

需求：可以输入姓名或 Email，模糊搜寻报名人资料

上一节的资料比对，会要完全一模一样(exact match)才会筛选出来，如果只要符合部分关键字就好，则需要用数据库的 [LIKE 搜寻](https://www.w3schools.com/sql/sql_like.asp) 语法，这里我们使用 [ransack](https://github.com/activerecord-hackery/ransack) gem 来帮我们达成这个功能。

编辑 `Gemfile`

Gemfile

```
+ gem 'ransack'
```

执行 `bundle`，重启服务器

修改 `app/controllers/admin/event_registrations_controller.rb`，改成需要先调用 ransack 方法

app/controllers/admin/event_registrations_controller.rb

```
   def index
-    @registrations = @event.registrations.includes(:ticket).order("id DESC").page(params[:page])
+    @q = @event.registrations.ransack(params[:q])
+
+    @registrations = @q.result.includes(:ticket).order("id DESC").page(params[:page])
```

编辑 `app/views/admin/event_registrations/index.html.erb`，改成 ransack 提供的 `search_form_for`

app/views/admin/event_registrations/index.html.erb

```
-  <%= form_tag admin_event_registrations_path(@event), :method => :get do %>
+  <%= search_form_for @q, :url => admin_event_registrations_path(@event) do |f| %>
+
+    <p><%= f.search_field :name_cont, :placeholder => "姓名", :class => "form-control" %></p>
+    <p><%= f.search_field :email_cont, :placeholder => "E-mail", :class => "form-control" %></p>
```

其中 `search_field` 是 ransack 独到的方法，后面的 `:name_cont` 代表 name 这个字段要包含(contains)的关键字。详见 ransack 的文档说明，有各种用法。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9Zqzrk4MTKmihkovGTXa_18-9.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9Zqzrk4MTKmihkovGTXa_18-9.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/x3e6nY8QkuVDCKEjCBxm_18-10.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/x3e6nY8QkuVDCKEjCBxm_18-10.png)

全栈营交流论坛上也有很多小夥伴写的教程可以参考，请[搜索 ransack](https://forum.qzy.camp/search?q=ransack)。

> ransack 会用数据库的 LIKE 语法来做搜寻，虽然用起来方便，但它会逐笔检查资料是否符合，而不会使用数据库的索引。如果数据量非常多有上万笔以上，搜寻效能就会不满足我们的需要。这时候会改安装专门的全文搜寻引擎，例如 [Elasticsearch](https://www.elastic.co/)，这是大数据等级的。

#### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/54)：[作业三](https://fullstack.xinshengdaxue.com/tasks/319)

已有 25 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/319/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/319)

请在任一个项目中的后台，实作资料过滤的功能，包括单选或多选、某个时间区间、关键字搜寻等方式。

# 18-8 前台的活动状态筛选

需求：活动的状态有分公开(public)、私密(private)和草稿(draft)：前台的活动列表页应该只显示 public 的活动、前台的活动页面不能显示状态是 draft 的活动

> 私密(private)状态的意思是，在活动列表上看不到，但是如果直接分享网址的话，透过连结还是可以打开。像我们默认的活动网址是随机的 uuid，如果不是自己分享的话，是不可能猜到的。

编辑 `app/models/event.rb`，加上两个 scope

app/models/event.rb

```
+  scope :only_public, -> { where( :status => "public" ) }
+  scope :only_available, -> { where( :status => ["public", "private"] ) }
```

编辑 `app/controllers/events_controller.rb`，分别套用这两个 scope

app/controllers/events_controller.rb

```
 class EventsController < ApplicationController

   def index
-    @events = Event.rank(:row_order).all
+    @events = Event.only_public.rank(:row_order).all
   end

   def show
-    @event = Event.find_by_friendly_id!(params[:id])
+    @event = Event.only_available.find_by_friendly_id!(params[:id])   # 如果活动是 draft 的话，经过 only_available scope 就会找不到，这就是我们的目的
   end

 end
```

回到前台浏览看看活动列表，只剩下有公开的活动了。

# 19-1 需求说明

在实际运作的网站中，用户可能会不小心删除资料，或是修改时不小心改错等等。这时候用户可能会透过客服希望管理员能进行复原的动作。另一方面，针对重要的资料，我们也希望建立追踪和稽核的机制。

这种需求叫做软删除(Soft Deletion)和版本控管(Versions)。

软删除(Soft Deletion)的意思是不要真的删除这一笔资料，常见的作法是增加一个删除的标记字段(例如 `deleted_at`字段)，如果被标记删除了，那就不要显示出来即可，使用 [Paranoia](http://www.rubydoc.info/gems/paranoia) 这个 gem 可以完成这个功能。

至于版本控管的作法，则会另外建立一个 Version Model 来存储编修纪录。如果本来的资料被删除或修改，则会复制资料到这个 Model 去。等会我们示范用 [paper_trail](https://github.com/airblade/paper_trail) gem。如果用了 paper_trail 来做版本控管，也就不需要用 paranoia 了。因为前者也可以做删除的复原。

> 不建议用 paranoia 的方式，这种方式有一个严重的数据库问题，会干扰 unique index。例如 User 的 email 是唯一的，如果不真的删除这一笔资料，只是标记被删除的话，那么被删除的用户资料，该 email 依然无法注册。因为数据库认为 email 重复了。

# 19-2 安装使用 paper_trail

编辑 `Gemfile`

Gemfile

```
+  gem 'paper_trail'
```

执行 `bundle`，重启服务器

执行 `bundle exec rails generate paper_trail:install --with-changes`

执行 `bundle exec rake db:migrate`

编辑 `app/models/registration.rb`

app/models/registration.rb

```
  class Registration < ApplicationRecord

+   has_paper_trail
```

这样就完成了，所有的修改和删除，都会纪录在 paper_trail 的 Version model 里面。

在 [paper_trail](https://github.com/airblade/paper_trail) 文档上，有完整的版本浏览、比较和复原的作法。

# 19-3 编修纪录的 UI 和复原

我们可以在后台新增一个 UI 来浏览最近的编修纪录：

编辑 `config/routes.rb`

config/routes.rb

```
  namespace :admin do
    root "events#index"

+   resources :versions do
+     post :undo
+   end
```

执行 `rails g controller admin::versions`

编辑 `app/controllers/admin/versions_controller.rb`

app/controllers/admin/versions_controller.rb

```
-  class Admin::VersionsController < ApplicationController
+  class Admin::VersionsController < AdminController

+    def index
+      @versions = PaperTrail::Version.order("id DESC").page(params[:page])
+    end

+    def undo
+      @version = PaperTrail::Version.find(params[:version_id])
+      @version.reify.save!
+
+      redirect_to admin_versions_path
+    end

   end
```

新增 `app/views/admin/versions/index.html.erb`

app/views/admin/versions/index.html.erb

```
<h2>编修纪录</h2>

<table class="table">
<tr>
  <td>ID</td>
  <td>Model</td>
  <td>Model ID</td>
  <td>事件</td>
  <td></td>
  <td>操作者</td>
  <td></td>
</tr>
<% @versions.each do |version| %>
  <tr>
    <td><%= version.id %></td>
    <td><%= version.item_type %></td>
    <td><%= version.item_id %></td>
    <td><%= version.event %></td>
    <td>
      <ul>
      <% version.changeset.each do |key, value| %>
        <li>从 <%= value[0] %> 改成 <%= value[1] %></li>
      <% end %>
      </ul>
    </td>
    <td><%= version.whodunnit && User.find(version.whodunnit).display_name %></td>
    <td>
      <% if version.event != 'create' %>
      <%= link_to "Undo", admin_version_undo_path(version), :data => { :confirm => "Are you sure?"}, :method => :post, class: "btn btn-danger" %>
      <% end %>
    </td>
  </tr>
<% end %>
</table>

<%= paginate @versions %>
```

浏览 `http://localhost:3000/admin/versions`

你可以试着删除或编辑报名资料看看，可以看到编修纪录，并进行复原(Undo)。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/L5cCTA8cSgSfev1RgE2L_19.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/L5cCTA8cSgSfev1RgE2L_19.png)

# 20-1 汇出 CSV 档案

需求：后台可以汇出报名资料

有时候后台功能做再多，也不如 Microsoft Excel 或 Apple Numbers 试算表软件提供的分析功能，这时候如果有汇出功能，就可以很方便地把资料汇出来，用软件来打开浏览。

[CSV 逗号分隔值](https://zh.wikipedia.org/wiki/%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC)是一种简单的资料格式，基本上就是单纯的文字档，一行一笔资料，不同字段用逗号隔开。这一节先来做这种。

编辑 `app/views/admin/event_registrations/index.html.erb`，在最下方加上汇出按钮，指定 format 格式是 csv

app/views/admin/event_registrations/index.html.erb

```
   <%= paginate @registrations %>

+  <p>
+    <%= link_to "汇出 CSV", admin_event_registrations_path(:format => :csv), :class => "btn btn-default" %>
+  </p>
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/TIrYWOETQ52poAPxUF3p_20-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/TIrYWOETQ52poAPxUF3p_20-1.png)

编辑 `app/controllers/admin/event_registrations_controller.rb`，利用 `respond_to` 针对不同格式的请求，回应不同的输出：

app/controllers/admin/event_registrations_controller.rb

```
+  require 'csv'
   class Admin::EventRegistrationsController < AdminController

     before_action :find_event

     def index
       # (略)

+      respond_to do |format|
+        format.html
+        format.csv {
+          @registrations = @registrations.reorder("id ASC")
+          csv_string = CSV.generate do |csv|
+            csv << ["报名ID", "票种", "姓名", "状态", "Email", "报名时间"]
+            @registrations.each do |r|
+              csv << [r.id, r.ticket.name, r.name, t(r.status, :scope => "registration.status"), r.email, r.created_at]
+            end
+          end
+          send_data csv_string, :filename => "#{@event.friendly_id}-registrations-#{Time.now.to_s(:number)}.csv"
+        }
+      end
     end
```

[CSV](https://ruby-doc.org/stdlib-2.3.0/libdoc/csv/rdoc/CSV.html) 是 Ruby 内建的库，这里第一行需要先 `require` 它。使用 `CSV.generate` 可以产生出 `csv_string`字符串，也就是要输出的 CSV 资料，接着透过 `send_data` 传给浏览器进行档案下载。

用 Apple Number 试算表软件打开：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/8SSJdTDSQPCLV4CP6d29_20-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/8SSJdTDSQPCLV4CP6d29_20-2.png)

但是 CSV 有个缺点，就是用 Microsoft Excel 打开时默认会变成乱码。这是因为汇出的 CSV 的字串编码是 [UTF-8](https://zh.wikipedia.org/zh-tw/UTF-8)，但是 Excel 默认会用本地编码，例如中国大陆地区用 [GB 2312](https://zh.wikipedia.org/wiki/GB_2312)，台湾地区用 [Big5](https://zh.wikipedia.org/wiki/%E5%A4%A7%E4%BA%94%E7%A2%BC)。解决办法有二：

方法一: 以记事本开启后储存，再以 Excel 开启即可正常显示。

方法二: 开启 Excel 软件，新增空白活页簿(Workbook)，然后在上方功能选项中点选「资料(Data)」->「取得外部资料 Get External Data」->「从文字档 From Text File...」→「选择汇出的 CSV 档案」→ 选择符号分隔(Delimited)、选择 File origin 编码是 Unicode (UTF-8) → 选择分隔符号是 Comma 逗点，即可正常显示。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YrhK8j7kTh2DVxBmjk5Y_20-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YrhK8j7kTh2DVxBmjk5Y_20-3.png)

# 20-2 汇出 Excel 档案

如果上述 Excel 打开 CSV 档案的解法没办法接受的话，那只好想办法汇出 Excel 专用的 xlsx 格式了。这需要额外装 gem，这里示范使用 [axlsx_rails](https://github.com/straydogstudio/axlsx_rails) gem。

编辑 `Gemfile`

Gemfile

```
+  gem 'rubyzip'
+  gem 'axlsx'
+  gem 'axlsx_rails'
```

执行 `bundle`，重启服务器

编辑 `app/views/admin/event_registrations/index.html.erb`，加上汇出的按钮，指定 format 格式是 xlsx

app/views/admin/event_registrations/index.html.erb

```
  <%= paginate @registrations %>

  <p>
    <%= link_to "汇出 CSV", admin_event_registrations_path(:format => :csv), :class => "btn btn-default" %>
+   <%= link_to "汇出 Excel", admin_event_registrations_path(:format => :xlsx), :class => "btn btn-default" %>
  </p>
```

编辑 `app/controllers/admin/event_registrations_controller.rb`，新增 xlsx 格式

app/controllers/admin/event_registrations_controller.rb

```
respond_to do |format|
  format.html
  format.csv {
   # 略
  }
+     format.xlsx
end
  end
```

新增 `app/views/admin/event_registrations/index.xlsx.axlsx` 样板：

app/views/admin/event_registrations/index.xlsx.axlsx

```
wb = xlsx_package.workbook
wb.add_worksheet(name: "Buttons") do |sheet|
  sheet.add_row ["报名ID", "票种", "姓名", "状态", "Email", "报名时间"]
  @registrations.each do |r|
    sheet.add_row [r.id, r.ticket.name, r.name, t(r.status, :scope => "registration.status"), r.email, r.created_at]
  end
end
```

这样就可以汇出 Excel 格式的档案了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/QllzQDiATQ26prDvZLAp_20-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/QllzQDiATQ26prDvZLAp_20-4.png)
