---
layout: post
title: "编程语言第三集"
date: 2017-10-30
tags:
    Rails
    教材
---
| 异常处理 Exception                           |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  21. 什么是异常处理 Exception](https://fullstack.xinshengdaxue.com/posts/1455) |                                          |
| [**  22. 什么是 callstack 和 backtrace](https://fullstack.xinshengdaxue.com/posts/1456) |                                          |
| [**  23. 异常处理策略](https://fullstack.xinshengdaxue.com/posts/1457) |                                          |
| [**  24. 关于 Rails 的异常处理](https://fullstack.xinshengdaxue.com/posts/1458) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1458#task) |

| 元编程 Meta-Programming                     |      |
| ---------------------------------------- | ---- |
| [**  25. 元编程: define_method](https://fullstack.xinshengdaxue.com/posts/1459) |      |
| [**  26. 元编程: method_missing](https://fullstack.xinshengdaxue.com/posts/1460) |      |
| [**  27. 元编程: Monkey Patch](https://fullstack.xinshengdaxue.com/posts/1461) |      |

| 编码风格                                     |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  28. 编码风格 Coding Style](https://fullstack.xinshengdaxue.com/posts/1462) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1462#task) |

# 21. 什么是异常处理 Exception

异常处理 (Exception Handling) 是高阶编程语言的一种用于处理异常状况的流程机制，在 Ruby、JavaScript、Python、Java、Swift 等语言中都有这个功能。

哪些算是异常状况呢？是指不在程序运行中预期会发生的事情，例如语法错误、发送 HTTP API 时网络不通、写入档案时硬盘已满、数字除以零等等。

当发生异常时，程序会中断跳开，跳到处理异常的代码。如果没有处理这段异常的代码，整个程序就会终止(也就是软件crash、app 闪退、网站看到500错误画面)

在开发 Rails 时，每次你看到的红色错误画面，就是发生了一个异常错误(Exception)。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/f5fhohrHRmeUopMZzlr6_1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/f5fhohrHRmeUopMZzlr6_1.png)

### Ruby 语法说明: raise

让我们实际看看异常处理的语法：

```
puts "Start"
raise "Errorrrr"
puts "Never execute"
```

这段代码中，用 `raise` 会丢出一个异常(Exception)，执行的结果是：

```
Start
Called
exception.rb:4:in `<main>': Errorrrr (RuntimeError)
```

注意到第三行的 `puts "Never execute"` 是没有被执行的，执行到 `raise` 时程序就终止了。

> `raise 'An error has occured.'` 等同于 `raise RuntimeError.new('An error has occured.')`，`RuntimeError` 是一个 Ruby 内建的默认异常对象，用来储存关于这个异常的信息。Rails 还有内建其他不同的异常对象，详见 [Ruby API](https://ruby-doc.org/core-2.2.0/Exception.html)。

为什么你好像很少用到 `raise` 这个功能呢？这是因为丢出 `raise` 的大多是 Ruby 本身或是我们使用的库和框架之中，例如：

- 当你对一个对象调用一个不存在的方法时，Ruby 会丢出 `NoMethodError` 异常
- 在 Rails 中当URL找不到任何路由规则可以符合时，会丢出 `Routing Error` 异常

### Ruby 语法说明: rescue

接下来让我们加上处理异常的代码：

```
puts "Start"

begin
  puts "Called"
  raise "Errorrrr"
  puts "Never execute"
rescue => e
  puts 'I am rescued.'
  puts e.message
end

puts "Done"
```

从 `begin` 到 `end` 包住整个可能会丢出异常的代码，然后用 `rescue => e` 可以捕捉到异常。执行的结果是：

```
Start
Called
I am rescued.
Errorrrr
Done
```

`puts "Never execute"` 这一行依然不会执行到，程式从 `raise` 后就跳去 `resue` 的部分，然后再继续往后正常执行。

在 `rescue` 我们会写如何去处理(拯救)异常，而 `rescue => e` 的 `e` 是个异常对象，会储存关于这个异常的信息。

常见的 `rescue` 可能是显示错误讯息，告诉用户这个操作失败了，然后程序回复正常继续执行。

### Ruby 语法: ensure

`ensure` 部分则是不管有没有发生异常，都一定会执行到。例如：

```
begin
    # do something
    raise 'An error has occured.'
rescue => e
    puts 'I am rescued.'
ensure
    puts 'This code gets executed always.'
end
```

执行结果

```
I am rescued.
This code gets executed always.
```

### Ruby 语法: 顶层异常捕获

上述的 `begin...rescue` 语法，如果放在 `def` 方法定义中，则可以用以下的简略写法：

```
def 某个方法名称
  # do something

  raise 'An error has occured.'
rescue => e
  puts 'I am rescued.'
ensure
  puts 'This code gets executed always.'
end
```

也就是可以省略掉原本异常处理的 `begin` 跟结尾的 `end`。

# 22. 什么是 callstack 和 backtrace

在一个复杂的软件中，方法内会调用其他方法，然后方法又在调用其他方法，例如以下范例，c 方法调用 b 方法、b 方法内又调用 a 方法：

```
def a
  puts "a"
  raise "A error"
end

def b
  puts "b"
  a()
end

def c
  puts "c"
  b()
end

begin
  c()
rescue => e
  puts e.message
  puts e.backtrace
ensure
  puts "finally"
end
```

这种一层一层的关系，又叫做 `callstack`。

其中 a 方法中丢出了异常，但是在 a 方法内并没有 rescue，这个异常会一层一层往外抛出，直到某一层有 rescue 有本事捕捉这个例外。如果一直到到最外层都没人能处理异常，那么程序才会中断。

在上述的 `rescue` 中，我们用 `e.backtrace` 可以列出调用的 `callstack` 关系，`backtrace` 的意思就是回朔当初的调用关系。

在 Rails 中如果发生异常，根据 development 模式或 production 模式，最外层有不同的异常处理策略：在开发时最外层的 `rescue` 会显示错误的 backtrace，这样可以帮助我们了解发生错误的来龙去脉：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9Bgdkhk0QKa8tLVSNlhA_2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9Bgdkhk0QKa8tLVSNlhA_2.png)

这里区分了 Application Trace、Framework Trace 和 Full Trace。默认显示 Application Trace 也就是我们写的代码 backtrace，而 Framework Trace 则是发生在 Rails 框架内的 backtrace。

如果是 production 模式，默认的最外层 `rescue` 其实是显示 500 错误画面(也就是 public/500.html)。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/4J89ANRWQ3qa5Qp24vqT_3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/4J89ANRWQ3qa5Qp24vqT_3.png)

# 23. 异常处理策略

现在你了解异常处理的语法了，我们回过头来思考一下，当程序发生错误时会如何处理? 程序发生错误其实是蛮常见的事情，但是并不是每种错误都会用异常处理功能来解决。

### 回传错误码 vs. 抛出异常

事实上有两种处理方式：第一种是回传某个代表错误的值(例如 nil, true/false 或错误数字码)，第二种才是抛出异常 Exception。

例如从 Hash 或 Array 中取出一个值，如果该 key 不存在，其实也可以算是一种异常：

```
h = { :foo => "123" }

h[:bar] # 回传 nil


h.fetch(:bar) # 丢出 KeyError 异常
```

其中 `:bar` 是一个不存在的 key，而 `h[:bar]` 默认回传 `nil` 代表了此值不存在。但 Ruby 也提供另一个 Hash#fetch 用法，如果该 key 不存在，会丢出错误异常 `KeyError`。同一件事情，Ruby 提供了两种 API 方法，但有不同的异常处理策略。

在看 Ruby API 或是 gem 的 API 文档时，你可以注意一下它们是如何处理异常情况的。例如在 [rest-client](https://github.com/rest-client/rest-client)gem 中(在 Web API 教程中，我们用这个 gem 来抓取第三方的信息)，如果抓取失败，就会抛出[RestClient::ExceptionWithResponse 异常](https://github.com/rest-client/rest-client#exceptions-see-httpwwww3orgprotocolsrfc2616rfc2616-sec10html)。

### 何时用抛出异常？

什么时候会用错误码？什么时候会用抛出异常的方式呢？这得取决于这个错误是否在预期之内。抛出异常的意思像是: 这个异常这里不知道怎么处理，只好把烫手山芋抛出去，看哪一层有办法处理。如果最后都没有人可以处理，那程序只好 crash 了!

以 Rails 来说，存储的 API 有两种，一个是 `save` 一个是 `save!`。差别是当 validation 验证失败时的处理方式不同。以下是大家比较熟悉的版本：

```
def create
  @user = User.new params[:user]
  if @user.save
    redirect_to user_path(@user)
  else
    flash[:notice] = 'Unable to create user'
    render :action => :new
  end
end
```

这是改用异常处理的版本：

```
def create
  @user = User.new params[:user]
  @user.save!
  redirect_to user_path(@user)
rescue ActiveRecord::RecordNotSaved
  flash[:notice] = 'Unable to create user'
  render :action => :new
end
```

在这两个版本中，前者还是比较好的。这是因为用户输入不正确其实是很常见的事情，处理用户输入失败，重新显示表单也算是正常流程处理的一部分，所以用 `if ... else ...` 的写法还比较清楚。改用异常处理的版本，代码并不会比较清楚。

异常处理的初衷，是希望处理异常的代码不要干扰正常代码的可读性，会发生异常的可能性很低，因此将处理异常的代码放到最后面去。

甚至，不处理异常也是很常见的事情，例如在百宝箱「自订列表顺序」中，其中有个 `reorder` action 是这样的：

```
 def reorder
    @event = Event.find_by_friendly_id!(params[:id])
    @event.row_order_position = params[:position]
    @event.save!
  end
```

在这个动作中，用了 `save!` 而不是 `save`。这是因为我们没有预期会发生 validation 失败，我们也没有打算要写 validation 失败了要怎么处理。在这种情况下，我们就会改用 `save!` 而不是 `save`。这样如果真的万一出事了，程序就会中断，用户会看到 500 错误画面，这个错误会被记录在 log 之中让我们程序员去检查这个错误。如果你用 `save` 的话，如果失败只会回传 `false` 然后就继续执行下去，用户只会觉得很奇怪为什么没有存成功，但是却没有任何错误记录。

# 24. 关于 Rails 的异常处理

在一节我们来回顾一下 Rails 是如何做异常处理的?

### find

ActiveRecord 的 `find` API 如果找不到数据，会丢 `ActiveRecord::RecordNotFound` 的例外。在 show action 我们经常用这个 API，因为如果真的找不到，程序就会中断。

```
 def show
    @event = Event.find(params[:id])
  end
```

> 在 development 开发模式中，你会看到 ActiveRecord::RecordNotFound 异常。在 production 上线模式，会显示 404 页面(public/404.html)

Rails 还有提供 `find_by_字段名称` 和 `find_by_字段名称!` API，前者如果找不到数据，会回传 `nil`，后者则是抛出异常。

在百宝箱第一集的「自定义 Model 网址」中，我们新增了一个 `friendly_id` 字段，然后 show action 改成：

```
  def show
    @event = Event.find_by_friendly_id!(params[:id])
  end
```

当找不到数据时，就会抛出 `ActiveRecord::RecordNotFound` 异常程序中断。

为什么这里偏好用抛出异常的策略呢？如果我们改用 `Event.find_by_friendly_id(params[:id])` 的话，找不到数据时会回传 `nil`，那么 @event 变成 `nil` 程序继续执行，一直进到 `show.html.erb` 里面的某一行去显示 `@event.name`，然后就会碰到 `nil.name` 抛出异常是 `NoMethodError` 最后程序中断。这时候要找到真正异常的原因就会多花一点时间。

我们希望在异常发生的第一时间就中断程序(fail fast)，而不是让程序无声地继续执行下去，最后像一个未爆弹一样最后莫名其妙地炸掉。

### save 和 save!

这刚刚有提过，存储有分 save 和 save!，更新有分 udpate 和 udpate!。

- 有搭配 `if ... else` 情况做处理用 save。这表示你会处理储存失败流程
- 没有的话，用 save! 惊叹号版本。这表示你认为 99% 应该会存成功，懒得处理存不成功。如果出错会异常抛出

### rescue_from

[rescue_from](http://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html)
可以在 controller 中宣告 `rescue_from` 去救回特定的异常对象。例如：

```
class ApplicationController < ActionController::Base
  rescue_from User::NotAuthorized, with: :deny_access # self defined exception
  rescue_from ActiveRecord::RecordInvalid, with: :show_errors

  rescue_from 'MyAppError::Base' do |exception|
    render xml: exception, status: 500
  end

  private
    def deny_access
      ...
    end

    def show_errors(exception)
      exception.record.new_record? ? ...
    end
end
```

这功能不太常用。你会发生其实我们不太常去处理 `rescue` 的情况，这是因为我们对于消费级软件的鲁棒性//抗变换性(Robust)的要求没这么高。如果异常发生了，只要能提示用户并记录下来就不错了。在一些高鲁棒性/抗变换性(Robust)要求的软件中，例如医疗、金融企业等级软件，则会进行重试(retry)或是切换备用系统。

### 安装异常通知

在 production 上线环境中，如果用户操作碰到异常会看到 500 错误画面，并且在 log 中会纪录下来。我们希望能有一些机制能够主动通知我们程序员，好让我可以 trace error、fixed bug 甚至在发生错误没多久就可以通知苦主发生了什么事情。

最基本我们可以安装 [Exception Notifier](https://github.com/smartinez87/exception_notification)，这个套件会在发生例外时寄 email 通知。或是使用第三方服务，例如：

- [Rollbar](https://rollbar.com/) 推荐这套，有免费额度一个月记录 5000 个异常
- [Airbrake](https://airbrake.io/)

这些第三方服务可以在网站发生异常错误的时候自动将错误讯息收集起来，并且提供了还蛮不错的后台可以浏览，还可以统计及追踪异常处理的情况。免费的方案对于小网站就很够用，非常推荐使用。

### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/70)：[作业一](https://fullstack.xinshengdaxue.com/tasks/359)

已有 9 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/359/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/359)

以下是一些常见的 Rails/Ruby 异常，请简单说明什么情况下会抛出这些异常?

- SyntaxError
- NoMethodError
- NameError
- ActiveRecord::RecordNotFound
- ActiveRecord::ForbiddenAttributesError
- ActiveRecord::RecordInvalid
- ActionController::Routing Error
- ActionController::UrlGenerationError
- AbstractController::DoubleRenderError

# 25. 元编程: define_method

元编程(Meta-programming)的意思是让程序帮我们写程序，这听起来非常神奇，但这就是 Rails 很多 API 用法之所以这么 magic 背后的秘密武器。撰写元编程的能力是库和框架作者的必备技巧。

这一章我们将简单介绍一些元编程的技巧，目的是让各位学员能够稍微理解 Rails 背后的原理。如果想要进一步了解如何使用元编程技巧，推荐[Ruby元编程](https://book.douban.com/subject/26575429/)一书。

### 动态定义方法 define_method

`define_method` 是个 Ruby 的类方法，可以动态定义对象方法，例如：

```
class Dragon
  define_method(:foo) { puts "bar" }

  ['a','b','c','d','e','f'].each do |x|
    define_method(x) { puts x }
  end
end

dragon = Dragon.new
dragon.foo # 输出 "bar"
dragon.a # 输出 "a"
dragon.f # 输出 "f"
```

其中 `define_method(:foo) { puts "bar" }` 等同于

```
def foo
  puts "bar"
end
```

也许你会好奇 `define_method` 跟 `def` 同样都可以定义方法，差别在哪里呢? 差别在 `define_method` 用匿名函式来定义方法，所以有 Closure(闭包) 特性。我们需要这个特性，才可以有弹性地根据参数去自定义出不同的方法实作。例如：

```
class A
  def self.define_my_method(x)
    define_method("output_#{x}") do
      puts "This is #{x}"
    end
  end
end

class B < A
  define_my_method :foo # 定义 output_foo 方法
end

class C < A
  define_my_method :bar # 定义 output_bar 方法
end

B.new.output_foo # 输出 This is foo
C.new.output_bar # 输出 This is bar
```

如果你能理解上述的代码，那么你就能理解在 Rails 很多这样的宣告背后，都是用 `define_method` 做出来的：

```
class Firm < ActiveRecord::Base
  has_many   :clients
  has_one    :account
  belongs_to :user
end

# has_many 是 AciveRecord 的类方法(class method)

# 其内容是动态定义出 Firm 的一堆对象方法(instance methods)


firm = Firm.find(1)
firm.clients
firm.account
firm.build_account
firm.user
```

其中 `clients`、`account`、`build_account`、`user` 等方法，都是透过 `has_many :clients`、`has_one :account`、`belongs_to :user` 所定义出来的。

# 26. 元编程: method_missing

Ruby 在调用方法找不到时，会改调用这个 `method_missing` 这个方法。例如以下的代码中，任何 `go_to_XXXX` 的方法调用，都可以输出 `go to XXXX` 字符串。

```
car = Car.new

car.go_to_taipei
# go to taipei


car.go_to_shanghai
# go to shanghai


car.go_to_japan
# go to japan
```

但是我们不可能定义出所有的 `go_to_XXX` 方法啊，这背后的秘诀就是 `method_missing` 方法：

```
class Car
  def go(place)
    puts "go to #{place}"
  end

  def method_missing(name, *args)
    if name.to_s =~ /^go_to_(.*)/
      go($1)
    else
      super
    end
  end
end

car = Car.new

car.go_to_taipei
# go to taipei


car.blah # NoMethodError: undefined method `blah`
```

> `super` 当你在类别中复写一个方法时，透过 `super` 可以调用到上一层被你复写的方法。

当调用 `go_to_XXXX` 时，因为我们并没有特别定义这个方法，所以就会改成调用 `method_missing` 方法，在这个方法中我们再检查是不是 `go_to_` 开头，如果是的话就调用 `go` 方法，不然就改调用 `super` 回到原本的行为，也就是抛出 NoMethodError 异常。

如果你能理解这个方法，那个在 Rails 中就有几个功能是这样做出来的：

例如 ActiveRecord 的 `find_by_XXX("YYY")` 功能，会变成 `where( :XXX => "YYY" ).first`

又例如在 Web API 教程中，用到 Jbuilder 样板来输出 JSON：

app/views/api/v1/trains/show.json.jbuilder

```
json.number @train.number
json.available_seats @train.available_seats
json.created_at @train.created_at
```

其中的 `number`、`available_seats` 和 `created_at` 方法其实都进到 `method_missing` 了。

# 27. 元编程: Monkey Patch

[猴子补丁](https://zh.wikipedia.org/wiki/%E7%8C%B4%E8%A1%A5%E4%B8%81)的意思是直接复写 Class 的定义去修改行为，在 Rails 中常用这招来扩增原本 Ruby 的行为，例如：

#### try 方法

```
person = Person.find_by_email(params[:email]) # 如果找不到，会回传 nil


@person.try(:name) # 如果 @person 是 nil，透过 try 会输出 nil


@person.name # 如果 @person 是 nil，这样会抛出异常 NoMethodError
```

try 这个方法的原理是什么呢？看一下 Rails 的原代码就知道了：

```
class NilClass
  def try(*args)
    nil
  end
end
```

#### blank? 方法

`blank?` 方法是 Rails 提供的一个方法，检查对象是否是 `nil` 或空字符串：

```
[1,2,3].blank? # false
"blah".blank? # false
"".blank? # true

class Demo
  def return_nil
  end
end

Demo.new.blank? # false
Demo.new.return_nil.blank? # true
```

blank? 这个方法的原理是什么呢？看一下 Rails 的原代码就知道了：

```
class Object    # 在 Ruby 中所有的类都会继承自 Object 这个类

  def blank?
    respond_to?(:empty?) ? empty? : !self
  end

  def present?
    !blank?
  end

end

class NilClass
  def blank?
    true
  end
end

class FalseClass
  def blank?
    true
  end
end

class TrueClass
  def blank?
    false
  end
end
```

# 28. 编码风格 Coding Style

同样一件事情，可以有很多种不同的写法，要用哪一种好呢? 很多时候对电脑来说并没有什么差别，因为作用和效能是一模一样的，差别只是编码风格而已。

编码风格对于团队开发十分重要，维持一惯的风格可以增加代码的可读性。在 Ruby 和 Rails 社区中，大多会遵守以下的风格指南：

- [Ruby 风格指南](https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md)
- [Rails 风格指南](https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md)
- [Udacity Frontend Nanodegree Style Guide](http://udacity.github.io/frontend-nanodegree-styleguide/index.html)
- [A guide for programming in style](https://github.com/thoughtbot/guides/tree/master/style)

对个人来说，编码风格也代表了你的代码有没有在编程语言社区「接地气」，更是代码给人的第一印象。一个缩进不佳的代码，给人的第一印象就是「不专业」。

> 要找工作的同学，面试官在看你的 Portfolio 作品集的代码时，第一印象就是你的代码风格好不好

### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/70)：[作业二](https://fullstack.xinshengdaxue.com/tasks/360)

已有 7 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/360/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/360)

请阅读 [Ruby 风格指南](https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md) 和 [Rails 风格指南](https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md)，请分享几个影响你转码风格的技巧。
