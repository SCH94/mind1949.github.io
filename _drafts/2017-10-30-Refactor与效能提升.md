---
layout: post
title: "Refactor&效能提升"
date: 2017-10-30
tags:
    Rails
    教材
---
# Refactor&效能提升



| 1-概览 预计学习时间: 1小时以内                       |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  1-1 效能提升](https://fullstack.xinshengdaxue.com/posts/452) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/452#task) |
| [**  1-2 效能提升基础概念](https://fullstack.xinshengdaxue.com/posts/454) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/454#task) |

| 2-前端效能提升 预计学习时间: 2小时以内                   |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  2-1 前端提速套路概览](https://fullstack.xinshengdaxue.com/posts/455) |                                          |
| [**  2-2 将 CSS 放在最顶层，将 JavaScript 放在最底层](https://fullstack.xinshengdaxue.com/posts/456) |                                          |
| [**  2-3 Minimize HTTP Requests](https://fullstack.xinshengdaxue.com/posts/457) |                                          |
| [**  2-4 Use a Content Delivery Network](https://fullstack.xinshengdaxue.com/posts/458) |                                          |
| [**  2-5 Split component cross domain](https://fullstack.xinshengdaxue.com/posts/459) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/459#task) |

| 3-后端效能提升 预计学习时间: 2小时以内                   |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  3-1 后端提速套路概览](https://fullstack.xinshengdaxue.com/posts/460) |                                          |
| [**  3-2 消滅 N+1 Query](https://fullstack.xinshengdaxue.com/posts/462) |                                          |
| [**  3-3 消灭 Table Scan](https://fullstack.xinshengdaxue.com/posts/463) |                                          |
| [**  3-4 使用高效 index](https://fullstack.xinshengdaxue.com/posts/464) |                                          |
| [**  3-5 使用 counter cache](https://fullstack.xinshengdaxue.com/posts/465) |                                          |
| [**  3-6 用工具自动侦测 N+1 Query, Table Scan, ...](https://fullstack.xinshengdaxue.com/posts/480) | 共2个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/480#task) |

| 4-重构 Part 1 预计学习时间: 2小时以内                |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  4-1 重构套路概览](https://fullstack.xinshengdaxue.com/posts/467) |                                          |
| [**  4-2 Controller 重构套路：before_action](https://fullstack.xinshengdaxue.com/posts/468) |                                          |
| [**  4-3 Controller 重构套路：继承](https://fullstack.xinshengdaxue.com/posts/469) |                                          |
| [**  4-4 Model 重构套路：mixin 与 ActiveSuppor...](https://fullstack.xinshengdaxue.com/posts/470) |                                          |
| [**  4-5 解说：Instance method / Class method](https://fullstack.xinshengdaxue.com/posts/472) |                                          |
| [**  4-6 解说：Instance variable / Class va...](https://fullstack.xinshengdaxue.com/posts/473) |                                          |
| [**  4-7 解说：Mixin / Extend / Inheritance](https://fullstack.xinshengdaxue.com/posts/471) |                                          |
| [**  4-8 小结技巧](https://fullstack.xinshengdaxue.com/posts/474) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/474#task) |

| 5-重构 Part 2 预计学习时间: 2小时以内                |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  5-1 Helper 收纳篇 - 1. 预先封装](https://fullstack.xinshengdaxue.com/posts/475) |                                          |
| [**  5-2 Helper 收纳篇 - 2. 使用 Ruby Helper ...](https://fullstack.xinshengdaxue.com/posts/476) |                                          |
| [**  5-3 小结：如何发觉自己需要 Helper](https://fullstack.xinshengdaxue.com/posts/477) |                                          |
| [**  5-4 但是你千万不能用 Helper 到走火入魔](https://fullstack.xinshengdaxue.com/posts/478) |                                          |
| [**  5-5 使用 Partial 的原则](https://fullstack.xinshengdaxue.com/posts/479) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/479#task) |

| 6-动手实作 预计学习时间: 1小时以内                     |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  6-1 使用code climate](https://fullstack.xinshengdaxue.com/posts/804) | 共2个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/804#task) |

# 1-1 效能提升

这一章我们将涵盖两个主题

- 网站效能调整 - 前端篇
- 网站效能调整 - 后端篇

### 本节作业

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[本周日记&周记](https://fullstack.xinshengdaxue.com/tasks/123)

已有 50 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/123/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/123)

本周日记&周记
1.请使用[ORID格式](https://fullstack.xinshengdaxue.com/tasks/7)记录每天的学习日记
2.请根据你本周的学习情况写一篇总结周记，内容提到以下两点：
2.1 “本周学到的最棒概念/工具”
2.2 “本周遇到最大的坑”
然后把日记和周记的博客连接贴在这里，格式如下：
（注意：你的logdown连结应该会是这样 <http://yy4ever.logdown.com/posts/1143304> 而不会有edit的链接）

2/20 日记：（你的博客链接）
2/21 日记：（你的博客链接）
2/22 日记：（你的博客链接）
2/23 日记：（你的博客链接）
2/24 周记：（你的博客链接）

# 1-2 效能提升基础概念

说到网站效能提升，一个网站大概分成几个结构

- 网站放置主机的地方（美国，日本，北京，等等等等）
- 前端代码结构（ CSS / JavaScript）
- 后端代码结构
  - Ruby Code 效能
  - 数据库的效能

你会先调整哪里呢？

### 膝盖反射迷思：先调整后端代码或机器摆放位置

很多同学听到这一题，通常会不加思索的回答出这两种答案，要不就是

- 搬主机
- 要不就是重构 Ruby 代码

还有很多程序员同学整天在网上跟人争论这个问题「Ruby 是不是性能不好，不适合拿来做网站？」上完这个课程，你会发现这样的争论事实上是没有道理的。

### 程序员性价比问题

要回答优先从何处提速这个问题，我的意见其实是得从程序员的「注意力」可以换取最高的网站提升效率速度来考虑优先级，「一天能够提升的有感速度」。

以下我们会先分析「开启一个网站」需要经过多少手续，速度，与资源。开始谈论这个问题。

### 机器地理位置的确很重要

首先，地理位置是一定会对开启速度造成差异的。

各位可以用 `ping` 这个指令去侦测你想要测试的网站，这个网站会告诉你现在的电脑距离服务器有多远。上面显示的毫秒值就是`完成一次封包请求需要的时间`。

比如说

- ping baidu.cn
- ping airbnb.com

大致上了解机器的实体地理位置，回传的速度真的是有很大差异的。

那这件事又对我们今天说的提速优先权有什么关系呢？

下图是

- 「日本用户」与「美国用户」连到中国大陆的服务器所需要的时间
- 中国大陆用户连到「日本网站」「美国网站」「香港网站」所需要的时间

你可以发现把机器放在日本是比放在美国快上好几倍的。

（所以甚至就算是 VPN 也是尽量要选择日本服务器的，铁定会比美国快很多倍。）

这是我们今天要讲的第一个观念。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/B6p5ylfeRfSaV9uZ9eL2_Rocketbook-2017-02-16-191127-039.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/B6p5ylfeRfSaV9uZ9eL2_Rocketbook-2017-02-16-191127-039.png)

### 网站开启速度是累加的

接下来我们要谈「下载并完全开启一个网站」的「总时长」是如何计算出来的？

以下这个图是中国大陆用户开启一个美国网站所需要的时间，公式是这样的：

> 网站代码产生网页的速度 + 下载网页的速度 + 下载素材的速度

- 网站代码产生网页的速度（通常在100ms-200ms）
- 下载网页（通常一张网页约 100-200KB）
- 下载素材 x 15（通常一张网页大约有 15 个以上素材）

只要发出每一个请求都要 +230 ms。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Wta2x8zfTuWu5Fksbl6Q_Rocketbook-2017-02-16-191121-043.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Wta2x8zfTuWu5Fksbl6Q_Rocketbook-2017-02-16-191121-043.png)

由这个公式我们会总结出

> 1. 下载所需时间 > （远大于）网页生成时间
> 2. 如果你的网站放在美国（如 Heroku），素材又很多的话，网站会巨慢

### 调整「前端速度」优先远高于「后端产生网页」速度

而「生成网页」的架构分解是这样的。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/aW05icz3RVWkDRaMiLOK_Rocketbook-2017-02-16-191115-049.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/aW05icz3RVWkDRaMiLOK_Rocketbook-2017-02-16-191115-049.png)

程序员花了一整天的时间，修改了网站架构，得到的结果可能是：

- 调整前端架构或搬机器：从 10s 下降到 2s (1s = 1000ms)
- 调整后端代码或数据库架构：从 500ms 下降到 150ms

### 总结

`「调整前端架构或搬机器」`比起「调整后端代码或数据库架构」来说，性价比远远为高。

但是，搬机器的地理位置手续非常复杂，特别是机器往往不是一台的，而是一组的，依据地理位置分配资源的技术与架构实做起来会非常复杂。所以我们这种「个体户程序员」，提速的方向往往会以「修正前端架构」去思考。

下面，我们就会先分享如何藉由`「更改前端架构」`为自己的网站，大大提速的技巧。

### 本节作业

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[提取练习-概览](https://fullstack.xinshengdaxue.com/tasks/118)

已有 56 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/118/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/118)

写一篇心得总结本章的重点。并把你的logdown地址贴上来。

# 2-1 前端提速套路概览

在 2009 年左右，当时前端大神 Steve Sounders 与他在雅虎的同事们，写了一篇神文，教当时还处于蛮荒世界的程序员，如何有效提升前端速度效果。

这篇教程 [Best Practices for Speeding Your website](https://developer.yahoo.com/performance/rules.html)　也是我们今天会拿来做教学的教程之一。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/wtwbyc5RHqjxVbiSi7wd_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%888.36.09.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/wtwbyc5RHqjxVbiSi7wd_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%888.36.09.png)

这篇教程洋洋洒洒了写了要调效前端，你所必须要知道的十几个要点。如：

- Minimize HTTP Requests
- Use a Content Delivery Network
- Put Stylesheets at the Top
- Put Scripts at the Bottom
- …..
- ….

大伙在当时可听的如痴如醉。

但是后来问题来了，程序员大概知道自己网页上的结构问题。但是一个网站有几百页，几十个问题，我如何快速找到这些问题，以及知道网站上调整前与调整后的差异呢？

### YSlow

所以后来 Yahoo 就决定了，好人做到底，也开源他们内部用的扫描侦测工具 [YSlow](http://yslow.org/)。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/xFJMeyk1RXmksjQTuanr_yslow.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/xFJMeyk1RXmksjQTuanr_yslow.png)

YSlow 这个工具是个浏览器插件，按下扫描就可以跑出这个网页的比分。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/vRaEQus4SDDt0jRBmcFL_yslow2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/vRaEQus4SDDt0jRBmcFL_yslow2.png)

今天我们前端提速章节，要谈的就是如何利用 YSlow 工具扫描网站的速度问题，并且利用 Rails 本身的机制实做出来这这些加速机制。

## 本节主要议题：

Best Practices for Speeding Your website　上面有很多诀窍，今天我们会挑 4 个最重要提速的技巧讲解并且实做。主要覆盖的题目会有这几个：

- Put Stylesheets at the Top / Put Scripts at the Bottom
- Minimize HTTP Requests
- Use a CDN
- Split Components Across Domains
- Gzip Components
- Minify JavaScript and CSS

如果你都实做了这些技巧，网站瞬间就会有很大的速度提升了。

# 2-2 将 CSS 放在最顶层，将 JavaScript 放在最底层

我们首先来讲一个最简单又能最有感提升网页速度的技巧，这一招叫做：

- 将 CSS 放在最顶层读取
- 将 JavaScript 放在最底层读取

什么意思呢？

就是原先在 Rails 预设的项目，我们都是这样摆放我们的 CSS 与 JavaScript 位置的。

### 步骤

先是这样摆：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pjWXDHTFe8BsSqzolffA_css_before.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/pjWXDHTFe8BsSqzolffA_css_before.png)

你现在得改成这样：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/fcaZo2prRoiMyAtI7dzn_js_after.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/fcaZo2prRoiMyAtI7dzn_js_after.png)

### 原理

#### 将 CSS 放在最顶层读取

将 CSS 先摆在网站的最上层读取，将 JavaScript 放在最底层读取。是因为浏览器是这样运作的：

- 先下载 HTML 本身。
- 而 CSS 放在 head 区块定义，这样可以允许页面逐步呈现。
- 「浏览器」下载完毕 CSS 就开始根据 CSS 的定义「绘制」网页
- 所以 CSS 的顺序要放在 head 里面。

#### 将 JavaScript 放在最底层读取

而为什么要将 JavaScript 从 head 拿出来放在 body 里面呢？

- 因为如果我们倾向在网站里面放很多支 JavaScript ，而这些 JavaScript 都非常肥大，要是一起放在 head 里面，CSS 下载绘制的速度也会受影响。
- 而如果你看大多数 jQuery 的教程，你会发现很都是这样的范例：

```
$( document ).ready(function() {
    console.log( "ready!" );
});
```

- document ready 意思是 HTML 下载完毕之后执行。既然是网页开完才执行，「先画完」再「执行特效」，那么把 JavaScript 放在最底层执行，使用者是不会察觉到任何改动的。
- 而且甚至使用者会感受到网页开得更快了，因为 CSS 更快被浏览器下载绘制完毕。

### 在 Rails 内实做的一个小细节

不过要在 Rails 中这样实做，其实还是要注意一个微小的细节：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/yjQg5SZQSOlVNimTJcc9_js_after.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/yjQg5SZQSOlVNimTJcc9_js_after.png)

如果我们将 JavaScript 往下搬了，那么我们在网页里面要是手写了一些 jQuery 代码。因为这些「手写的代码」开在「jQuery」的上面，所以特效会烂掉，浏览器会抱怨找不到 jQuery。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YDMR2coGQxGmh6MkHn6l_js_2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YDMR2coGQxGmh6MkHn6l_js_2.png)

因为「手写的代码」实际上执行的地方是在 `yield` 这一区。

#### 解决方法：

解决方式是我们在 `javascript_include_tag` 下再多加一行 `yield :handwrite_javascript`。（多一个区块）

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/4xvqB5IUTKWzIQOCPbCS_js_solution.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/4xvqB5IUTKWzIQOCPbCS_js_solution.png)

然后再将原先写的 JavaScript 特效，用 `content_for` 把原先的网页包起来。

那么这一段 JavaScript 就会在`javascript_include_tag` 以下执行了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ICPtH9rTQA2kzyBctMms_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%889.12.08.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ICPtH9rTQA2kzyBctMms_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%889.12.08.png)

# 2-3 Minimize HTTP Requests

接下来，我们要请各位在浏览器看网站源代码，你会在网站 head 看到这么一大包 CSS / JS。这是我们网站里面会用的所有细小资源。

浏览器下载抓档案是这样的：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cPTBSarTiicVuMSqHUbw_%E6%AA%94%E6%A1%88%202017-2-16%2022%2009%2046.jpeg)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cPTBSarTiicVuMSqHUbw_%E6%AA%94%E6%A1%88%202017-2-16%2022%2009%2046.jpeg)

有点像是每次要下载档案，都要先说「哈啰，你这里有没有图？」。

如果你要下载 10 个 CSS，那么就要问 10 次「哈啰，你这里有没有 CSS？」。

> 哈啰一次也是要 50-200ms 的
>
> 哈啰一次也是要 50-200ms 的
>
> 哈啰一次也是要 50-200ms 的

如果你的网站一次要下载很多 CSS / JavaScipt 时，那么网站开启效果一定不会太好，要不是

- 等很久，网站一片空白
- 网站开起来是一片一片开的

所以我们这里有一招可以加速。

### 把多支 CSS / JavaScript 合并成一支 CSS / JS

前端程序员有一个邪恶的技巧，可以解决「要讲 10 次哈啰」的耗时问题。

他们决定部署时把所有 CSS 复制贴上打包成一支 CSS（那么就只需要讲 1 次哈啰）。

如果你用 chrome 打开 Rails production 上 HTML 的源码，就会发现结果的确是变成这样子。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y7y84mSaTjmrMwP4uWop_css_production.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y7y84mSaTjmrMwP4uWop_css_production.png)

为什么可以这样做呢？这是因为：

- 多个 CSS 样式放在一个档案，是可以如常执行的
- 甚至打包起来，把所有空白空行都「砍掉」，还是可以如常执行的。

所以前端界要将网站上线，几乎都会做这样处理。而近年来更先进，以前要先自己用工具打包，再部署。

而现在有些先进的框架（如 Rails ）则是在部署的过程当中，自动压制（ `rake assets:precompile` ）上传。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/o8Z7zt3TRZK8ivwGKdWr_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%8810.21.31.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/o8Z7zt3TRZK8ivwGKdWr_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%8810.21.31.png)

### 步骤

这一课你不用作什么，Rails 已经帮你自动做完了 XD

# 2-4 Use a Content Delivery Network

在最前面我们提到了，搬迁机器的位置其实能有效提升传输速率，但是做起来不太可行。因为有时候，牛逼的服务商只在某个国家提供服务（ 如 Heroku 是在美东，Linode 最近的点在东京）。

况且你的服务对象是面对世界各地的用户，那么机器放哪儿都是问题。

这种状况我们会怎么解决呢？

这时候我们就会用上 CDN （ Content delivery network）加速档案的分发。CDN 是个什么样的概念，我们这里用张图来解释：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/q6Nn9L8ERcyvAAJKfaES_Rocketbook-2017-02-17-134659-053.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/q6Nn9L8ERcyvAAJKfaES_Rocketbook-2017-02-17-134659-053.png)

- 我们可以把「网站服务」与「静态档案」的提供来源（网址出处）分开。
  - 比如说服务器网站是 [www.jd.com](http://www.jd.com/)
  - 图片网址则是由 cdn.jd.com 提供
- CDN 技术做的是针对不同地区的用户，自动提供他们最近的点下载档案
  - 如果 CDN 上有档案快取，就直接从 CDN 上吐给用户
  - 如果 CDN 上没有档案快取，就从原站拉一份，快取在 CDN 上。

### 如何在 Rails 上实现

你不需要去改网站上的 image_tag 一个一个处理。

只要在 Rails 上改全站的图片来源，只要修改 `config/enviorments/production.rb` 里的这一行就可以了。

```
config.action_controller.asset_host = "http://cdn.jd.com"
```

这样全站的 image/css/js 网址，就会全部变成

- cdn.jd.com/images/demo.jpg
- cdn.jd.com/assets/admin.css
- cdn.jd.com/assets/admin.js

### 我在哪可以找到 CDN 服务

- [Amazon Cloudfront](https://aws.amazon.com/cloudfront/)
- [Cloudflare](https://www.cloudflare.com/)

# 2-5 Split component cross domain

在上一章 CDN 的章节，我们提到只要修改 config/enviorments/production.rb 档里的这一行代码 `config.action_controller.asset_host = "http://cdn.jd.com"` 就可以把全站的 image/css/js 网址全部都一并改了。

### HTTP 1.1 的限制

一般来说，一个网站的图片可能都是放在同一个网址上的。比如说原先你上面图的网址可能是：

- jd.com/images/demo.jpg
- jd.com/assets/admin.css
- jd.com/assets/admin.js

那么我们改成 CDN 递送之后，网址会变成

- cdn.jd.com/images/demo.jpg
- cdn.jd.com/assets/admin.css
- cdn.jd.com/assets/admin.js

这样的作法，是有可能将速度提升一些的。那么，这里我们要介绍一个能将速度再提升个四倍的技巧，让我们画一张图来解释一下这件事。

这个技巧要牵扯到 HTTP 1.1 通讯协定，是怎么处理「下载」这件事的。

一般来说，根据浏览器与通讯协定的实做，一个网站只能同时对一个 domain 开启两个连线。也就是如果这一页有 48 张图。浏览器得做 24 次下载。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/jPfICewkTnQEgJzuwawQ_Rocketbook-2017-02-17-142235-054.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/jPfICewkTnQEgJzuwawQ_Rocketbook-2017-02-17-142235-054.png)

那么，这会造成什么情况呢？也就是服务器很快，客户家里的网速也很快，但是客户开起网站的图还是「2张2张开起来的）。

所以我们可以在实现上做个小小 hack，也就是我们可以起多个域名，但是都连到同一台主机上，也就是输出网址改成：

- cdn0.jd.com/images/demo.jpg
- cdn1.jd.com/assets/admin.css
- cdn2.jd.com/assets/admin.js
- cdn3.jd.com/assets/fonts/font-awesome.ttf

网站上的素材是随机从四台机器上分发，那么有 48 张图，只有做 6 次下载，网站瞬间就会变成秒开。

### Rails 可以怎么做：

修改 `config/environments/production.rb` 这一行就可以把全站的 image/css/js 网址全部都一并改了。

```
config.action_controller.asset_host = "http://cdn％d.jd.com"
```

### 本节作业

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[提取练习-前端](https://fullstack.xinshengdaxue.com/tasks/117)

已有 58 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/117/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/117)

本章教了四个方法提升前端效能，回答以下问题进行提取练习：
1.为什么要将 CSS 放在最顶层，将 JavaScript 放在最底层？
2.如何尽可能减少HTTP Requests?
3.CDN是什么？请用自己的话解释
4.如何提升自己的网站加载速度？
并把问题的答案写成logdown，贴上你的logdown链接地址。

# 3-1 后端提速套路概览

后端提速分为两个方向：

- 一个方向是提升 Ruby Code 的效能
- 一个方向是提升数据库方面的效能

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/aW05icz3RVWkDRaMiLOK_Rocketbook-2017-02-16-191115-049.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/aW05icz3RVWkDRaMiLOK_Rocketbook-2017-02-16-191115-049.png)

### 后端侦测速度工具 rack-mini-profiler

这里推荐各位一个在 Rails 里面的测速神器：<https://github.com/MiniProfiler/rack-mini-profiler>

装上去后，会在 Rails 开发模式的网页出现一个小小的 widget，会显示这个网站执行时耗费了多少时间，主要会显示以下的信息：

- controller 执行的速度
- view 执行的速度
- SQL 下了几次
- 为什么 SQL 很慢

### 提速方向

而在实务上，通常后端效能速度瓶颈是这样的：

- 慢在资料库 ( 90% 机率）
- 慢在 Ruby Code （10% 机率）

所以这一章我们会集中在如何`设计调整资料库取资料`的方式，以提升网站效能。

# 3-2 消滅 N+1 Query

提升资料库查询效率有两个方向：

- 减少查询次数
- 提升资料库索引效率

### ActiveRecord 的作用

ActiveRecord （ model ）其实是 Rails 非常强大的一套工具。正常来说，在网站开发时，我们要呼叫数据库资料是使用 SQL 查询语法。

比如说我们要调取 Post 这个 table 的第 12 笔资料，SQL 语法是这样的：

```
SELECT  "posts".* FROM "posts" WHERE "posts"."id" = $1 LIMIT 1  [["id", 12]]
```

但在 Rails 里面我们只需要很优雅的写 `Post.find(12)`。

又比如说我们要调取 Post 的最新 5 笔资料，SQL 语法是这样的：

```
SELECT  "posts".* FROM "posts"  ORDER BY id DESC LIMIT 5
```

但在 Rails 里面我们只需要很优雅的写 `Post.order("id DESC").limit(5)`。

Rails 开发者很幸福的可以利用类似 Ruby 的语句查询资料，享受高效开发的红利。

### N+1 Query 问题

但是，这么方便的包装，却会带来另外一个问题。

以下这是一个情境题，假设这个 controller 里面，我们要列出所有学生 ( students )，页面上也会连带显示他们上的班级 ( class ) 的信息）。

app/controllers/students_controller.rb

```
def index
  @students = Student.all
end`
```

app/views/students/index.html.erb

```
<% @students.each do |student| %>
<tr>
  <td> <%= student.name %> </td>
  <td> <%= student.class.name %> </td>
</tr>
<% end %>
```

看起来没有什么问题。

但问题是这个画面，却会调用了 1 + 4 个 Query。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/PsU5TabROyk8noQuTneV_Rocketbook-2017-02-17-211038-057.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/PsU5TabROyk8noQuTneV_Rocketbook-2017-02-17-211038-057.png)

如果在本机开发环境，应该还不会感受到这是什么严重的大事。

- 因为每调取 1 笔资料是 0.1 ms
- 总共才调取 1+N ( 1+4 = 5 ) 笔资料。
- 总共是 0.1 * 5 = 0.5 ms

但是正式开发环境，要是 Web Server 与 Database Server 是不同台机器，而调取每笔资料是 20ms 的差距，一个页面又有 20 笔资料。那么效能数据就会变成

- 每调取 1 笔资料是 20 ms
- 调取 1+20 ( 1+20 = 21 ) 笔资料
- 总共是 21* 20 = 420 ms

那样这个网页就会变得巨慢无比了！

app/controllers/students_controller.rb

```
def index
  @stude
end
```

app/views/students/index.html.erb

```
<% @students.each do |student| %>
<tr>
  <td> <%= student.name %> </td>
  <td> <%= student.class.name %> </td>
</tr>
<% end %>
```

### Rails 的解法

你可以修改代码变成如下：

app/controllers/students_controller.rb

```
def index
  @students = Student.includes(:class).all
end
```

- 加一个`includes(:class)`，Rails 　就会智能的将这么多个 query 合并成一个 query 了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/LIdTs0gdTbSvZmlZpD08_Rocketbook-2017-02-17-220154-057.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/LIdTs0gdTbSvZmlZpD08_Rocketbook-2017-02-17-220154-057.png)

# 3-3 消灭 Table Scan

Table Scan 的意思是一般数据库，在没有加 Index （索引）的情况下，找资料是一笔一笔的循序的找。

如果我们偷换这个概念

- 书 => 资料
- 地上 => 内存

假设我们今天到图书馆，如果要找一本书要怎么找？

Table Scan 的找法，就是`图书馆工作人员，将全馆的书都倒在地上，一本一本的找给你`！

你就会知道，如果数据库里面有一千万笔资料，查找我们要的数据，效率会如何低下？

以下我们用一张图解释数据库在没有索引卡时，是怎么查找资料。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9r5HYUOMSNOOG3BcBFtE_Rocketbook-2017-02-17-225746-059.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9r5HYUOMSNOOG3BcBFtE_Rocketbook-2017-02-17-225746-059.png)

### 打上 Index

所以，比较好的方式，是我们针对关键的特征栏位，打上索引。比如我们对整个图书馆的书做上索引卡，那么检索时就会比较高效。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/y48a22VPSYS0ZtzmpSFF_Rocketbook-2017-02-17-225746-059%20%E6%8B%B7%E8%B2%9D.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/y48a22VPSYS0ZtzmpSFF_Rocketbook-2017-02-17-225746-059%20%E6%8B%B7%E8%B2%9D.png)

### 常见忘记打 Index 的状况

#### 状况一：has_many

比如说 User `has_many` Order

```
class User < ActiveRecord::Base
  has_many :orders
end
```

那么实务上，我们常常就需要查询 user.orders，会生成如此的 SQL 语句。

```
SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = $1  [["user_id", 3140]]
```

那么当 Order 这个 table 很大时，查询订单效率就会变得很差

##### 解法：

新增一个 migration 然后打上 Index

```
def change
   add_index :orders, :user_id
end
```

### 状况二：查询条件

更多时候，我们在实做某些查询时，也都需要下条件判断：

##### 1. state_machine 的条件

```
def index
  @new_orders = Order.where(:aasm_state => "order_placed")
end
```

##### 2. 时间

```
def index
  @orders = Order.order("created_at DESC")
end
```

#### 3. True / False

```
def index
   @paid_orders = Order.where(:is_paid => true )
end
```

这一些关键的栏位，其实也都需要下 index。

# 3-4 使用高效 index

在上一章我们讲了下 index 的重要性，这一章我们要讲 index 其实也有分索引效率的。

我们以下图来解释不同的数据栏位，索引效率也是有分别的。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9nzgcEkmQdesuBlRLjpG_Rocketbook-2017-02-18-030342-061.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9nzgcEkmQdesuBlRLjpG_Rocketbook-2017-02-18-030342-061.png)

### 常见低效索引：

所以如果当你的代码是这样设计的，想要捞出最新的订单：

如果原先是这样设计的：

```
def index
  @orders = Order.order("created_at DESC")
end
```

可以改成

```
def index
  @orders = Order.order("id DESC")
end
```

效率会高上好几倍。

# 3-5 使用 counter cache

### 使用 Counter Cache

有时候，我们必须在 Rails 里面计算总共有多少笔资料。比如说，一门课有多少学生选修：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MbBzLMwcTNKwdRc7d7aY_Rocketbook-2017-02-18-033651-063.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MbBzLMwcTNKwdRc7d7aY_Rocketbook-2017-02-18-033651-063.png)

背后的代码是：

```
class Course < ActiveRecord::Base
  has_many :students
end
```

```
class Student < ActiveRecord::Base
  belongs_to :course
end
```

```
class CoursesController < ApplicationController
  def index
    @courses = Course.all
  end
end
```

```
<h1> Courses </h1>
<ol>
  <% @courses.each do |course| %>
  <li><%= link_to course.name, course_path(course) %> (<%= course.students.count %> students )</li>
  <% end %>
</ol>
```

而后面产生出来的 Log 会长这样

```
Rendering courses/index
  SQL (0.3ms)   SELECT count(*) AS count_all FROM "students" WHERE ("students".course_id = 61)
  SQL (0.2ms)   SELECT count(*) AS count_all FROM "students" WHERE ("students".course_id = 62)
  SQL (0.3ms)   SELECT count(*) AS count_all FROM "students" WHERE ("students".course_id = 63)
  SQL (0.2ms)   SELECT count(*) AS count_all FROM "students" WHERE ("students".course_id = 64)
  SQL (0.2ms)   SELECT count(*) AS count_all FROM "students" WHERE ("students".course_id = 65)
```

而 count(*) 其实是很伤效能的。

### 改进方法

Rails 其实有一招叫 counter_cache，也就是将 count 快取起来。具体实现作法是：

`rails g migration add_students_count_to_course`

然后在 migration 档案里面加入：

```
def change
   add_column :courses, :students_count, :integer, default: 0
end
```

然后修改 `app/models/student.rb`，变成：

```
class Student < ActiveRecord::Base
  belongs_to :course, counter_cache: true
end
```

那么 Log 就会变成：

```
Rendering courses/index
  SQL (0.3ms)   SELECT students_count FROM "courses" WHERE id = 61
  SQL (0.3ms)   SELECT students_count FROM "courses" WHERE id = 62
  SQL (0.3ms)   SELECT students_count FROM "courses" WHERE id = 63
  SQL (0.3ms)   SELECT students_count FROM "courses" WHERE id = 64   
```

直接取存好的数字，而不是「即时算」，这样就会大幅降低数据库的负担。

# 3-6 用工具自动侦测 N+1 Query, Table Scan, Counter Cache

Bullet 这个 gem <https://github.com/flyerhzm/bullet>，可以自动侦测 Rails 里面的代码有这样的问题。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/JuouXfqaSW8jp49RgJ6u_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-18%20%E4%B8%8A%E5%8D%884.55.39.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/JuouXfqaSW8jp49RgJ6u_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-18%20%E4%B8%8A%E5%8D%884.55.39.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YMvraJKTBqIRo50B9KQH_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-18%20%E4%B8%8A%E5%8D%884.55.51.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YMvraJKTBqIRo50B9KQH_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-18%20%E4%B8%8A%E5%8D%884.55.51.png)



### 本节作业

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[gem bullet](https://fullstack.xinshengdaxue.com/tasks/119)

已有 40 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/119/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/119)

安装 bullet 这个gem，记录自己操作的过程，写成一篇logdown，并将logdown链接贴上来。
注意：仔细阅读 bullet 的 [README](https://github.com/flyerhzm/bullet)，请尝试自行Google解决问题。
提示：Google 关键字 "logdown bullet"

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[提取练习-后端](https://fullstack.xinshengdaxue.com/tasks/120)

已有 38 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/120/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/120)

为什么后端效能大部分是慢在资料库？如何解决这个问题？请写成一篇logdown，并贴上你的logdown链接地址。

# 4-1 重构套路概览

优美高质量的代码是人人都想习得的技能，在此章我们会介绍一些 Rails 内基础的技巧。

让大家可以将代码写的更佳优美。主要在本章我们会涵盖几个主题的基本重构技巧

- Controller
- Model
- View

# 4-2 Controller 重构套路：before_action

这是一个常见的 CRUD controller，我们会发现：`@group = Group.find(params[:id])` 一直出现。

app/controllers/groups_controller.rb

```
class GroupsController < ApplicationController

  def index
    @groups = Group.all
  end

  def new
    @group = Group.new
  end

  def show
    @group = Group.find(params[:id])
  end

  def edit
    @group = Group.find(params[:id])
  end

  def create
    @group = Group.new(group_params)

    if @group.save
      redirect_to groups_path
    else
      render :new
    end
  end

  def update
    @group = Group.find(params[:id])
    if @group.update(group_params)
      redirect_to groups_path, notice: 'Update Success'
    else
      render :edit
    end
  end

  def destroy
    @group = Group.find(params[:id])

    @group.destroy
    redirect_to groups_path, alert: 'Group deleted'
  end

  private



  def group_params
    params.require(:group).permit(:title, :description)
  end
end
```



## 如何整理冗余代码

我们可以用 `before_action` 将这一行重复的代码提取出来。

变成：

app/controllers/groups_controller.rb

```
class GroupsController < ApplicationController

  before_aciton :find_group, only: [:show, :edit, :update, :destroy]

  def index
    @groups = Group.all
  end

  def new
    @group = Group.new
  end

  def show
  end

  def edit
  end

  def create
    @group = Group.new(group_params)

    if @group.save
      redirect_to groups_path
    else
      render :new
    end
  end

  def update
    if @group.update(group_params)
      redirect_to groups_path, notice: 'Update Success'
    else
      render :edit
    end
  end

  def destroy

    @group.destroy
    redirect_to groups_path, alert: 'Group deleted'
  end

  private



  def group_params
    params.require(:group).permit(:title, :description)
  end

  def find_group
    @group = Group.find(params[:id])
  end
end
```

# 4-3 Controller 重构套路：继承

当我们在写后台几个 action 时，会发现几个 Controller 都有同样的几行代码

app/controllers/admin/products_controller.rb

```
class Admin::ProductsController < ApplicationController
  before_action :authenticate_user!
  before_action :admin_required

  layout "admin"

end
```

app/controllers/admin/orders_controller.rb

```
class Admin::OrdersController < ApplicationController
  before_action :authenticate_user!
  before_action :admin_required

  layout "admin"

end
```

### 如何改善

我们可以利用 `继承` 这个特性。新增一个 `AdminController`，内容如下：

app/controllers/admin_controller.rb

```
class AdminController < ApplicationController
  before_action :authenticate_user!
  before_action :admin_required

  layout "admin"

end
```

然后再把里面重复的这几句砍掉，将这几个 controller `< （继承）` 自 AdminController。

如此一来，它们就都具有了 AdminController 的特性。（都需要注册才能登入，都限定要admin才能登入，都使用admin这个layout）

app/controllers/admin/products_controller.rb

```
class Admin::ProductsController < AdminController
end
```

app/controllers/admin/orders_controller.rb

```
class Admin::OrdersController < AdminController
end
```

# 4-4 Model 重构套路：mixin 与 ActiveSupport::Concern

### Mixin

假设我们在 Order 与 Reciept 这两个 model 里面都有 `generate_token` 这个 method。

app/models/order.rb

```
class Order < ActiveRecord::Base
  def generate_token
    self.token = SecureRandom.uuid
  end
end
```

app/models/reciept.rb

```
class Reciept < ActiveRecord::Base
  def generate_token
    self.token = SecureRandom.uuid
  end
end
```

复制贴上代码实在是个不好的习惯。

我们其实可用 `mixin` 这个技巧，将代码进行重构，新增一个档案 ，将此 method 变成一个「特性」。

app/models/concerns/tokenable.rb

```
module Tokenable
  def generate_token
    self.token = SecureRandom.uuid
  end
end
```

再将 Order 与 Reciept 修改成如下。这样一来，代码就变得高雅以及容易叙述。

app/models/order.rb

```
class Order < ActiveRecord::Base
  include Tokenable
end
```

app/models/reciept.rb

```
class Reciept < ActiveRecord::Base
  include Tokenable
end
```

### ActiveSupport::Concern

但是 generate_token 其实与 before_create :generate_token 是一组的。

app/models/order.rb

```
class Order < ActiveRecord::Base

  before_create :generate_token
  def generate_token
    self.token = SecureRandom.uuid
  end
end
```

一般纯的 Ruby module 其实是不认识 before_create 的，所以 Rails 内部开发了一套工具 `ActiveSupport::Concern` 解决这件事。

如果要让 module 也支援加入 before_create，必须要这样写。

app/models/concerns/tokenable.rb

```
module Tokenable

  extend ActiveSupport::Concern

  included do
    before_create :generate_token
  end


  def generate_token
    self.token = SecureRandom.uuid
  end
end
```

# 4-5 解说：Instance method / Class method

class method就是给class层级呼叫的method，instance method则是给class的实例呼叫的method。

举例说明，假设我们有一个class Test长这样：

```
class Test
# 在class内定义method时加上self代表要直接取用class

  def self.class_method
    "class method"
  end

  def instance_method
     "instance method"
  end
end
```

### 呼叫class method时的情况：

```
#class的呼叫

Test.class_method # => "class method"

Test.instance_method # => NoMethodError: undefined method `instance_method' for Test:Class
```

### 呼叫instance method时的情况：

```
#class实例的呼叫

test = Test.new  # => #<Test:0x007fd103969840>

test.class_method # => undefined method `class_method' for #<Test:0x007fd103969840>

test.instance_method # => "instance method"
```

### 参考资源

- <http://railstips.org/blog/archives/2009/05/11/class-and-instance-methods-in-ruby>

# 4-6 解说：Instance variable / Class variable

简单来说，class variable跟着class走，instance variable跟着实例走。

class variable跟instance variable都可以被继承。但只要是在class底下的任何实例改变了class变数，其他同个class的实例的class变数也会被改变。

### class variable例子：

```
class Earth
    # class variable用@@定义

  @@pollution = "low"
end

class HumanBorn < Earth
    @@pollution = "high"
end
```

让我们查看这时Earth的变数`@@pollution`就变成了`"high"`，因为是class variable所以被HumanBorn更改了。

但若class底下的实例是改变实例变数，那么就只会在实例中被改变，不会影响到其他实例。

### instance variable例子：

```
class Kid
    @age = 1
  def grow_up
    @age = @age +1
  end

  def show_age
    @age
  end
end

wayne = Kid.new
wayne.show_age # => 1

wayne.grow_up
wayne.show_age # => 2


jason = Kid.new
# wayne.grow_up改变的是wayne这个实例内的instance variable，所以不影响jason这个实例

jason.show_age # => 1
```

### 参考资源

- <http://railstips.org/blog/archives/2006/11/18/class-and-instance-variables-in-ruby/>

# 4-7 解说：Mixin / Extend / Inheritance

在说明Mixin跟Extend之前我们必须先解释何为Module，因为Mixin跟Extend是在引入module时会使用到的语法，而Inheritance则是继承class时会用到的。

## Module

Module的好处就是可以选择性的引用Module内的方法，不会让Module内的变数或是Method与其他Class互相影响，有点类似class补充包的感觉。而引用Module的方式就是Mixin & Extend。

### Mixin

引用Module的方式有以下两种：

#### 1. Class內include Module

```
class Include < Example
    include module
end
```

使用include的方式可以让module的method在class底下被取用，所以我们就可以使用这样的方法

```
user.module_method
```

#### 2. Extend

另外一个引用Module方式是Extend，Extend的用法是让Class可以直接取用Module内的Method。

```
class Extend < Example
    extend module
end
```

所以这样这个时候我们就可以使用这样的写法：

```
Extend.module_method
```

### Inheritance

Inheritance（继承）的意思就是继承者拥有被继承者的特性，用于类别(class)的继承，所以子类别可以呼叫父类别的方法

```
class Parent
  @last_name = "james"
  def laugh
    "heeeeeeeeha!"
  end
  def last_name
    @last_name
  end
end

class Child < Parent
end

dad = Parent.new
son = Child.new
#Child可以呼叫Parent的method

dad.laugh # => "heeeeeeeeha!"

son.laugh # => "heeeeeeeeha!"

#Child也继承了Parent的实例变数

son.last_name # => "james"
```

### 参考资源

- <http://railstips.org/blog/archives/2009/05/15/include-vs-extend-in-ruby/>
- <http://stackoverflow.com/questions/14541823/how-to-use-concerns-in-rails-4>

# 4-8 小结技巧

- 如果 Model 超过 3 个 PageDown，拆 Module
- 如果 Controller 每个 action 都有重复的code，使用 before_filter
- 如果多个 Controller 有同样的少样几行 action，如 Admin，考虑用 继承

### 本节作业

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[重构代码Part 1](https://fullstack.xinshengdaxue.com/tasks/121)

已有 26 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/121/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/121)

使用本章的技巧，重构自己的商店网站，并将重构前与重构后的不同写一篇logdown记录下来。

# 5-1 Helper 收纳篇 - 1. 预先封装

### Tips 1 : 预先封装会重复写很多次，需要改格式的栏位

常见需要包装的地方有：

- 标题
- 叙述
- 链接
- 图片
- 按钮

所以比如我在设计订单页时

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/msFhrie5RCKr7wTbrlRG_order_list.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/msFhrie5RCKr7wTbrlRG_order_list.png)

就会先在 `app/helpers/orders_helper.rb` 定义 `render_order_created_time(order)`

app/helpers/orders_helper.rb

```
def render_order_created_time(order)
   order.created_at.to_s(:short)
end
```

这样如果以后全站的订单时间格式需要改，那么只要改一处就行了。

# 5-2 Helper 收纳篇 - 2. 使用 Ruby Helper 输出代码

### Tips 2: 不要 HTML 与 Ruby 混杂写 View

有很多同学，会这样写 HTML 与 Ruby 混杂，这样写 View。其实这样写 View 是很不好的。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/osB87eJRb6EFNp5Yajzx_ruby-html.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/osB87eJRb6EFNp5Yajzx_ruby-html.png)

你该这样写。尽量都用 Helper 输出逻辑判断类的代码。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/LTwaJijjRSeJYG0CAx0q_ruby-helper.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/LTwaJijjRSeJYG0CAx0q_ruby-helper.png)

# 5-3 小结：如何发觉自己需要 Helper

- HTML 与Ruby 高度混杂
- 该段程式码有很多 if / else
- 该段程式码衣服穿很多层 `simple_format(truncate(auto_link(@post.content), :length => 30) )`

# 5-4 但是你千万不能用 Helper 到走火入魔

但是每次我教大家写完 Ruby 后，就会有人走火入魔写成这样的代码：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/V515jm83TWms26HKhffx_helpe-chaos.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/V515jm83TWms26HKhffx_helpe-chaos.png)

其实这应该用 Helper 与 Partial 互相结合：

app/helpers/products_helper.rb

```
def render_product_item(product)
  render "products/item"
end
```

app/views/products/_item.html.erb

```
<div class="col-md-3">
  <div>
     <%= link_to(render_product_photo_medium(product.default_photo), product_path(product)) %>
  </div>

  <p>
    <hr>
   <strong> <%= product.name %> </strong>
   <br>
   <span> <%= product.price %> 元 </span>
  </p>
</div>
```

### 如何警觉自己用 Helper 走火入魔

- 程式码出现 html_safe
- content_tag 出现两次
- helper 里面出现纯 HTMLa

# 5-5 使用 Partial 的原则

- 如果 View 超过 2.5 个 PageDown 请拆 Partial
- 如果元件需要被复用，也是拆 Partial
- 特殊元件可拆 partial
- 登入 / 登出 navbar
- Google Analytics

### 本节作业

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[重构代码Part 2](https://fullstack.xinshengdaxue.com/tasks/122)

已有 23 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/122/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/122)

使用本章的技巧，重构自己的商店网站，并将重构前与重构后的不同写一篇logdown记录下来。

# 6-1 使用code climate

## 目标

使用code climate为自己的项目评分。这是一个批改代码的服务，除了分数之外，还会标示出哪里需要修改。

## 步驟

### Step 1:登录code climate

<https://codeclimate.com/>

可以直接使用GitHub账号登录

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bnODlOSRuHhneuriHvAL_Screen%20Shot%202017-03-10%20at%2015.16.31.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bnODlOSRuHhneuriHvAL_Screen%20Shot%202017-03-10%20at%2015.16.31.png)

### Step 2:添加GitHub repo

点击 Add a repository

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/KQaCjcGqQUGmedawEYDM_Screen%20Shot%202017-03-10%20at%2015.20.06.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/KQaCjcGqQUGmedawEYDM_Screen%20Shot%202017-03-10%20at%2015.20.06.png)

到GitHub复制你的repo名称

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cvGjSqxPRwEPvwoFi0Ng_Screen%20Shot%202017-03-10%20at%2015.27.57.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cvGjSqxPRwEPvwoFi0Ng_Screen%20Shot%202017-03-10%20at%2015.27.57.png)

填写到这里

点击 Import Repo from GitHub

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/a4cuIqNCSfyJ4aS9hXLF_Screen%20Shot%202017-03-10%20at%2015.26.43.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/a4cuIqNCSfyJ4aS9hXLF_Screen%20Shot%202017-03-10%20at%2015.26.43.png)

画面如下，点击complete

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5juThnHxR9OifbosAsNG_Screen%20Shot%202017-03-10%20at%2015.35.01.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5juThnHxR9OifbosAsNG_Screen%20Shot%202017-03-10%20at%2015.35.01.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/liWeDWuASdCOI1NLOgh1_Screen%20Shot%20on%202017-03-10%20at%2015:32:13.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/liWeDWuASdCOI1NLOgh1_Screen%20Shot%20on%202017-03-10%20at%2015:32:13.png)

### Step 3:得到评分

GPA是分数，满分为4分

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DH0rS1S7QBnpqWVBQscg_Screen%20Shot%202017-03-10%20at%2015.58.12.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DH0rS1S7QBnpqWVBQscg_Screen%20Shot%202017-03-10%20at%2015.58.12.png)

点击issues查看代码评估

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y2aI0g4QQcyZXFrC3Vr8_Screen%20Shot%20on%202017-03-10%20at%2016:00:20.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y2aI0g4QQcyZXFrC3Vr8_Screen%20Shot%20on%202017-03-10%20at%2016:00:20.png)

### 本节作业

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[在CodeClimate上检查自己大赛作品分数](https://fullstack.xinshengdaxue.com/tasks/258)

已有 23 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/258/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/258)

依照本章节的操作，把自己的大赛项目repo评分，并且把分数贴上来。

##### [Refactor & 效能提升](https://fullstack.xinshengdaxue.com/assignments/17)：[改善自己的项目](https://fullstack.xinshengdaxue.com/tasks/259)

已有 18 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/259/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/259)

依照本课，将自己的项目分数使用refactor技巧来尽可能拿高GPA，把修改前/修改后的得分截图贴上来。
