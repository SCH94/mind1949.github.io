---
layout: post
title: "Rails代码重构"
date: 2017-10-30
tags:
    Rails
    教材
---
| 什么是重构？                                   |      |
| ---------------------------------------- | ---- |
| [**  1. 什么是重构？](https://fullstack.xinshengdaxue.com/posts/1766) |      |

| 关于 Controller                            |      |
| ---------------------------------------- | ---- |
| [**  2. 将代码从 Controller 重构到 Model](https://fullstack.xinshengdaxue.com/posts/1767) |      |
| [**  3. 善用 Model scope](https://fullstack.xinshengdaxue.com/posts/1768) |      |
| [**  4. 善用 Model association](https://fullstack.xinshengdaxue.com/posts/1769) |      |
| [**  5. 有关联的权限检查 scope access](https://fullstack.xinshengdaxue.com/posts/1770) |      |
| [**  6. 使用 Model 虚拟属性](https://fullstack.xinshengdaxue.com/posts/1771) |      |
| [**  7. 使用 Model 回呼(callback)](https://fullstack.xinshengdaxue.com/posts/1772) |      |
| [**  8. 将逻辑放到 Model](https://fullstack.xinshengdaxue.com/posts/1773) |      |
| [**  9. 使用工厂方法(Factory Method)取代复杂的建构过程](https://fullstack.xinshengdaxue.com/posts/1774) |      |

| 关于 Model                                 |      |
| ---------------------------------------- | ---- |
| [**  10. 善用 Module 抽取相关代码](https://fullstack.xinshengdaxue.com/posts/1775) |      |

| 关于 View                                  |      |
| ---------------------------------------- | ---- |
| [**  11. 将代码放回 controller](https://fullstack.xinshengdaxue.com/posts/1776) |      |
| [**  12. 将代码重构到 Model](https://fullstack.xinshengdaxue.com/posts/1777) |      |
| [**  13. 将代码重构到 Helper](https://fullstack.xinshengdaxue.com/posts/1778) |      |
| [**  14. 将代码重构到 Partial 样板](https://fullstack.xinshengdaxue.com/posts/1779) |      |
| [**  15. 使用 Partial 尽量用区域变量取代对象变量](https://fullstack.xinshengdaxue.com/posts/1780) |      |
| [**  16. 整理 Helper 档案](https://fullstack.xinshengdaxue.com/posts/1781) |      |

| 其他补充                                     |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  17. 代码分析工具](https://fullstack.xinshengdaxue.com/posts/1782) |                                          |
| [**  18. 补充和推荐资源](https://fullstack.xinshengdaxue.com/posts/1783) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1783#task) |

# 1. 什么是重构？

> 进行重构教程前，请先完成编程语言系列。

重构(Refactoring)是指对软件代码进行更动以增加可读性或者简化结构，但是不影响功能和输出结果。

真正营运的软件都是演进来的，而不是一步到位的作品，需要借由频繁与用户互动得到的回馈来修改设计。与其把软件开发比喻成盖房子，实际上更像是园艺，需要长时间的呵护。我们甚至可以说，所有得软件开发其实都是一种维护，因为绝大部分的时间都在改code，写一点改一点。即使是新项目，也很快需要回头作修改。

因此面对日渐复杂的代码、以及 团队协同开发的需求，维护好代码是一件重要的事情。

不好的代码，会有以下症状：

- 僵硬 (Rigidity)：难以修改，每改一处牵一发动全身
- 脆弱 (Fragility)：一旦修改，别的无关地方也炸到
- 固定 (Immobility)：难以分解，让程式再重用
- 黏滞 (Viscosity)：弹性不够，把事情做对比做错还难
- 不需要的复杂度 (Needless Complexity)：过度设计没直接好处的基础设施
- 不需要的重复 (Needless Repetition)：相同概念的代码被复制贴上重复使用
- 晦涩 (Opacity)：难以阅读，无法了解意图

好的代码，会有以下特征：

- Readability 易读，容易了解
- Flexibility 弹性，容易扩充
- Effective 效率，撰码快速
- Maintainability 维护性，容易找到问题
- Consistency 一致性，循惯例无需死背
- Testability 可测性，元件独立容易测试

很多时候，为了项目时程，我们会在项目初期只专注于尽快完成项目，而妥协于写出不好的代码，这些不好的代码又被叫做[技术负债](https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA)。因为就像债务一样，虽然短期可以得到好处，但必须仍在未来偿还，不然之后软件会变成越来越难维护，要新增功能的开发成本也会越来越高。工程师需要付出时间成本才能修复之前的妥协所造成的问题。

透过重构行为，我们希望让不好的代码，变成好的代码，减少技术负债。这份教程，会用实际的范例，说明重构前和重构后的差异。这篇教程没有提及自动化测试，不过一个好的重构，建议搭配自动化的测试，这样才可以确保重构前后的软件行为是一样的，而没有带来新的 bugs。

> 重构不等于重写。重构更像是小地方小地方的不断持续改善，而不是花几个月把代码砍掉重写。

重构教程着重在思考为什么这样写比较好，而不是实现功能。照着做是没有意义的，因此这份教程并没有完整的功能实现，而是代码片段(code snippet)。

# 2. 将代码从 Controller 重构到 Model

[Skinny Controller, Fat Model](http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model) 是一篇在 Rails 社区非常有名的文章，这篇 2006 年 Rails 2 时期的旧文章，定调了 Fat Controller 是一种反模式(anti-pattern)。放在 Controller 的代码一般来说比较难进行重用(re-use)和单元测试，可读性也较差，我们希望将更多代码放在 Model 里面。

一个 Rails 项目如果 controller 代码很多，但是 model 代码打开却没有自定义什么方法，给人的印象上就是这是软件开发初学者所写的项目。

基本上，一段 Controller 的 action 代码如果超过15行以上，很可能这段代码表示太肥大了，应该进行重构。

以下示范几个情境，适合将 Controller 的代码重构到 Model，目的都是在简化 controller 的代码。

# 3. 善用 Model scope

情境：在 action 中需要依照不同条件捞取 Model 数据

重构前：在 action 中用 where 指定不同条件

```
class PostsController < ApplicationController
  def index
    @public_posts = Post.where(:state => 'public' ).limit(10)
                  .order('id desc')
    @draft_posts  = Post.where(:state => ‘draft').limit(10)
                  .order('id desc')
  end
end
```

重构后：把 where 条件搬到 model 的 scope 宣告，这样就可以在 controller 使用已经定义好的 scope。可读性变好，而且可以在不同地方重复沿用这个 scope。

```
class Post < ActiveRecord::Base
  scope :published, -> { where(:state => ‘published').limit(10)
                        .order('id desc') }
  scope :draft, -> { where(:state => ‘draft').limit(10)
                    .order('id desc') }
end
```

```
class UsersController < ApplicationController
  def index
    @published_post = Post.published
    @draft_post = Post.draft
  end
end
```

# 4. 善用 Model association

情境：新建数据时，想要关联建立的用户

重构前：

```
class PostsController < ApplicationController
  def create
    @post = Post.new(params[:post])
    @post.user_id = current_user.id
    @post.save
  end
end
```

重构后：由于 User has_many posts 的关系，我们可以用 `current_user.posts.build` 来取代 `@post.user_id = current_user.id` 的作用。

```
class PostsController < ApplicationController
  def create
    @post = current_user.posts.build(params[:post])
    @post.save
  end
end
```

```
class User < ActiveRecord::Base
  has_many :posts
end
```

# 5. 有关联的权限检查 scope access

情境：读取数据时，想要检查用户有没有操作该数据的权限

重构前：需要检查 `@post.user` 等于 `current_user`

```
class PostsController < ApplicationController
  def edit
    @post = Post.find(params[:id)
    if @post.user != current_user
      flash[:warning] = 'Access denied'
      redirect_to posts_url
    end
  end
end
```

重构后：直接用 `current_user.posts.find` 就可以了。如果该 post 不属于该 user，就会找不到数据。不过，如果权限允许管理员的话，这招就不行了。

```
class PostsController < ApplicationController
  def edit
    # raise RecordNotFound exception (404 error) if not found

    @post = current_user.posts.find(params[:id)
  end
end
```

# 6. 使用 Model 虚拟属性

情境：在表单中，操作不是直接对应 Model 属性的字段。例如下述范例，假设 User model 里面有 `first_name` 和 `last_name` 字段，但是画面显示时，我们希望改用 `full_name` 来操作。这个 `full_name`并不是数据库中真正的字段，而是 first_name 和 last_name 两个字段合在一起显示而已。

重构前：表单只能用原始的 `text_field_tag` 方法，并且在 action 中拆开 `params[:full_name]` 塞进 model 的 first_name 和 last_name 字段

```
<% form_for @user do |f| %>
    <%= text_filed_tag :full_name %>
<% end %>
```

```
class UsersController < ApplicationController
  def create
    @user = User.new(params[:user)
    @user.first_name = params[:full_name].split(' ', 2).first
    @user.last_name = params[:full_name].split(' ', 2).last
    @user.save
  end
end
```

重构后：在 model 中新增 `full_name` 和 `full_name=` 方法，这样在表单就可以把 `full_name` 当作一般的 model 字段使用。而 controller action 更是简化到不需要处理 `full_name`。这个 `full_name` 并没有实际对应数据库的字段，因此称之虚拟属性。

```
class User < ActiveRecord::Base
  def full_name
    [first_name, last_name].join(' ')
  end

  def full_name=(name)
    split = name.split(' ', 2)
    self.first_name = split.first
    self.last_name = split.last
  end
end
```

```
<% form_for @user do |f| %>
  <%= f.text_field :full_name %>
<% end %>
```

```
class UsersController < ApplicationController

  def create
    @user = User.create(params[:user)
  end

end
```

# 7. 使用 Model 回呼(callback)

情境：新增文章时，有一个核选方块 `auto_tagging`，如果打勾表示想要系统自动下标籤。

重构前：需要在 action 中检查 `params[:auto_tagging]`，然后调用 model 方法产生标籤(这里假设有一个 AsiaSearch.generate_tags 方法可以自动下标籤)

```
<% form_for @post do |f| %>
  <%= f.text_field :content %>
  <%= check_box_tag 'auto_tagging' %>
<% end %>
```

```
class PostController < ApplicationController
  def create
    @post = Post.new(params[:post])
    if params[:auto_tagging] == '1'
      @post.tags = AsiaSearch.generate_tags(@post.content)
    else
      @post.tags = ""
    end
    @post.save
  end
end
```

重构后：新增一个虚拟属性 `auto_tagging`，以及一个 before_save 回呼来检查要不要自动下标籤。如此在 action 中就可以不必检查和处理 auto_tagging。这段过程会自动在 Post 存储前，自动调用 `generate_taggings` 方法进行处理。

```
class Post < ActiveRecord::Base
  attr_accessor :auto_tagging
  before_save :generate_taggings

  private
  def generate_taggings
    return unless auto_tagging == '1' self.tags = Asia.search(self.content)
  end
end
```

```
<% form_for :note, ... do |f| %>
  <%= f.text_field :content %>
  <%= f.check_box :auto_tagging %>
<% end %>
```

```
class PostController < ApplicationController
  def create
    @post = Post.new(params[:post])
    @post.save
  end
end
```

# 8. 将逻辑放到 Model

情境：有一个发布文章 publish 的 action 有很多操作的相关步骤，需要设定很多 model 字段。

重构前：所有操作都在 action 之中

```
class PostController < ApplicationController
 def publish
   @post = Post.find(params[:id])
   @post.is_published = true
   @post.approved_by = current_user

   if @post.create_at > Time.now - 7.days
     @post.popular = 100
   else
     @post.popular = 0
   end

   @post.save
   redirect_to post_url(@post)
  end
end
```

重构后：把相关的操作全部搬到 Model 的自定义方法 `publish!`，这样 action 中只需要调用 `@post.publish!` 即可，非常可读清楚。这个 `publish!` 方法也可以在其它各处使用。

```
class Post < ActiveRecord::Base
  def publish!(user)
    self.is_published = true
    self.approved_by = user
    if self.create_at > Time.now-7.days
      self.popular = 100
    else
      self.popular = 0
    end
    self.save!
  end
end
```

```
class PostController < ApplicationController
  def publish
    @post = Post.find(params[:id])
    @post.publish!(current_user)

    redirect_to post_url(@post)
  end
end
```

# 9. 使用工厂方法(Factory Method)取代复杂的建构过程

情境：建立 model 需要复杂的建构过程，例如以下建构 Invoice 需要设定很多属性。

重构前：都在 create action 中完成

```
class InvoiceController < ApplicationController
  def create
    @invoice = Invoice.new(params[:invoice])
    @invoice.address = current_user.address
    @invoice.phone = current_user.phone
    @invoice.vip = ( @invoice.amount > 1000 )

    if Time.now.day > 15
      @invoice.delivery_time = Time.now + 2.month
    else
      @invoice.delivery_time = Time.now + 1.month
    end

    @invoice.save
  end
end
```

重构后：在 model 中新写一个类方法 `new_by_user`，把建构的过程全部搬进来。这样 controller action 里面只需要调用这个方法即可。这一招跟上一节是一样的道理。这种建构用途的方法又叫做工厂方法。

```
class Invoice < ActiveRecord::Base
  def self.new_by_user(params, user)
    invoice = self.new(params)
    invoice.address = user.address
    invoice.phone = user.phone
    invoice.vip = ( invoice.amount > 1000 )
    if Time.now.day > 15
      invoice.delivery_time = Time.now + 2.month
    else
      invoice.delivery_time = Time.now + 1.month
    end
    return invoice
  end
end
```

```
class InvoiceController < ApplicationController
  def create
    @invoice = Invoice.new_by_user(params[:invoice], current_user)
    @invoice.save
  end
end
```

# 10. 善用 Module 抽取相关代码

情境：如果将代码从 Controller 重构到 Model 做得不错了，接下来如何进一步重构 Model 代码？

重构前：在 Model 中有一些高度相关的代码，希望能够更清楚他们是一起的，或是希望能在不同 Model 中也能重复使用。

```
class User < ActiveRecord::Base

  validates_presence_of :cellphone
  before_save :parse_cellphone

  def parse_cellphone
    # do something

  end

  def self.foobar
    # do something

  end

end
```

重构后：善用 Ruby 的 module 语法，可以将这些相关代码抽取出来，放在 `app/models/concerns` 目录下，包括 model 的 validates 宣告、回呼宣告、关联宣告、对象方法、类方法等等都可抽取出来。

app/models/concerns/has_cellphone.rb

```
module HasCellphone

  def self.included(base)
    base.validates_presence_of :cellphone
    base.before_save :parse_cellphone
    base.extend ClassMethods
  end

  def parse_cellphone
    # do something

  end

  module ClassMethods
    def foobar
      # do something

    end
  end

end
```

或是使用 [Rails ActiveSupport::Concern](http://api.rubyonrails.org/v5.1/classes/ActiveSupport/Concern.html) 语法，可以更简洁一点：

app/models/concerns/has_cellphone.rb

```
module HasCellphone
  extend ActiveSupport::Concern

  included do
    validates_presence_of :cellphone
    before_save :parse_cellphone
  end

  def parse_cellphone
    # do something

  end

  class_methods do
    def foobar
      # do something

    end
  end

end
```

最后在 model 里面 include 即可。

```
class User < ActiveRecord::Base
  include HasCellphone
end
```

其他 model 也可以沿用这段代码，只要 include 即可：

```
class Contact < ActiveRecord::Base
  include HasCellphone
end
```

这一招其实 controller 也可以用，在 rails 中 `app/controllers/concerns` 目录就是拿来放 controller 的 module 档案

# 11. 将代码放回 controller

> 关于 View，最重要的守则就是在 template 中绝对没有商务逻辑。

重构前：在 View 出现了 `@posts = Post.all`

```
<% @posts = Post.all %>

<% @posts.each do |post| %>
 <%= post.title %>
 <%= post.content %>
<% end %>
```

重构后：应该在 controller 中就先读取 @posts

```
class PostsController < ApplicationController

  def index
    @posts = Post.all
  end

end
```

```
<% @posts.each do |post| %>
 <%= post.title %>
 <%= post.content %>
<% end %>
```

# 12. 将代码重构到 Model

情境：在 View 中需要一些条件判断，来决定要不要显示某些内容

重构前：需要检查有登入、该用户是该篇文章作者或是编辑员

```
<% if current_user && (current_user == @post.user ||
                       @post.editors.include?(current_user) %>
  <%= link_to 'Edit this post', edit_post_url(@post) %>
<% end %>
```

重构后：这一整段条件判断，可以重构到 Model 的一个方法。这样 View 里面只需要调用 `@post.editable_by?(current_user)` 即可，代码干净又清楚。

```
<% if @post.editable_by?(current_user) %>
  <%= link_to 'Edit this post', edit_post_url(@post) %>
<% end %>
```

```
class Post < ActiveRecord::Base
  def ediable_by?(user)
    user && ( user == self.user || self.editors.include?(user)
  end
end
```

# 13. 将代码重构到 Helper

情境：

- HTML 与 Ruby 高度混杂
- 该段程式码有很多 if / else
- 该段程式码衣服穿很多层 simple_format(truncate(auto_link(@post.content), :length => 30) )

重构前：我们想要把文章内容自动加超连结、截断只留前30字前、保留换行等等：

```
<%= simple_format(truncate(auto_link(@post.content), :length => 30) ) %>
```

重构后：抽取出一个 `pretty_content` helper 方法，这样在各处 template 都可以重复使用这个 helper，而且也比较清楚。

app/helpers/posts_helper.rb

```
module PostsHelper
  def pretty_content(content)
    simple_format(truncate(auto_link(content), :length => 30) )
  end
end
```

```
<%= pretty_content(@post.content) %>
```

> 那到底什么情境适合把代码重构到 Model? 什么时候用 Helper 呢？如果跟 HTML 画面显示无关，跟商务逻辑有关，则放到 Model 里面。如果跟 HTML 画面显示有关，则适合放在 Helper 里面。一般来说，在 Model 里面是不会处理 HTML 代码的，这是 Helper 的事情。

# 14. 将代码重构到 Partial 样板

情境：Helper 是 Ruby 代码，里面不适合放太多的 HTML。如果你有一整段的 HTML 代码想要抽取出来，应该用 Partial 样板。

重构前：

```
def render_product_item(product)
  content_tag(:div, :class => "col-md-3") do
    content_tag(:div, link_to(product.title), product_path(product) ) +
    content_tag(:p, tag(:hr)) +
    content_tag(:span, product.price + "元")
  end
end
```

```
 <%= render_product_item(@product) %>
```

重构后：应该改用 partial 而不是 helper。

app/views/products/_item.html.erb

```
<div class="col-md-3">
  <div><%=link_to(product.title), product_path(product) %></div>
  <p>
    <hr>
    <span><%= product.price %>元</span>
  </p>
</div>
```

```
 <%= render :partial => "item", :locals => { :product => @product } %>
```

# 15. 使用 Partial 尽量用区域变量取代对象变量

情境：在使用 Partial 时

```
class Post < ApplicationController
  def show
    @post = Post.find(params[:id)
  end
end
```

重构前：在 action 中宣告的对象变量例如 `@post`，会穿透到这个 template 内所有使用的 partial。虽然很方便，但是如果 partial 内要用到的变量很多，就会搞不清楚到底要准备哪些变量才能使用这个 partial。

```
<%= render :partial => "sidebar" %>
```

_sidebar.html.erb

```
<%= @post.title %>
```

重构后：将 @post 传入这个 partial，这样在这个 partial 里面，就会变成区域变量 `post`。这个好处是可以增加这个 partial 的可重复使用性，也比较清楚要传这些变量才能使用。

```
<%= render :partial => "sidebar", :locals => { :post => @post } %>
```

_sidebar.html.erb

```
<%= post.title %>
```

# 16. 整理 Helper 档案

情境：每次 rails g controller XXX 时，Rails 都会自动新增对应的 XXX_helper.rb 档案

重构前：很多 Helper 档案打开来里面都是空的，没有用到

```
app/helpers/user_posts_helper.rb
app/helpers/author_posts_helper.rb
app/helpers/editor_posts_helper.rb
app/helpers/admin_posts_helper.rb
```

重构后：简化集中到少数的 Helper 档案即可。这些 Helper 档案跟 Controller 并没有对应的关系，所有 Helper 档案里面宣告的方法都是通用的，不会因为放在哪一个 Helper 档案而有差异。因此我们可以重新编排整理。

```
app/helpers/posts_helper.rb
```

# 17. 代码分析工具

- [Rubocop](https://github.com/bbatsov/rubocop) 是一个 gem 可以分析 Rails 代码，建议一些可以重构的地方
- [CodeClimate](https://codeclimate.com/) 是一个线上的工具，可以为项目评分，并建议哪里需要修改。

## 步驟

### Step 1:登录code climate

<https://codeclimate.com/>

可以直接使用GitHub账号登录

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bnODlOSRuHhneuriHvAL_Screen%20Shot%202017-03-10%20at%2015.16.31.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bnODlOSRuHhneuriHvAL_Screen%20Shot%202017-03-10%20at%2015.16.31.png)

### Step 2:添加GitHub repo

点击 Add a repository

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/KQaCjcGqQUGmedawEYDM_Screen%20Shot%202017-03-10%20at%2015.20.06.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/KQaCjcGqQUGmedawEYDM_Screen%20Shot%202017-03-10%20at%2015.20.06.png)

到GitHub复制你的repo名称

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cvGjSqxPRwEPvwoFi0Ng_Screen%20Shot%202017-03-10%20at%2015.27.57.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/cvGjSqxPRwEPvwoFi0Ng_Screen%20Shot%202017-03-10%20at%2015.27.57.png)

填写到这里

点击 Import Repo from GitHub

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/a4cuIqNCSfyJ4aS9hXLF_Screen%20Shot%202017-03-10%20at%2015.26.43.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/a4cuIqNCSfyJ4aS9hXLF_Screen%20Shot%202017-03-10%20at%2015.26.43.png)

画面如下，点击complete

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5juThnHxR9OifbosAsNG_Screen%20Shot%202017-03-10%20at%2015.35.01.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5juThnHxR9OifbosAsNG_Screen%20Shot%202017-03-10%20at%2015.35.01.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/liWeDWuASdCOI1NLOgh1_Screen%20Shot%20on%202017-03-10%20at%2015:32:13.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/liWeDWuASdCOI1NLOgh1_Screen%20Shot%20on%202017-03-10%20at%2015:32:13.png)

### Step 3:得到评分

GPA是分数，满分为4分

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DH0rS1S7QBnpqWVBQscg_Screen%20Shot%202017-03-10%20at%2015.58.12.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/DH0rS1S7QBnpqWVBQscg_Screen%20Shot%202017-03-10%20at%2015.58.12.png)

点击issues查看代码评估

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y2aI0g4QQcyZXFrC3Vr8_Screen%20Shot%20on%202017-03-10%20at%2016:00:20.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Y2aI0g4QQcyZXFrC3Vr8_Screen%20Shot%20on%202017-03-10%20at%2016:00:20.png)

# 18. 补充和推荐资源

- [重构](https://book.douban.com/subject/1229923/) 这本书是软件开发领域的经典之作，原作使用 Java 代码，但是仍然值得一读。另有 [Ruby 版本](https://www.amazon.com/Refactoring-Ruby-Addison-Wesley-Professional/dp/0321984137)但没有中文翻译。
- [how DHH organizes his rails controllers](http://jeromedalbert.com/how-dhh-organizes-his-rails-controllers/) Rails 发明人 DHH 如何组织 Controller 代码，坚持 RESTful
- [Put chubby models on a diet with concerns](https://signalvnoise.com/posts/3372-put-chubby-models-on-a-diet-with-concerns) DHH 对于 concerns 用法的看法

当你仍不满足 Rails 的 concerns 机制时，你会需要更多面向对象的知识，在编程语言教程中有介绍到。关于 Rails 的部分推荐以下补充资料：

- [7 Patterns to Refactor Fat ActiveRecord Models](http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/)
- [Object Oriented Rails – Writing better controllers](https://content.pivotal.io/blog/object-oriented-rails-writing-better-controllers)
- [Slimming Down Your Models and Controllers with Concerns, Service Objects, and Tableless Models](https://www.viget.com/articles/slimming-down-your-models-and-controllers)
- [Growing Rails Applications in Practice](https://leanpub.com/growing-rails)

这是ihower老师最后一篇教程了，謝謝大家 😘😘😘

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/3EPE6XBQtmN4c6iPuwJq_IMG_1024.JPG)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/3EPE6XBQtmN4c6iPuwJq_IMG_1024.JPG)

👏👏👏

### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/87)：[作业](https://fullstack.xinshengdaxue.com/tasks/390)

已有 1 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/390/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/390)

请针对你的项目进行重构，请分享几个 code snippet 片段：重构前以及重构后的差异。
