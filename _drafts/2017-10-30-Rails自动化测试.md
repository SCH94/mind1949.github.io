---
layout: post
title: "Rails自动化测试"
date: 2017-10-30
tags:
    Rails
    教材
---
# Rails自动化测试

| 1. 一个简单的闰年程序 预计学习时间: 1小时半以内              |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  1-1 闰年程序(第一版)](https://fullstack.xinshengdaxue.com/posts/870) |                                          |
| [**  1-2 闰年程序(第二版)](https://fullstack.xinshengdaxue.com/posts/887) |                                          |
| [**  1-3 使用 RSpec 自动化测试](https://fullstack.xinshengdaxue.com/posts/888) |                                          |
| [**  1-4 闰年程序(完成版)](https://fullstack.xinshengdaxue.com/posts/889) |                                          |
| [**  1-5 重构闰年程序(最终版)](https://fullstack.xinshengdaxue.com/posts/890) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/890#task) |

| 2. 停车计费程序 Part 1 预计学习时间: 2小时以内           |      |
| ---------------------------------------- | ---- |
| [**  2-1 目标](https://fullstack.xinshengdaxue.com/posts/891) |      |
| [**  2-2 初始 Rails 并安装 rspec-rails](https://fullstack.xinshengdaxue.com/posts/892) |      |
| [**  2-3 建立 Parking Model](https://fullstack.xinshengdaxue.com/posts/893) |      |
| [**  2-4 撰写 Parking Model 的 Validation 测试](https://fullstack.xinshengdaxue.com/posts/894) |      |
| [**  2-5 完成基本架构](https://fullstack.xinshengdaxue.com/posts/895) |      |
| [**  2-6 准备「一般费率」测试案例](https://fullstack.xinshengdaxue.com/posts/896) |      |
| [**  2-7 开始撰写「一般费率」的测试](https://fullstack.xinshengdaxue.com/posts/897) |      |
| [**  2-8 完成「一般费率」计算](https://fullstack.xinshengdaxue.com/posts/898) |      |

| 3. 停车计费程序 Part 2 预计学习时间: 2小时以内           |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  3-1 目标](https://fullstack.xinshengdaxue.com/posts/899) |                                          |
| [**  3-2 装 Devise 产生 User Model](https://fullstack.xinshengdaxue.com/posts/900) |                                          |
| [**  3-3 修正前台接口](https://fullstack.xinshengdaxue.com/posts/901) |                                          |
| [**  3-4 准备「短期费率」测试案例](https://fullstack.xinshengdaxue.com/posts/902) |                                          |
| [**  3-5 开始撰写「短期费率」的测试](https://fullstack.xinshengdaxue.com/posts/903) |                                          |
| [**  3-6 增加实作](https://fullstack.xinshengdaxue.com/posts/904) |                                          |
| [**  3-7 重构测试码](https://fullstack.xinshengdaxue.com/posts/905) |                                          |
| [**  3-8 扩充长期费率计算](https://fullstack.xinshengdaxue.com/posts/906) |                                          |
| [**  3-9 如何在测试除错](https://fullstack.xinshengdaxue.com/posts/930) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/930#task) |

| 4. 用户验收测试 预计学习时间: 2小时以内                  |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  4-1 目标](https://fullstack.xinshengdaxue.com/posts/907) |                                          |
| [**  4-2 Capybara 安装](https://fullstack.xinshengdaxue.com/posts/908) |                                          |
| [**  4-3 测试「一般费率」缴费流程](https://fullstack.xinshengdaxue.com/posts/909) |                                          |
| [**  4-4 测试注册流程](https://fullstack.xinshengdaxue.com/posts/910) |                                          |
| [**  4-5 测试登入登出流程](https://fullstack.xinshengdaxue.com/posts/911) |                                          |
| [**  4-6 测试「短期费率」流程](https://fullstack.xinshengdaxue.com/posts/912) |                                          |
| [**  4-7 故意修改 Model API](https://fullstack.xinshengdaxue.com/posts/913) |                                          |
| [**  4-8 小结](https://fullstack.xinshengdaxue.com/posts/914) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/914#task) |

| 5. Web API 自动化测试 预计学习时间: 2小时以内           |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  5-1 目标](https://fullstack.xinshengdaxue.com/posts/915) |                                          |
| [**  5-2 安装 rspec-rails](https://fullstack.xinshengdaxue.com/posts/916) |                                          |
| [**  5-3 测试注册 API](https://fullstack.xinshengdaxue.com/posts/917) |                                          |
| [**  5-4 测试登入登出 API](https://fullstack.xinshengdaxue.com/posts/918) |                                          |
| [**  5-5 测试查询列车 API](https://fullstack.xinshengdaxue.com/posts/919) |                                          |
| [**  5-6 测试查询订票、修改定票、取消订票 API](https://fullstack.xinshengdaxue.com/posts/920) |                                          |
| [**  5-7 测试订票 API](https://fullstack.xinshengdaxue.com/posts/921) |                                          |
| [**  5-8 测试查询我全部的订单 API](https://fullstack.xinshengdaxue.com/posts/922) |                                          |
| [**  5-9 测试查询和更新我的资料 API](https://fullstack.xinshengdaxue.com/posts/929) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/929#task) |

| 6. 总结与补充 预计学习时间: 半小时以内                   |      |
| ---------------------------------------- | ---- |
| [**  总结与补充](https://fullstack.xinshengdaxue.com/posts/923) |      |

# 1-1 闰年程序(第一版)

所谓的自动化测试，就是用程序去测试程序，听起来好像有点玄妙。让我们用一个简单的题目来举例：

请写一个方法判断闰年，闰年的规则是这样的：

- 西元年分除以400可整除，为闰年。
- 西元年分除以4可整除但除以100不可整除，为闰年。
- 西元年分除以4不可整除，为平年。
- 西元年分除以100可整除但除以400不可整除，为平年

我们来写程序吧，请新增一个档案 `leap_year.rb`，内容如下：

leap_year.rb

```
def is_leap_year?(year)
  if year % 4 == 0
    return true
  else
    return false
  end

  # 同学们可能会发现这不是正确的版本，让我们继续做下去

end
```

接下来你怎么知道这个方法对不对呢? 让我们试试看：

执行 `irb`，输入：

```
require_relative './leap_year'
is_leap_year?(2016)   # => 应该得到 true
is_leap_year?(2017)   # => 应该得到 false
```

好像对了吗? 让我们想想想，好像应该再测测看 2100 年，照规格应该是平年才对。

```
is_leap_year?(2100)   # => 得到 true，但是应该要 false 才对
```

果然写错了，让我们回去修 bug...

离开`irb`，请输入 `exit`。

# 1-2 闰年程序(第二版)

修改 `leap_year.rb`，改写成：

leap_year.rb

```
def is_leap_year?(year)
  if year % 4 == 0
    if year % 100 == 0
      return false
    else
      return true
    end
  else
    return false
  end
end
```

再进来`irb`测测看，执行 `irb`：

```
require_relative './leap_year'
is_leap_year?(2016)   # => 应该得到 true
is_leap_year?(2017)   # => 应该得到 false
is_leap_year?(2100)   # => 应该得到 false 了
```

看起来好像都对了吗? 我们可能会再多输入几个年份试试看。

但我相信这样往返检查程序是否正确的过程，大家一定不陌生。

而自动化测试想要做的事情，就是去自动化这个过程。

# 1-3 使用 RSpec 自动化测试

首先请各位安装 Rspec，这是一个自动化测试的框架。输入：

`gem install rspec`

新增一个档案 `.rspec`，内容如下：

.rspec

```
--format documentation
--color
```

接着新增一个档案 `leap_year_spec.rb`：

leap_year_spec.rb

```
require_relative './leap_year'

describe "Leap Year" do
  it "2016 is leap year" do
    result = is_leap_year?(2016)  # 把 2016 传进去

    expect(result).to eq(true)    # 检查结果应该要是 true

  end

  it "2017 is common year" do
    result = is_leap_year?(2017)  # 把 2017 传进去

    expect(result).to eq(false)   # 检查结果应该要是 false

  end

  it "2100 is common year" do
    result = is_leap_year?(2100)  # 把 2100 传进去

    expect(result).to eq(false)   # 检查结果应该要是 false

  end

  it "2400 is leap year" do
    result = is_leap_year?(2400)  # 把 2400 传进去

    expect(result).to eq(true)    # 检查结果应该要是 true

  end

end
```

其中每一个 `it` 包起来的就是一个要测试的案例，我们会在里面用 `expect` 方法去检查结果是否如我们所预期。

这里除了刚刚测试的 2016、2017、2100 案例之外，我们还多补了一个检查 2400 年，这应该是润年。

执行 `rspec leap_year_spec.rb` 就会自动测试这四个测试案例(test example)。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/mFJuf8ObR3WgfX8XDYsd_1-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/mFJuf8ObR3WgfX8XDYsd_1-1.png)

红字表示测试没有通过了(这很正常，代表我们发现还有bug)，它指出 2400 年的检查结果不正确。

# 1-4 闰年程序(完成版)

让我们回去继续改程序，改写成如下版本：

leap_year.rb

```
def is_leap_year?(year)
  if year % 4 == 0
    if year % 100 == 0
      if year % 400 == 0
        return true
      else
        return false
      end
    else
      return true
    end
  else
    return false
  end
end
```

再执行一次`rspec leap_year_spec.rb`，出现：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/rc0rOUIFQcWGu8hNU5As_1-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/rc0rOUIFQcWGu8hNU5As_1-2.png)

一片绿字就表示测试通过了，这四个测试案例都通过，我们不需要进`irb`检查了，这个 RSpec 测试程序就帮我们检查好了。

如果你还不放心闰年程序是不是都正确了，也可以继续加更多测试案例进来检查。就判断闰年来说，用这四个测试资料就是关键的测试案例了。

# 1-5 重构闰年程序(最终版)

最后，我们觉得那段源码有点丑，我们想要重构一下，重构意思是在不影响功能的情况下让代码变得更漂亮，例如上述的逻辑可以改成这样：

leap_year.rb

```
def is_leap_year?(y)
  y % 400 == 0 || ( y % 4 == 0 && y % 100 != 0)
end
```

但是怎么确认改成这样，结果还是正确的呢?

只要再执行一次 `rspec leap_year_spec.rb` 观察测试结果通过就知道了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/rc0rOUIFQcWGu8hNU5As_1-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/rc0rOUIFQcWGu8hNU5As_1-2.png)

自动化测试提供了重构的安全网。

### 本节作业

##### [测试作业](https://fullstack.xinshengdaxue.com/assignments/42)：[作业四(请课程最后再挑战这个作业)](https://fullstack.xinshengdaxue.com/tasks/284)

已有 24 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/284/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/284)

请照第一章练习闰年的形式，挑战以下题目：

有一家书店在卖哈利波特书籍系列，每一本书定价 $100 元。买两本不同的书可以打5% 的折扣、买三本不同的书可以打 10% 的折扣、买四本不同的书可以打 20%。如果买到五本可以打到 25% 的折扣。请写出一个方法可以计算价格。

前几个测试案例会是这样：

- 第一集买 1 本，总价应为 100 元
- 第一集买 1 本、第二集买 1 本，总价应为 190 元
- 第一集买 1 本、第二集买 2 本，总价应为 290 元 (要不同集数才有折扣，所以第二集第二本没有折扣)

请继续完成。

# 2-1 目标

上一章只是单纯的 Ruby 程序，那么在 Rails 里面，要怎么写测试呢?

如果是非常简单的程序逻辑，写自动化测试比较没有价值，让我们挑战一个比较难的例子，计算停车费的应用：

规格如下：

- 未注册登入用户，可以点选开始计费和结束，并使用「一般费率」： 第一个小时 ¥2，之后每半小时 ¥1
- 有注册的登入用户，可以选择「短期费率」 或「长期费率」
  - 短期费率：第一个小时 ¥2，之后每半小时 ¥0.5
  - 长期费率：一天 ¥16，若停六小时以内 ¥12

你应该可以想像得到，这个要测试的时候，会有很多种情况吧? 如果每次改代码都要把全部情况都测过一遍，是会非常耗时的。 这时候如果有撰写自动化的技能的话，就可以大大地辅助我们开发，减少开发的时间、减少程序是否正确的疑惑。

接下来我们会实作 Rails Model 的单元测试。自动化测试分成几种不同类型，目前学的这种是针对单一类别的方法进行测试，叫做单元测试(Unit Testing)。

# 2-2 初始 Rails 并安装 rspec-rails

执行

```
rails new parking-app
cd parking-app
rm -rf test
git init
git add .
git commit -m "Init Rails project"
```

> Rails 内建也有一个测试框架放在 `/test` 目录，但是不太好用。业界几乎都改用 RSpec 来写测试。

编辑 `Gemfile`

Gemfile

```
  group :development, :test do
+   gem 'rspec-rails'

    # Call 'byebug' anywhere in the code to stop execution and get a debugger console
    gem 'byebug', platform: :mri
  end
```

执行 `bundle`

执行 `rails g rspec:install` 这会建立出 `spec` 目录来放我们的测试档案。

```
git add .
git commit -m "Install rspec-rails"
```

# 2-3 建立 Parking Model

新增 Parking model 来储存停车的资料，并检查必填的资料。

`rails g model parking`

编辑 migration 档案：

db/migrate/201703XXXXXXXX_create_parkings.rb

```
  class CreateParkings < ActiveRecord::Migration[5.0]
    def change
      create_table :parkings do |t|
+       t.string :parking_type  # 费率类型: guest, short-term, long-term

+       t.datetime :start_at    # 开始时间

+       t.datetime :end_at      # 结束时间

+       t.integer :amount       # 总金额(分)

+       t.integer :user_id, :index => true
        t.timestamps
      end
    end
  end
```

> 注意到 `amount` 金额字段通常会储存货币的最小单位，因此这里 ¥1 会存成 100。

执行 `rake db:migrate`

编辑 `app/models/parking.rb`

app/models/parking.rb

```
  class Parking < ApplicationRecord

+  validates_presence_of :parking_type, :start_at
+  validates_inclusion_of :parking_type, :in => ["guest", "short-term", "long-term"]
+
+  validate :validate_end_at_with_amount
+
+  def validate_end_at_with_amount
+    if ( end_at.present? && amount.blank? )
+      errors.add(:amount, "有结束时间就必须有金额")
+    end
+
+    if ( end_at.blank? && amount.present? )
+      errors.add(:end_at, "有金额就必须有结束时间")
+    end
+  end

  end
```

这里我们检查 `parking_type` 和 `start_at` 是必填，而且 `parking_type` 的值只能是 `["guest", "short-term", "long-term"]` 其中之一。另外我们还自订了一个检查规则是 `end_at` 和 `amount` 需要一起填。

# 2-4 撰写 Parking Model 的 Validation 测试

上述的检查该如何写测试呢?

spec/models/parking_spec.rb

```
  require 'rails_helper'

  RSpec.describe Parking, type: :model do
-   pending "add some examples to (or delete) #{__FILE__}" 这行砍掉不需要
+   describe ".validate_end_at_with_amount" do
+
+     it "is invalid without amount" do
+       parking = Parking.new( :parking_type => "guest",
+                              :start_at => Time.now - 6.hours,
+                              :end_at => Time.now)
+       expect( parking ).to_not be_valid
+     end
+
+     it "is invalid without end_at" do
+       parking = Parking.new( :parking_type => "guest",
+                              :start_at => Time.now - 6.hours,
+                              :amount => 999)
+       expect( parking ).to_not be_valid
+     end
+   end
  end
```

执行 `rspec spec/models/parking_spec.rb` 会看到绿色测试通过：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/hi6VJhaSSeeiXPmDsVBm_2-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/hi6VJhaSSeeiXPmDsVBm_2-1.png)

不过，太顺利其实不是好事，假如我们把验证暂时注解掉：

apps/models/parking.rb

```
  class Parking < ApplicationRecord

-  validate :validate_end_at_with_amount
+  # validate :validate_end_at_with_amount
```

然后把两个 `expect` 也注解掉试看看：

spec/models/parking_spec.rb

```
      it "is invalid without amount" do
        parking = Parking.new( :parking_type => "guest",
                               :start_at => Time.now - 6.hours,
                               :end_at => Time.now)
-       expect( parking ).to_not be_valid
+       # expect( parking ).to_not be_valid
      end

      it "is invalid without end_at" do
        parking = Parking.new( :parking_type => "guest",
                               :start_at => Time.now - 6.hours,
                               :amount => 999)
-       expect( parking ).to_not be_valid
+       # expect( parking ).to_not be_valid
      end
```

你会发现跑测试也是一片绿：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YyY01abBRJix3Z7edxNV_2-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/YyY01abBRJix3Z7edxNV_2-1.png)

这告诉我们如果没有先看到测试失败，那么测试成功可能只是幻觉：其实你的测试代码什么也没测到，结果也会是绿色通过。

让我们把测试的注解改回来

spec/models/parking_spec.rb

```
-  # expect( parking ).to_not be_valid
+  expect( parking ).to_not be_valid

   (略)

-  # expect( parking ).to_not be_valid
+  expect( parking ).to_not be_valid
```

再跑一次测试：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/w3DDXl2eQbqsXmAuMDp0_2-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/w3DDXl2eQbqsXmAuMDp0_2-2.png)

红字了，这表示这个测试真的起了作用，因为我们注解掉 `validate :validate_end_at_with_amount` 的关系，所以测试失败了。

接着请把 `validate :validate_end_at_with_amount` 的注解改回来：

apps/models/parking.rb

```
  class Parking < ApplicationRecord

-  # validate :validate_end_at_with_amount
+  validate :validate_end_at_with_amount
```

# 2-5 完成基本架构

接下来我们来制作 Controller 和网页表单，把操作流程做出来：

- Step1: 显示开始停车的表单
- Step2: 新建一笔停车，纪录下开始时间
- Step3: 显示结束停车的表单
- Step4: 结束一笔停车，记录下结束时间，并且计算停车费
- Step5: 显示停车费用

首先修改 `config/routes.rb`

config/routes.rb

```
 Rails.application.routes.draw do

+   resources :parkings
+   root "parkings#new"

  end
```

执行 `rails g controller parkings`

修改 `app/controllers/parkings_controller.rb`

app/controllers/parkings_controller.rb

```
  class ParkingsController < ApplicationController

+   # Step1: 显示开始停车的表单
+   def new
+     @parking = Parking.new
+   end
+
+   # Step2: 新建一笔停车，纪录下开始时间
+   def create
+     @parking = Parking.new( :parking_type => "guest", :start_at => Time.now )
+     @parking.save!
+
+     redirect_to parking_path(@parking)
+   end
+
+   # Step3: 如果还没结束，显示结束停车的表单
+   # Step5: 如果已经结束，显示停车费用。
+   def show
+     @parking = Parking.find(params[:id])
+   end
+
+   # Step4: 结束一笔停车，记录下结束时间，并且计算停车费
+   def update
+     @parking = Parking.find(params[:id])
+     @parking.end_at = Time.now
+     @parking.calculate_amount
+
+     @parking.save!
+
+     redirect_to parking_path(@parking)
+   end

  end
```

编辑 `app/models/parking.rb`，新增一个 `duration` 和 `calculate_amount` 方法：

app/models/parking.rb

```
   class Parking < ApplicationRecord

     # (略)

+    # 计算停了多少分钟
+    def duration
+      ( end_at - start_at ) / 60
+    end

+    def calculate_amount
+      # 如果有开始时间和结束时间，则可以计算价格
+      if self.amount.blank? && self.start_at.present? && self.end_at.present?
+        self.amount = 9487   # TODO: 等会再来处理
+      end
+    end
+
   end
```

修改 `app/views/parkings/new.html.erb`

app/views/parkings/new.html.erb`<h1>全栈营停车费用计算</h1><%= form_for @parking do |f| %>  <p><%= f.submit "开始计费" %></p><% end %>`

修改 `app/views/parkings/show.html.erb`

app/views/parkings/show.html.erb

```
<h1>全栈营停车费用计算</h1>

<% if @parking.amount.present? # 已经结束，显示停车费 %>

  <p>从 <%= @parking.start_at %> 至 <%= @parking.end_at %><p>
  <p>共 <%= @parking.duration %> 分钟</p>
  <p>总计 <%= number_to_currency(@parking.amount.to_f / 100, :unit => "¥") %> 元</p>

  <p><%= link_to "继续停车", new_parking_path %></p>

<% else # 还没结束，显示结束按钮 %>

  <%= form_for @parking do |f| %>

    <p><%= f.submit "结束计费" %></p>

  <% end %>

<% end %>
```

让我们操作看看，浏览 `http://localhost:3000`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/d1QMZnSQQSRdLSlxhVEc_2-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/d1QMZnSQQSRdLSlxhVEc_2-3.png)

按下开始计费：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Aagn4jpRf6IQDskmpJ9u_2-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Aagn4jpRf6IQDskmpJ9u_2-4.png)

按下结束计费：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/psJZUnWQky8eJF9kd8tU_2-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/psJZUnWQky8eJF9kd8tU_2-5.png)

最后显示时间是 UTC 有点奇怪，这是因为 Rails 默认的时区是 UTC，让我们改成北京时间：

修改 `config/application.rb`，加上一行指定北京时区：

config/application.rb

```
  module ParkingApp
    class Application < Rails::Application
+      config.time_zone = "Beijing"
    end
  end
```

重开服务器再看一次就是北京时区了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/rp4K2puJSsyxdHFjeRNc_2-6.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/rp4K2puJSsyxdHFjeRNc_2-6.png)

> 无论设定什么时区，Rails 存进数据库一律是用 UTC 储存，这样在做跨时区的应用时，比大小才不会出错。这里有设定时区的话，Rails 会自动在读取和写入数据库的时候帮你转换时区。

# 2-6 准备「一般费率」测试案例

接下来让我们进攻这堂课的重点，计算停车的费率：未注册登入用户使用一般费率的规则：第一个小时 ¥2，之后每半小时 ¥1

刚才在写测试的时候，有一个关键是要决定要测什么：准备测试案例可说是写测试的关键，要测哪些案例(example)才算这个程序是正确的。

因此在开始写代码前，我们先梳理一下：根据上述的规则，我们脑力激荡一下列出所有可能测试案例的清单，特别是边界(edge case)的情形：

| 时间长度   | 总金额  |
| ------ | ---- |
| 30 分钟  | 2    |
| 60 分钟  | 2    |
| 61 分钟  | 3    |
| 90 分钟  | 3    |
| 120 分钟 | 4    |

列出所有需要测试的可能情况后，再删减掉明显重复的案例，例如测了 30 分钟，就不需要再测 15 分钟 或 45 分钟了，因为都在第一个小时内。

# 2-7 开始撰写「一般费率」的测试

我们在 2-4 时，告诉各位写测试时，要看到测试失败，才表示测试有作用。

因此，写测试的时机点，不一定是先写实作代码，再写测试代码。而可以是先写测试代码，再写实作代码。这样就顺理成章会先看到测试失败的情形。

根据上一节准备的案例，我们开始写第一个测试案例：

spec/models/parking_spec.rb

```
+  describe ".calculate_amount" do
+    it "30 mins should be ¥2" do
+      t = Time.now
+      parking = Parking.new( :parking_type => "guest", :start_at => t, :end_at => t + 30.minutes )
+      parking.calculate_amount
+      expect(parking.amount).to eq(200)
+    end
+  end
```

> 用 describe 包起来只是用来分类测试案例而已，并没有什么真正的作用。这里用意是里面都是针对 calculate_amount 方法的测试。另外，describe 和 it 的第一个字串参数也只是描述，是可以打中文的，例如 `it "30 分钟应该是 2 元"`

执行 `rspec spec/models/parking_spec.rb` 会出现红字测试失败：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/6RBBCP5DSkuVxWzokLPk_2-7.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/6RBBCP5DSkuVxWzokLPk_2-7.png)

开始实作，只需要让这个测试通过即可，先不用急着完成：

app/models/parking.rb

```
  def calculate_amount
     if self.amount.blank? && self.start_at.present? && self.end_at.present?
-      self.amount = 9487 # TODO: 等会再来处理
+      if duration <= 60
+        self.amount = 200
+      end
    end
  end
```

执行 `rspec spec/models/parking_spec.rb` 测试通过。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9ZdpwSTQQSuupEWYtpvC_2-8.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9ZdpwSTQQSuupEWYtpvC_2-8.png)

增加 60 分钟的测试案例，注意到案例跟案例之间是互相独立、不会互相影响的(这样测试失败时，才不用怀疑是不是被别的测试影响到)，因此新增加的测试案例，里面需要的物件会重新建立。

spec/models/parking_spec.rb

```
   describe ".calculate_amount" do

+    it "60 mins should be ¥2" do
+      t = Time.now
+      parking = Parking.new( :parking_type => "guest", :start_at => t, :end_at => t + 60.minutes )
+      parking.calculate_amount
+      expect( parking.amount ).to eq(200)
+    end

     # (略)
   end
```

执行 `rspec spec/models/parking_spec.rb` 测试也通过。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bvgnKrMxSLeHBi8z9CFa_2-9.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bvgnKrMxSLeHBi8z9CFa_2-9.png)

# 2-8 完成「一般费率」计算

增加 61 分钟的测试案例：

spec/models/parking_spec.rb

```
+    it "61 mins should be ¥3" do
+      t = Time.now
+      parking = Parking.new( :parking_type => "guest", :start_at => t, :end_at => t + 61.minutes )
+      parking.calculate_amount
+      expect( parking.amount ).to eq(300)
+    end
```

执行 `rspec spec/models/parking_spec.rb` 会出现红字测试失败：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/e8h0p8gSkKM273oSbTRI_2-10.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/e8h0p8gSkKM273oSbTRI_2-10.png)

改实作：

app/models/parking.rb

```
  def calculate_amount
    if self.amount.blank? && self.start_at.present? && self.end_at.present?
-     if duration <= 60
-       self.amount = 200
-     end
+     total = 0
+     if duration <= 60
+       total = 200
+     else
+       total += 200
+       left_duration = duration - 60
+       total += ( left_duration.to_f / 30 ).ceil * 100
+     end
+
+     self.amount = total
    end
  end
```

执行 `rspec spec/models/parking_spec.rb` 测试通过。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5lRF5XXFRy6ZGxyLHatA_2-11.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5lRF5XXFRy6ZGxyLHatA_2-11.png)

增加 90 分钟的测试案例：

spec/models/parking_spec.rb

```
it "90 mins should be ¥3" do
  t = Time.now
  parking = Parking.new( :parking_type => "guest", :start_at => t, :end_at => t + 90.minutes )
  parking.calculate_amount
  expect( parking.amount ).to eq(300)
end
```

执行 `rspec spec/models/parking_spec.rb` 测试通过。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/d5ONPqfTAWqkALmq1zyx_2-12.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/d5ONPqfTAWqkALmq1zyx_2-12.png)

增加 120 分钟的测试案例：

spec/models/parking_spec.rb

```
it "120 mins should be ¥4" do
  t = Time.now
  parking = Parking.new( :parking_type => "guest", :start_at => t, :end_at => t + 120.minutes )
  parking.calculate_amount
  expect( parking.amount ).to eq(400)
end
```

执行 `rspec spec/models/parking_spec.rb` 测试通过。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/APqzjPugTOWf4fMJTW2n_2-13.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/APqzjPugTOWf4fMJTW2n_2-13.png)

你会发现我们不需要一开始就把全部测试案例都先写上去(这样要一次通过所有测试会很辛苦)，而是新写一段测试码让测试失败，改一下实作让测试通过，然后再新写下一个测试码让测试失败，然后再改实作，如此迭代交替。

这种技巧，在软件开发领域有一个很响亮的名称，叫做 TDD(Test-Driven Development)，流程是这样的：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9HKlzsNoQfm7A0zHddNw_tdd.jpg)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/9HKlzsNoQfm7A0zHddNw_tdd.jpg)

流程的最后一步是重构，例如，我们可以整个方法改成更简洁的写法：

app/models/parking.rb

```
 def calculate_amount
    if self.amount.blank? && self.start_at.present? && self.end_at.present?
      if duration <= 60
        self.amount = 200
      else
        self.amount = 200 + ((duration - 60).to_f / 30).ceil * 100
      end
    end
  end
```

这时候再执行 `rspec spec/models/parking_spec.rb` 还是通过，就知道这个重构万无一失了。

至此，我们完成了一般费率的计算，过程中不需要打开浏览器，或是进 `rails console` 进行检查。

# 3-1 目标

接下来实作有注册的登入用户，可以选择「短期费率」或「长期费率」：

- 短期费率：第一个小时 ¥2，之后每半小时 ¥0.5
- 长期费率：一天 ¥16，若停六小时以内 ¥12

# 3-2 装 Devise 产生 User Model

编辑 `Gemfile` 加上 `gem "devise"`

执行 `bundle`，然后重启服务器

执行 `rails g devise:install`

执行 `rails g devise user`

执行 `rake db:migrate`

编辑 `app/views/layout/application.html.erb`，插入：

app/views/layout/application.html.erb

```
  <body>
+   <% if flash[:notice] %>
+     <%= flash[:notice] %>
+   <% end %>

+   <% if flash[:alert] %>
+     <%= flash[:alert] %>
+   <% end %>

+  <% if current_user %>
+     <%= link_to('登出', destroy_user_session_path, :method => :delete) %>
+    <%= link_to('修改密码', edit_registration_path(:user)) %>
+  <% else %>
+    <%= link_to('注册', new_registration_path(:user)) %> |
+    <%= link_to('登入', new_session_path(:user)) %>
+   <% end %>

...(略)
```

编辑 `app/models/user.rb`，加上 parkings 关联

app/models/user.rb

```
 class User < ApplicationRecord

+ has_many :parkings

...(略)
```

编辑 `app/models/parking.rb`，加上 user 关联

app/models/parking.rb

```
 class Parking < ApplicationRecord

+ belongs_to :user, :optional => true

...(略)
```

重启 Rails 服务器

# 3-3 修正前台接口

修改 `parkings_controller.rb`

app/controllers/parkings_controller.rb

```
   def create
-    @parking = Parking.new( :parking_type => "guest", :start_at => Time.now )
+    @parking = Parking.new( :start_at => Time.now )
+
+    # 有登入的话，根据用户选的费率。没有登入的话，指定是 guest 费率
+    if current_user
+      @parking.parking_type = params[:parking][:parking_type]
+      @parking.user = current_user
+    else
+      @parking.parking_type = "guest"
+    end
+
```

修改 `app/views/parkings/new.html.erb`

app/views/parkings/new.html.erb

```
   <%= form_for @parking do |f| %>
+  <% if current_user %>
+
+    <label>
+      <%= f.radio_button :parking_type, "short-term" %> 短期费率
+    </label>
+
+    <label>
+      <%= f.radio_button :parking_type, "long-term" %> 长期费率
+    </label>
+
+  <% else %>
+    一般费率
+  <% end %>
+

   <p><%= f.submit "开始计费" %></p>

 <% end %>
```

修改 `app/views/parkings/show.html.erb`，多加一行显示是哪一种费率：

app/views/parkings/show.html.erb

```
  <% if @parking.amount.present? # 已经结束，显示停车费 %>

+   <p>计费方式 <%= @parking.parking_type %></p>

    # (略)
```

实际注册和登入之后，就可以操作看看了：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Nb2t2VeeSrypTuQMbapZ_3-1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Nb2t2VeeSrypTuQMbapZ_3-1.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/xUWuKmNQ7eVmOOtkC9Gs_3-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/xUWuKmNQ7eVmOOtkC9Gs_3-2.png)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/CIQyLThSqO9orIrccmLA_3-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/CIQyLThSqO9orIrccmLA_3-3.png)

# 3-4 准备「短期费率」测试案例

和准备「一般费率」测试案例一样，让我们列出「短期费率」需要测试的清单：

| 时间长度   | 总金额  |
| ------ | ---- |
| 30 分钟  | 2    |
| 60 分钟  | 2    |
| 61 分钟  | 2.5  |
| 90 分钟  | 2.5  |
| 120 分钟 | 3    |

# 3-5 开始撰写「短期费率」的测试

现在 `calculate_amount` 方法里面有两种计费方式，我们可以用 `context` 语法来分类，一个区块是`context "guest"`，另一个区块是`context "short-term"`。

spec/models/parking_spec.rb

```
  describe ".calculate_amount" do
+   context "guest" do
      # (略，本来的一般费率测试放在这层)
+   end
+
+   context "short-term" do
+     it "30 mins should be ¥2" do
+       t = Time.now
+       parking = Parking.new( :parking_type => "short-term",
+                              :start_at => t, :end_at => t + 30.minutes )
+       parking.user = User.create(:email => "test@example.com", :password => "123455678")
+
+       parking.calculate_amount
+       expect(parking.amount).to eq(200)
+     end
+
+     it "60 mins should be ¥2" do
+       t = Time.now
+       parking = Parking.new( :parking_type => "short-term",
+                              :start_at => t, :end_at => t + 60.minutes )
+       parking.user = User.create(:email => "test@example.com", :password => "123455678")
+
+       parking.calculate_amount
+       expect( parking.amount ).to eq(200)
+     end
+
+     it "61 mins should be ¥2.5" do
+       t = Time.now
+       parking = Parking.new( :parking_type => "short-term",
+                              :start_at => t, :end_at => t + 61.minutes )
+       parking.user = User.create(:email => "test@example.com", :password => "123455678")
+
+       parking.calculate_amount
+
+       expect( parking.amount ).to eq(250)
+     end
+
+     it "90 mins should be ¥2.5" do
+       t = Time.now
+       parking = Parking.new( :parking_type => "short-term",
+                              :start_at => t, :end_at => t + 90.minutes )
+       parking.user = User.create(:email => "test@example.com", :password => "123455678")
+
+       parking.calculate_amount
+       expect( parking.amount ).to eq(250)
+     end
+
+     it "120 mins should be ¥3" do
+       t = Time.now
+       parking = Parking.new( :parking_type => "short-term",
+                              :start_at => t, :end_at => t + 120.minutes )
+       parking.user = User.create(:email => "test@example.com", :password => "123455678")
+
+       parking.calculate_amount
+       expect( parking.amount ).to eq(300)
+     end
+
+   end
  end
```

> context 和 describe 作用一模一样，单纯只是分类组织而已，没有实际作用

执行 `rspec spec/models/parking_spec.rb` 测试失败。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/jdpXuVHS8G1ECfenvxnX_3-4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/jdpXuVHS8G1ECfenvxnX_3-4.png)

# 3-6 增加实作

一般费率和短期费率，只有差在停了一小时后，前者是每半小时 ¥1，后者是 ¥0.5，我们很快地就修好实作了：

app/models/parking.rb

```
  def calculate_amount
+    factor = (self.user.present?)? 50 : 100

    if self.amount.blank? && self.start_at.present? && self.end_at.present?
      if duration <= 60
        self.amount = 200
      else
-        self.amount = 200 + ((duration - 60).to_f / 30).ceil * 100
+        self.amount = 200 + ((duration - 60).to_f / 30).ceil * factor
      end
    end
  end
```

执行 `rspec spec/models/parking_spec.rb` 全部测试通过。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/g2vPTGmSTumjAscNSKWz_3-5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/g2vPTGmSTumjAscNSKWz_3-5.png)

# 3-7 重构测试码

除了实作代码，测试代码也可以重构。不同案例之间如果有重复用到的变量，可以抽取出来放在 `before` 区块：

```
 describe ".calculate_amount" do
+   before do
+     # 把每个测试都会用到的 @time 提取出来，这个 before 区块会在这个 describe 内的所有测试前执行
+     @time = Time.new(2017,3, 27, 8, 0, 0) # 固定一个时间比 Time.now 更好，这样每次跑测试才能确保一样的结果
+   end

    context "guest" do

+     before do
+       # 把每个测试都会用到的 @parking 提取出来，这个 before 区块会在这个 context 内的所有测试前执行
+       @parking = Parking.new( :parking_type => "guest", :user => @user, :start_at => @time )
+     end

      it "30 mins should be ¥2" do
-       t = Time.now
-       parking = Parking.new(:parking_type => "guest", :start_at => t, :end_at => t + 30.minutes)
-       parking.calculate_amount
-       expect(parking.amount).to eq(200)
+       @parking.end_at = @time + 30.minutes
+       @parking.calculate_amount
+       expect(@parking.amount).to eq(200)
      end

      it "60 mins should be ¥2" do
-       t = Time.now
-       parking = Parking.new(:parking_type => "guest", :start_at => t, :end_at => t + 60.minutes)
-       parking.calculate_amount
-       expect( parking.amount ).to eq(200)
+       @parking.end_at = @time + 60.minutes
+       @parking.calculate_amount
+       expect( @parking.amount ).to eq(200)
      end

      it "61 mins should be ¥3" do
-       t = Time.now
-       parking = Parking.new(:parking_type => "guest", :start_at => t, :end_at => t + 61.minutes)
-       parking.calculate_amount
-       expect( parking.amount ).to eq(300)
+       @parking.end_at = @time + 61.minutes
+       @parking.calculate_amount
+       expect( @parking.amount ).to eq(300)
      end

      it "90 mins should be ¥3" do
-       t = Time.now
-       parking = Parking.new(:parking_type => "guest", :start_at => t, :end_at => t + 90.minutes)
-       parking.calculate_amount
-       expect( parking.amount ).to eq(300)
+       @parking.end_at = @time + 90.minutes
+       @parking.calculate_amount
+       expect( @parking.amount ).to eq(300)
      end

      it "120 mins should be ¥4" do
-       t = Time.now
-       parking = Parking.new(:parking_type => "guest", :start_at => t, :end_at => t + 120.minutes)
-       parking.calculate_amount
-       expect( parking.amount ).to eq(400)
+       @parking.end_at = @time + 120.minutes
+       @parking.calculate_amount
+       expect( @parking.amount ).to eq(400)
      end
    end

    context "short-term" do

+     before do
+       # 把每个测试都会用到的 @user 和 @parking 提取出来
+       @user = User.create( :email => "test@example.com", :password => "123455678")
+       @parking = Parking.new( :parking_type => "short-term", :user => @user, :start_at => @time )
+     end

      it "30 mins should be ¥2" do
-       t = Time.now
-       parking = Parking.new( :parking_type => "short-term",
-                              :start_at => t, :end_at => t + 30.minutes )
-       parking.user = User.create( :email => "test@example.com", :password => "123455678")
-       parking.calculate_amount
-       expect(parking.amount).to eq(200)
+       @parking.end_at = @time + 30.minutes
+       @parking.calculate_amount
+       expect(@parking.amount).to eq(200)
      end

      it "60 mins should be ¥2" do
-       t = Time.now
-       parking = Parking.new( :parking_type => "short-term",
-                              :start_at => t, :end_at => t + 60.minutes )
-       parking.user = User.create( :email => "test@example.com", :password => "123455678")
-       parking.calculate_amount
-       expect( parking.amount ).to eq(200)
+       @parking.end_at = @time + 60.minutes
+       @parking.calculate_amount
+       expect( @parking.amount ).to eq(200)
      end

      it "61 mins should be ¥2.5" do
-       t = Time.now
-       parking = Parking.new( :parking_type => "short-term",
-                              :start_at => t, :end_at => t + 61.minutes )
-       parking.user = User.create( :email => "test@example.com", :password => "123455678")
-       parking.calculate_amount
-       expect( parking.amount ).to eq(250)
+       @parking.end_at = @time + 61.minutes
+       @parking.calculate_amount
+       expect( @parking.amount ).to eq(250)
      end

      it "90 mins should be ¥2.5" do
-       t = Time.now
-       parking = Parking.new( :parking_type => "short-term",
-                              :start_at => t, :end_at => t + 90.minutes )
-       parking.user = User.create( :email => "test@example.com", :password => "123455678")
-       parking.calculate_amount
-       expect( parking.amount ).to eq(250)
+       @parking.end_at = @time + 90.minutes
+       @parking.calculate_amount
+       expect( @parking.amount ).to eq(250)
      end

      it "120 mins should be ¥3" do
-       t = Time.now
-       parking = Parking.new( :parking_type => "short-term",
-                              :start_at => t, :end_at => t + 120.minutes )
-       parking.user = User.create( :email => "test@example.com", :password => "123455678")
-       parking.calculate_amount
-       expect( parking.amount ).to eq(300)
+       @parking.end_at = @time + 120.minutes
+       @parking.calculate_amount
+       expect( @parking.amount ).to eq(300)
      end
    end
  end
```

但是，也不能做的太过分，例如把所有测试案例改写成循环:

```
# 不好的例子，请不要这么写

[[30, 200], [60, 200], [61, 300], [90, 300], [120, 400]].each do |data|
  it "#{data[0]} mins should be #{data[1]}" do
    @parking.end_at = @time + data[0].minutes
    @parking.calculate_amount
    expect(@parking.amount).to eq(data[1])
  end
end
```

这样就太过分了，因为测试码需要尽量好读，每一个测试案例尽量清楚，能一眼就看出来要测试什么。

因此测试代码比实作还多行是正常的，请耐着性子看完，你会发现其实非常平铺直叙，就是 1. 建立测试资料 2.执行程序 3. 检查结果

# 3-8 扩充长期费率计算

长期费率的计算，跟前两者差比较多。让我们来调整看看。来修改 `calulate_amount` 方法，根据不同费率呼叫不同计算方法：

app/models/parking.rb

```
  def calculate_amount
    if self.amount.blank? && self.start_at.present? && self.end_at.present?
      if self.user.blank?
        self.amount = calculate_guest_term_amount  # 一般费率
      elsif self.parking_type == "long-term"
          self.amount = calculate_long_term_amount # 长期费率
      elsif self.parking_type == "short-term"
        self.amount = calculate_short_term_amount  # 短期费率
      end
    end
  end

  def calculate_guest_term_amount
    if duration <= 60
      self.amount = 200
    else
      self.amount = 200 + ((duration - 60).to_f / 30).ceil * 100
    end
  end

  def calculate_short_term_amount
    if duration <= 60
      self.amount = 200
    else
      self.amount = 200 + ((duration - 60).to_f / 30).ceil * 50
    end
  end

  def calculate_long_term_amount
    # TODO
  end
```

在跑一次测试，一片绿，非常好!! 这样修改 calulate_amount 有测试安全网太棒了。

剩下一个计算长期费率的就当作挑战作业吧。

> 在测试代码中，你可以直接 `puts` 变量，跑测试的时候就会印出来了。这是最简单的除错方式。或是你可以在任意地方放 `byebug` 下中断点，就会在执行到那一行时停下来，可以检查变量，输入 `continue` 就会继续执行下去。

# 3-9 如何在测试除错

在测试代码中，你可以直接 `puts` 变量，跑测试的时候就会印出来了。这是最简单的除错方式。

例如我们想观察一下执行 `calculate_amount` 方法时，里面的 `parking_type` 长怎样：

app/models/parking.rb

```
   def calculate_amount
+    puts "----"
+    puts self.parking_type
+    puts "----"
    # (略)
```

执行 `rspec spec/models/parking_spec.rb` 会发现每个测试都印出来了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/rffoc2SSzySB5iBstbGT_3-6.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/rffoc2SSzySB5iBstbGT_3-6.png)

但是这样可能不是我们除错时想要的，有没有办法只跑我想要除错的那一个测试案例?

方法一：暂时注解掉其他的测试案例，只留下一个就好了
方法二：请编辑 `spec/rails_helper.rb`，加上两行设定：

spec/rails_helper.rb

```
  RSpec.configure do |config|
  # (略)

+  config.filter_run :focus => true
+  config.run_all_when_everything_filtered = true
```

然后修改 `spec/models/parking_spec.rb` 针对你想要单独测试的案例，加上 `:focus => true`，例如：

spec/models/parking_spec.rb

```
-     it "30 mins should be ¥2" do
+     it "30 mins should be ¥2", :focus => true do
        @parking.end_at = @time + 30.minutes
        @parking.save
        expect(@parking.amount).to eq(200)
      end
```

再跑一次测试 `rspec spec/models/parking_spec.rb` 就只会跑这个测试了。除错完毕把 `:focus => true` 移除就可以了。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/uloagW4TpuJuMAfYr5DI_3-7.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/uloagW4TpuJuMAfYr5DI_3-7.png)

除了用 `puts`，你也可以在用 `byebug` 下中断点(这是一个内建的gem，你在Gemfile里面可以看到)，就会在执行到那一行时停下来，可以检查变量，输入 `continue` 就会继续执行下去。

例如

app/models/parking.rb

```
   def calculate_amount
+    byebug
     # (略)
```

执行 `rspec spec/models/parking_spec.rb` 会发现停在中途，这时候可以检查变量。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/w7rDU6USISRDJxRv8Pe6_3-8.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/w7rDU6USISRDJxRv8Pe6_3-8.png)

最后输入 `continue` 就会继续执行下去。这一招不只在测试可以用，平常开发除错也可以使用：`rails server` 服务器就会在你下中断点的地方暂时停止以供除错。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5GvxAYg4SeCqK7h4nUws_3-9.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/5GvxAYg4SeCqK7h4nUws_3-9.png)

### 本节作业

##### [测试作业](https://fullstack.xinshengdaxue.com/assignments/42)：[作业一](https://fullstack.xinshengdaxue.com/tasks/281)

已有 29 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/281/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/281)

请完成计算停车费率的全部测试，并贴上长期费率的测试案例清单。

# 4-1 目标

单元测试是针对单一类别和方法进行测试，但是对一个系统来说，单一组件运作正常，不代表整个系统运作正常。就像这张 GIF 图一样，锁是正常运作的，门也是正常运作的，但是组起来不OK啊。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/uz9dSFmyQduBvUqyhyeO_4-1.gif)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/uz9dSFmyQduBvUqyhyeO_4-1.gif)

刚才我们只测试了 Parking model，但是整个 Rails 还包括 Router、Controller 和 View。

这时候可以撰写所谓的用户验收测试，在 Rspec 中叫做 Feature Spec。这会模拟用户操作浏览器的行为，来对 Rails 进行整合性的测试。

> 在稍后的补充我们会提到也可以针对 Router、Controller 和 View 进行做单元测试，但是效益不大，因为用 Model Spec 和 Feature Spec 就可以大致涵盖我们的测试需要了。

# 4-2 Capybara 安装

Capybara 这个 gem 会用来搭配 Rspec 进行 Feature Spec 测试，请先安装：

Gemfile

```
  group :development, :test do
    gem 'rspec-rails'
+   gem 'capybara'
    gem 'byebug', platform: :mri
  end
```

执行 `bundle`

编辑 `spec/rails_helper.rb`

spec/rails_helper.rb

```
   # (略)
   require 'spec_helper'
   require 'rspec/rails'

+  require 'capybara/rails'
+  require 'capybara/rspec'
```

# 4-3 测试「一般费率」缴费流程

执行 `mkdir spec/features` 建立验收测试的目录

新增 `spec/features/guest_spec.rb`

```
require 'rails_helper'

feature "parking", :type => :feature do

  scenario "guest parking" do
    # Step 1

    visit "/"            # 浏览首页

    # save_and_open_page # 这会存下测试当时的 HTML 页面


    expect(page).to have_content("一般费率") # 检查 HTML 中要出现 "一般费率" 文字


    # Step 2

    click_button "开始计费" # 按这个按钮

    # Step 3:

    click_button "结束计费" # 按这个按钮

    # Step 4: 看到费用画面

    expect(page).to have_content("¥2.00")  # 检查 HTML 中要出现 ¥2.00 文字

  end

end
```

执行 `rspec spec/features/guest_spec.rb` 测试会通过。

你可以试试看稍微更动画面的文字，就会发现测试失败。例如拿掉开始计费按钮之类的。

说明一下：

1. `feature` 的作用等同于 `describe`，`scenario` 的作用等同于 `it`
2. 这里用了 `have_content` 来检查指定文字有没有出现在 HTML 里面。Web 应用的测试，没办法去完整比对 HTML 字串，因为字串比对差一个空白就不一样。如果说设计师稍微多加一个 `<br>` 就要改测试，这样就太累了，测试会太敏感。所以我们只能检查说 HTML 里面有出现我们希望要有的关键字。
3. 注意到我们不需要再重复测试金额对不对了，在前几章单元测试中我们已经确定这部分的元件正常。Feature Spec 的重点在于检查东西(Model + Controller + View)接起来有没有正常运作。
4. 被注解掉的 `save_and_open_page` 会存下测试当时的 HTML 页面，除错的时候可以使用。如果打开的话，跑测试会出现：

spec/features/guest_spec.rb

```
- # save_and_open_page
+ save_and_open_page
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/939nupNT9GxXu7ov5ELo_4-2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/939nupNT9GxXu7ov5ELo_4-2.png)

你会找到存下来的 HTML 档名，执行 `open tmp/capybara/capybara-xxxxxx.html` 就可以直接用默认浏览器打开看看。

# 4-4 测试注册流程

测试用户注册的流程：

spec/features/auth_spec.rb

```
require 'rails_helper'

feature "register and login", :type => :feature do

  scenario "register" do
    visit "/users/sign_up"  # 浏览注册页面


    expect(page).to have_content("Sign up")

    within("#new_user") do  # 填表单

      fill_in "Email", with: "foobar@example.com"
      fill_in "Password", with: "12345678"
      fill_in "Password confirmation", with: "12345678"
    end

    click_button "Sign up"
    # 检查文字。这文字是 Devise 默认会放在 flash[:notice] 上的

    expect(page).to have_content("Welcome! You have signed up successfully")

    # 检查数据库里面最后一笔真的有刚刚填的资料

    user = User.last
    expect(user.email).to eq("foobar@example.com")
  end

end
```

这里我们模拟用户填写表单送出的情况，用`fill_in`可以填入值。最后除了检查画面上有没有出现想要的关键字，也可以检查资料有没有正确存进数据库。

# 4-5 测试登入登出流程

测试用户登入登出的流程：

spec/features/auth_spec.rb

```
 feature "register and login", :type => :feature do

+  scenario "login and logout" do
+    user = User.create!( :email => "foobar@example.com", :password => "12345678")
+
+    visit "/users/sign_in"
+
+    within("#new_user") do
+      fill_in "Email", with: "foobar@example.com"
+      fill_in "Password", with: "12345678"
+    end
+
+    click_button "Log in"  # 点击登入按钮

+    expect(page).to have_content("Signed in successfully")
+
+    click_link "登出"  # 点击主选单的登出超连结

+    expect(page).to have_content("Signed out successfully")
+  end

  end
```

# 4-6 测试「短期费率」流程

要操作「短期费率」必须登入。但是登入刚刚已经测试过了，不需要再用 capybara 再走一次。Devise 有提供测试用的 `sign_in` 方法，请修改 `spec/rails_helper.rb`：

spec/rails_helper.rb

```
  RSpec.configure do |config|

+    config.include Devise::Test::ControllerHelpers, type: :controller
+    config.include Devise::Test::ControllerHelpers, type: :view
+    config.include Devise::Test::IntegrationHelpers, type: :feature

  # (略)
```

新增 `spec/features/short_term_spec.rb`

spec/features/short_term_spec.rb

```
require 'rails_helper'

feature "parking", :type => :feature do

  scenario "short-term parking" do
    user = User.create!( :email => "foobar@example.com", :password => "12345678")
    sign_in(user) # 这样就可以登入了


    visit "/"
    choose "短期费率"  # 选 radio button


    click_button "开始计费"

    click_button "结束计费"

    expect(page).to have_content("¥2.00")
  end

end
```

执行 `rspec spec/features/short_term_spec.rb` 测试通过。

这里用了 `choose` 来对 Radio 按钮做选择，在 capybara 中还有提供其他方法针对不同表单元件做操作，例如：

- check "核选方块名称"
- uncheck "核选方块名称"
- select "选项名称", :from => "下拉选单名称"
- attach_file 上传档案

详细用法请参考 [capybara](https://github.com/teamcapybara/capybara) 文件。

# 4-7 故意修改 Model API

做到这里，假设我们想回来修改一下 Model，这个 `calculate_amount` 其实可以放在回呼(callback)里面，这样只要 `save` 存进数据库时就会自动计算，不需要手动呼叫`calculate_amount`，也不需要检查 `amount`必填了。然后我们有点故意地顺便改个方法名称：

app/models/parking.rb

```
+  before_validation :setup_amount

-  def calculate_amount
+  def setup_amount

   # (略)
   def validate_end_at_with_amount
-    if ( end_at.present? && amount.blank? )
-      errors.add(:amount, "有结束时间就必须有金额")
-    end
```

修改 `spec/models/parking_spec.rb` 中把所有 `calculate_amount` 改成 `save`(有多处请都修改到)：

spec/models/parking_spec.rb

```
-        @parking.calculate_amount
+        @parking.save
```

> 之前提过测试案例跟案例之间是互相独立、不会互相影响的(这样测试失败时，才不用怀疑是不是被别的测试影响到)。每个测试案例，里面需要的物件会重新建立。跑自动化测试用的数据库跟开发用的不一样(在config/database.yml里面会设定`test`环境用的数据库，并用 `db/schema.rb` 的定义建立测试用数据库)。另外，如果你有 `save` 存进数据库的话，Rails 也会在跑完测试案例后，自动复原砍掉该测试案例新增的资料。

删除检查 amount 必填的测试：

spec/models/parking_spec.rb

```
-     it "is invalid without amount" do
-       parking = Parking.new( :parking_type => "guest",
-                              :start_at => Time.now - 6.hours,
-                              :end_at => Time.now)
-       expect( parking ).to_not be_valid
-     end
```

然后再跑一次 `rspec spec/models/parking_spec.rb` 测试全部通过。

但是呢，这个 Parking model 元件是好的。但是其实跑验收其实是烂的，因为我们改了 Parking model 的 API。

执行 `rspec spec/features/guest_spec.rb`：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/zfQoGpQ9e41sPYmLiFwA_4-3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/zfQoGpQ9e41sPYmLiFwA_4-3.png)

这告诉我们单元测试的局限性，验收测试帮助我们检查了整个系统整合起来是正常的。

修改 `app/controllers/parkings_controller.rb`，砍掉 `@parking.calculate_amount`：

app/controllers/parkings_controller.rb

```
   def update
     @parking = Parking.find(params[:id])
     @parking.end_at = Time.now
-    @parking.calculate_amount

     @parking.save!

    redirect_to parking_path(@parking)
  end
```

再跑一次 `rspec spec/features/guest_spec.rb` 就通过了。

刚刚都是跑单个测试档案，如果要跑全部测试，可以执行 `rake spec`

# 4-8 小结

刚刚都是跑单个测试档案，要一次跑全部的测试的话，请执行 `rake spec`

通常我们会在 git push 前，尽量跑过一次全部的测试。实际部署上 production 服务器前，也一定会执行 `rake spec` 检查所有测试都必须通过。一个项目如果有良好的测试涵盖，那么透过执行自动化测试可以大幅减少人工测试的时间，确保这次的修改一切功能正常，增加成功上线的把握。

至于验收测试什么时候写? 要写多少呢?

- 相对于单元测试，验收测试通常是在功能完成之后才撰写，主要的目的其实是做「回归测试(Regression Testing」，旨在检验软件原有功能在修改后是否保持正常，每次部署新版本上线前，会跑全部的测试做回归测试检查，看看有没有东西被弄坏了，是一种投资未来的测试。
- 单元测试通常是跟该功能一起由开发者完成，验收测试则会另外开任务，并可能由另一个开发者(或专门的测试工程师)来完成会更好。
- 撰写验收测试会花额外的时间，而且比较脆弱。因为页面流程一改、或是改个文案，测试就得跟着改。因此通常我们只会针对网站最常用的功能(Happy Path)，来撰写验收测试报资报酬率最高。
- 验收测试很难完全取代人工验证，因为有太多东西是很难验证的，例如 CSS、画面颜色、按钮位置等等。如果要做到自动检查画面完全一模一样，会耗费很大的维护成本。
- 因此相对于新创公司还在时常变动功能的软件，成熟期的软件比较会投资在完整的验收测试，特别是 B2B 领域，因为软件出错对客户造成的损失是很大的。

### 本节作业

##### [测试作业](https://fullstack.xinshengdaxue.com/assignments/42)：[作业二](https://fullstack.xinshengdaxue.com/tasks/282)

已有 26 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/282/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/282)

请完成停车计费流程的 Feature Spec 并贴上测试的结果。

# 5-1 目标

> 这一章依赖 [Web API 设计实作](https://fullstack.xinshengdaxue.com/courses/38/syllabus) 课程，如果你还没有完成，请先回去完成或先跳过。

跟上一章讲到验收测试，并且提到了自动化测试 HTML 的局限性。接下来我们来谈谈 Web API 的自动化测试。

和 HTML 不同，Web API 的 JSON 可以完全被程序自动验证(后端工程师欢呼!)。因此写自动化测试，可以完全取代用 Postman 手动测试的过程，连浏览器都不需要打开。

在前后端团队分离的公司里面(前端包括 iOS、Android 或 Web App)，所谓的后端工程师就是专门提供这些 Web API 给前端使用，并透过自动化测试来验证结果和保证质量。

# 5-2 安装 rspec-rails

接下来请回到 Web API 设计实作 课程的订票专案。

编辑 Gemfile

Gemfile

```
  group :development, :test do

+   gem 'rspec-rails'
    gem 'byebug', platform: :mri

end
```

执行 `bundle`

执行 `rails g rspec:install`

执行 `rm -rf test`

执行 `git add .` 和 `git commit -m "Add Rspec"`

# 5-3 测试注册 API

Web API 测试的重点是：

1. 检查回传的 HTTP 状态码
2. 检查回传的 JSON
3. 检查资料真的有被新建、修改或删除

执行 `mkdir spec/requests/`
新增 `spec/requests/auth_spec.rb`

spec/requests/auth_spec.rb

```
require 'rails_helper'

RSpec.describe "API_V1::Auth", :type => :request do

  example "register" do
    post "/api/v1/signup", params: { :email => "test2@example.com", :password => "12345678"}

    expect(response).to have_http_status(200)

    # 检查数据库中真的有存进去

    new_user = User.last
    expect(new_user.email).to eq("test2@example.com")

    # 检查回传的 JSON

    expect(response.body).to eq( { :user_id => new_user.id }.to_json )
  end

  example "register failed" do
    post "/api/v1/signup", params: { :email => "test2@example.com" }

    # 测试没有传密码，注册失败的情形

    expect(response).to have_http_status(400)

    expect(response.body).to eq( { :message => "Failed", :errors => {:password => ["can't be blank"]}  }.to_json )
  end
end
```

> `example` 和 `it` 的作用是一样的

执行 `rspec spec/requests/auth_spec.rb` 测试通过。

两个测试案例分别测试成功和失败的情形。

# 5-4 测试登入登出 API

编辑 `spec/requests/auth_spec.rb`

spec/requests/auth_spec.rb

```
  require 'rails_helper'

  RSpec.describe "API_V1::Auth", :type => :request do

  # (略)...


+  before do
+    @user = User.create!( :email => "test@example.com", :password => "12345678")
+  end
+
+  example "valid login and logout" do
+    post "/api/v1/login", params: { :email => @user.email, :password => "12345678" }
+
+    expect(response).to have_http_status(200)
+    # 检查回传的 JSON

+    expect(response.body).to eq(
+      {
+        :message => "Ok",
+        :auth_token => @user.authentication_token,
+        :user_id => @user.id
+      }.to_json
+    )
+
+    post "/api/v1/logout"
+    expect(response).to have_http_status(401)
+
+    post "/api/v1/logout", params: { :auth_token => @user.authentication_token }
+    expect(response).to have_http_status(200)
+    old_token = @user.authentication_token
+    @user.reload
+    # 检查登出后 `authentication_token` 会改掉

+    expect(@user.authentication_token).not_to eq(old_token)
+  end
+
+  example "invalid auth login" do
+    post "/api/v1/login", params: { :email => @user.email, :password => "xxx" }
+
+    # 检查登入失败回传 401

+    expect(response).to have_http_status(401)
+    expect(response.body).to eq(
+      { :message => "Email or Password is wrong" }.to_json
+    )
+  end

  end
```

两个测试案例测试登入成功和登入失败。

# 5-5 测试查询列车 API

新增 `spec/requests/train_spec.rb`

spec/requests/train_spec.rb

```
require 'rails_helper'

RSpec.describe "API_V1::Trains", :type => :request do

  before do
    @train1 = Train.create!( :number => "0822")
    @train2 = Train.create!( :number => "0603")
  end

  example "GET /api/v1/trains" do
    get "/api/v1/trains"

    expect(response).to have_http_status(200)

    expected_result = {
      "meta": {
        "current_page": 1,
        "total_pages": 1,
        "per_page": 30,
        "total_entries": 2,
        "next_url": nil,
        "previous_url": nil
      },
      "data": [
        { "number": @train1.number,
          "logo_url": nil,
          "logo_file_size": nil,
          "logo_content_type": nil,
          "available_seats": ["1A","1B","1C","2A","2B","2C","3A","3B","3C","4A","4B","4C","5A","5B","5C","6A","6B","6C"],
          "created_at": @train1.created_at },
        { "number": @train2.number,
          "logo_url": nil,
          "logo_file_size": nil,
          "logo_content_type": nil,
          "available_seats": ["1A","1B","1C","2A","2B","2C","3A","3B","3C","4A","4B","4C","5A","5B","5C","6A","6B","6C"],
          "created_at": @train2.created_at }
      ]
    }
    expect(response.body).to eq( expected_result.to_json )
  end

  example "GET /api/v1/trains/{train_number}" do
    get "/api/v1/trains/0822"

    expect(response).to have_http_status(200)

    expected_result = { "number": @train1.number,
          "logo_url": nil,
          "logo_file_size": nil,
          "logo_content_type": nil,
          "available_seats": ["1A","1B","1C","2A","2B","2C","3A","3B","3C","4A","4B","4C","5A","5B","5C","6A","6B","6C"],
          "created_at": @train1.created_at }

    expect(response.body).to eq( expected_result.to_json )
  end

end
```

# 5-6 测试查询订票、修改定票、取消订票 API

新增 `spec/requests/reservation_spec.rb`

spec/requests/reservation_spec.rb

```
require 'rails_helper'

RSpec.describe "API_V1::Reservations", :type => :request do

  before do
    @train1 = Train.create!( :number => "0822")
    @train2 = Train.create!( :number => "0603")

    @user = User.create!( :email => "test@example.com", :password => "12345678" )
    @reservation = Reservation.create!( :train_id => @train1.id, :seat_number => "1A",
                                        :customer_name => "foo", :customer_phone => "12345678" )
  end

  example "GET /api/v1/reservations/{booking_code}" do
    get "/api/v1/reservations/#{@reservation.booking_code}"

    expect(response).to have_http_status(200)
    expect(response.body).to eq( { :booking_code => @reservation.booking_code,
                                   :train_number => @reservation.train.number,
                                   :train => {
                                     :number => @train1.number,
                                     :logo_url => nil,
                                     :logo_file_size => nil,
                                     :logo_content_type => nil,
                                     :available_seats => ["1B","1C","2A","2B","2C","3A","3B","3C","4A","4B","4C","5A","5B","5C","6A","6B","6C"],
                                     :created_at => @train1.created_at
                                   },
                                   :seat_number => @reservation.seat_number,
                                   :customer_name => @reservation.customer_name,
                                   :customer_phone => @reservation.customer_phone
                                  }.to_json )
  end

  example "DELETE /api/v1/reservations/{booking_code}" do
    delete "/api/v1/reservations/#{@reservation.booking_code}"

    expect(response).to have_http_status(200)

    expect(response.body).to eq( { :message => "已取消定位" }.to_json )
    expect( Reservation.count ).to eq(0)
  end

  example "PATCH /api/v1/reservations/{booking_code}" do
    patch "/api/v1/reservations/#{@reservation.booking_code}", :params => { :customer_name => "bar", :customer_phone => "987654321" }

    expect(response).to have_http_status(200)

    expect(response.body).to eq( { :message => "更新成功" }.to_json )

    @reservation.reload

    expect( @reservation.customer_name ).to eq("bar")
    expect( @reservation.customer_phone ).to eq("987654321")
  end

end
```

# 5-7 测试订票 API

编辑 `spec/requests/reservation_spec.rb`

spec/requests/reservation_spec.rb

```
+  describe "POST /api/v1/reservations" do
+    example "success without auth_token" do
+      post "/api/v1/reservations", :params => { :train_number => @train1.number, :seat_number => "1B",
+                                                :customer_name => "zoo", :customer_phone => "55555555"}
+
+      expect(response).to have_http_status(200)
+
+      created_reservation = Reservation.last
+
+      expect(response.body).to eq( { :booking_code => created_reservation.booking_code,
+                                     :reservation_url => api_v1_reservation_url(created_reservation.booking_code) }.to_json )
+
+      expect(created_reservation.customer_name).to eq("zoo")
+      expect(created_reservation.customer_phone).to eq("55555555")
+      expect(created_reservation.user_id).to eq(nil)
+    end
+
+    example "success with auth_token" do
+      post "/api/v1/reservations", :params => { :auth_token => @user.authentication_token,
+                                                :train_number => @train1.number, :seat_number => "1B",
+                                                :customer_name => "zoo", :customer_phone => "55555555"}
+
+      expect(response).to have_http_status(200)
+
+      created_reservation = Reservation.last
+
+      expect(response.body).to eq( { :booking_code => created_reservation.booking_code,
+                                     :reservation_url => api_v1_reservation_url(created_reservation.booking_code) }.to_json )
+
+      expect(created_reservation.customer_name).to eq("zoo")
+      expect(created_reservation.customer_phone).to eq("55555555")
+      expect(created_reservation.user_id).to eq(@user.id)
+    end
+
+    example "failed" do
+      post "/api/v1/reservations", :params => { :train_number => @train1.number, :seat_number => "1A", :customer_name => "zoo", :customer_phone => "55555555"}
+
+      expect(response).to have_http_status(400)
+
+      expect(response.body).to eq( { :message => "订票失败", :errors => { :seat_number => ["has already been taken"] } }.to_json )
+    end
+  end
```

订票其实有三种情况，分别是 1. 有登入带 `auth_token` 订票 2. 没登入订票 3. 订票失败(因为座位重复)

> 在 Web API 课程中比较早完成的同学，做到这里你可能会测试失败，因为之前在 `app/models/reservation.rb` 中是写 `belongs_to :user` 这表示 `user` 是必填，需要改成 `belongs_to :user, :optional => true` 让 user 是选填。

# 5-8 测试查询我全部的订单 API

编辑 `spec/requests/reservation_spec.rb`

spec/requests/reservation_spec.rb

```
+  describe "GET /api/v1/reservations" do
+    example "failed" do
+      get "/api/v1/reservations", :params => {  }
+      expect(response).to have_http_status(401)
+    end
+
+    example "success" do
+
+      @reservation1 = Reservation.create!( :user_id => @user.id, :train_id => @train1.id, :seat_number => "1B",
+                                           :customer_name => "foo", :customer_phone => "12345678" )
+      @reservation2 = Reservation.create!( :user_id => @user.id, :train_id => @train1.id, :seat_number => "1C",
+                                           :customer_name => "foo", :customer_phone => "12345678" )
+
+      get "/api/v1/reservations", :params => { :auth_token => @user.authentication_token }
+
+      expect(response).to have_http_status(200)
+      expect(response.body).to eq( { :data => [
+                                      { :booking_code => @reservation1.booking_code,
+                                        :train_number => @reservation1.train.number,
+                                         :train => {
+                                           :number => @train1.number,
+                                           :logo_url => nil,
+                                           :logo_file_size => nil,
+                                           :logo_content_type => nil,
+                                           :available_seats => ["2A","2B","2C","3A","3B","3C","4A","4B","4C","5A","5B","5C","6A","6B","6C"],
+                                           :created_at => @train1.created_at
+                                         },
+                                         :seat_number => @reservation1.seat_number,
+                                         :customer_name => @reservation1.customer_name,
+                                         :customer_phone => @reservation1.customer_phone
+                                      },
+                                    { :booking_code => @reservation2.booking_code,
+                                        :train_number => @reservation2.train.number,
+                                         :train => {
+                                           :number => @train1.number,
+                                           :logo_url => nil,
+                                           :logo_file_size => nil,
+                                           :logo_content_type => nil,
+                                           :available_seats => ["2A","2B","2C","3A","3B","3C","4A","4B","4C","5A","5B","5C","6A","6B","6C"],
+                                           :created_at => @train1.created_at
+                                         },
+                                         :seat_number => @reservation2.seat_number,
+                                         :customer_name => @reservation2.customer_name,
+                                         :customer_phone => @reservation2.customer_phone
+                                      }
+                                  ] }.to_json )
+
+
+    end
+  end
```

这里测试两种情况 1. 没有登入带 `auth_token` 的话，会失败 2. 成功查询我的订票

# 5-9 测试查询和更新我的资料 API

新增 `spec/requests/user_spec.rb`

spec/requests/user_spec.rb

```
require 'rails_helper'

RSpec.describe "API_V1::Users", :type => :request do

  before do
    @user = User.create!( :email => "test@example.com", :password => "12345678")
  end

  example "GET /me" do
    get "/api/v1/me", params: { :auth_token => @user.authentication_token }

    expect(response).to have_http_status(200)

    @user.reload

    expect(response.body).to eq(
       {
        :email => @user.email,
        :avatar => @user.avatar,
        :updated_at => @user.updated_at,
        :created_at => @user.created_at
      }.to_json )
  end

  it "PATCH /me" do
    # 上传档案，请放一个图档在 spec/fixtures 目录下

    file = fixture_file_upload("#{Rails.root}/spec/fixtures/rails.png", "image/png")

    patch "/api/v1/me", params: { :auth_token => @user.authentication_token, :email => "test2@example.com", :avatar => file }

    expect(response).to have_http_status(200)

    expect(response.body).to eq( { :message => "OK" }.to_json )

    @user.reload

    expect(@user.email).to eq("test2@example.com")
    expect(@user.avatar).not_to eq(nil)
  end

end
```

### 本节作业

##### [测试作业](https://fullstack.xinshengdaxue.com/assignments/42)：[作业三](https://fullstack.xinshengdaxue.com/tasks/283)

已有 22 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/283/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/283)

请至少完成注册 API 的 Request Spec 并贴上测试的结果。

# 总结与补充

测试是一门需要长期练习的技能，才能够抓到测试的重点和关键，需要多思考哪些地方要写测试、要测什么案例。总结一下这堂课学会的：

1. 单元测试：可以协助我们在写代码时检查程式的正确性，快速得到反馈，进行重构
2. 用户验收测试：主要作用是回归测试，投资未来在改代码时，不会搞坏本来的功能
3. Web API测试：可以完整测试 API 系统的正确性，免去手动测试的繁琐

关于测试的豆知识非常多，如果你已经能抓到测试的诀窍，可以继续参考以下资源：

- [ihower 老师的 Ruby on Rails 实战圣经](https://ihower.tw/rails/testing-cn.html) (請下載PTT投影片)
- [xdite 老师的 RSpec on Rails 101](https://www.gitbook.com/book/xdite/rspec-101/details)
- [thoughtbot 的 Testing Rails](https://gumroad.com/l/testing-rails)
- [Everyday Rails Testing with RSpec](https://leanpub.com/everydayrailsrspec)
