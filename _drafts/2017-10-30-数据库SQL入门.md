---
layout: post
title: "数据库SQL入门"
date: 2017-10-30
tags:
    Rails
    教材
---
| 什么是数据库                                   |      |
| ---------------------------------------- | ---- |
| [**  1. 什么是数据库？](https://fullstack.xinshengdaxue.com/posts/1411) |      |
| [**  2. 关系型数据库的特性一: Schema](https://fullstack.xinshengdaxue.com/posts/1412) |      |
| [**  3. 关系型数据库的特性二: SQL 标准语法](https://fullstack.xinshengdaxue.com/posts/1413) |      |
| [**  4. 关系型数据库的特性三: ACID](https://fullstack.xinshengdaxue.com/posts/1414) |      |

| 基础 SQL                                   |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  5. SQL 语言: DDL](https://fullstack.xinshengdaxue.com/posts/1415) |                                          |
| [**  6. SQL 语言: DML](https://fullstack.xinshengdaxue.com/posts/1416) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1416#task) |

| 数据库设计                                    |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  7. 数据库规范化 Normalization](https://fullstack.xinshengdaxue.com/posts/1417) |                                          |
| [**  8. 数据库设计实务](https://fullstack.xinshengdaxue.com/posts/1418) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1418#task) |

| 进阶 SQL                                   |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  9. Joining](https://fullstack.xinshengdaxue.com/posts/1419) |                                          |
| [**  10. Functions](https://fullstack.xinshengdaxue.com/posts/1420) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1420#task) |
| [**  11. NoSQL 简介](https://fullstack.xinshengdaxue.com/posts/1421) |                                          |
| [**  12. SQL 参考资料和更多教程](https://fullstack.xinshengdaxue.com/posts/1422) |                                          |

# 1. 什么是数据库？

数据库的作用就是为了保存数据。

程序运行时的数据会放在内存之中，但是只要程序结束或关机就会消失了。需要永久保存数据的话，就会存放在硬盘上。我们在编程基础课程曾经学过，可以利用档案来将数据放在硬盘上。不过如果数据又多又杂，存成档案要怎么命名、档案要用什么格式才方便之后查询，这些都是问题。

数据库就是为了解决这些问题而发明了，除了可以保存大量数据，数据库还提供了方便的查询(Query)机制，以及提供 CRUD(Create, Read, Update, Delete) 操作。

### 关系型数据库

数据库有很多种，其中一种叫做「关系型数据库」 (RDBMS: Relational Database Management System) 是目前最普遍最多人使用的一种数据库。这种数据库包括开源的 SQLite、MySQL、PostgreSQL，以及需要付费的 Oracle、Microsoft SQL Server 等等，简单介绍如下：

#### [SQLite3](https://www.sqlite.org/)

SQLite 是一套轻量级的关系型数据库，也是 Rails 开发时默认的数据库。这种数据库并不是单独的服务器，而是会被集成在我们程序(也就是 Rails)之中，它的一个数据库就是一个档案，在 Rails 中也就是 `db/development.sqlite3` 这个档案。

SQLite 主要是单机用途，在行动装置、手机上比较常使用，并不适合多人连线使用的场景。因此在实际部署 Rails 到服务器时，我们会需要换成 PostgreSQL 或 MySQL 等数据库服务器。

Mac 本身就有内建 SQLite3，请下载 [DB Browser for SQLite](http://sqlitebrowser.org/) 这个 GUI 软件，就可以打开 SQLte3 的数据库档案。

#### [MySQL](https://www.mysql.com/)

MySQL 是目前最流行的开源数据库，容易上手、资源多、效能好、支援的厂商多，是最多网络公司使用的数据库。跟 SQLite3 不同，这是一个数据库服务器，除了安装还必须要执行 MySQL 服务器跑在背景，要连线 MySQL 也必须提供数据库的帐号密码。

Mac 上用 `brew install mysql` 就会安装 MySQL，推荐再安装 [Sequel Pro](https://www.sequelpro.com/) 这套 GUI 软件。

#### [PostgreSQL](https://www.postgresql.org/)

PostgreSQL 也是非常流行的开源数据库，经常与 MySQL 相提并论。因为是 Heroku 默认的数据库，所以在全栈营中大家比较熟悉。和 MySQL 相比，PostgreSQL 的功能比较多，但是在超级大量数据的场景下，不如 MySQL 有更多的的分布式服务器经验。

Mac 上用 `brew install postgresql` 就会安装 PostgreSQL 服务器。GUI 的话，可以考虑安装 [pgAdmin](https://www.pgadmin.org/)。

#### Oracle 和 MS SQL Server

这两家公司提供的数据库系统，则是需要付费的。通常是非软件开发专业的大型企业(例如银行、保险业等等)会采购的产品。这种需要付费的数据库有更好的自调优功能。

# 2. 关系型数据库的特性一: Schema

在关系型数据库中，有一些共通的特性，第一个就是 Schema 纲要：

### Schema 纲要

所谓的 Schema 纲要就是使用数据库存数据前，需要先定义 Tables(表) 和 Columns(字段)：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Yx5LyN5zSAexfpThkpxk_1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Yx5LyN5zSAexfpThkpxk_1.png)

例如在这张 Table，有 id、name、capacity、user_id 等字段，其中每一行(row)就一笔数据(data)。

相信大家用过试算表(Microsoft Excel 或 Apple Numbers)，这跟试算表看起来蛮像的：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/O1cY2sh1RTCiqniaNGj2_2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/O1cY2sh1RTCiqniaNGj2_2.png)

在试算表中，每一格都可以随便你填什么，但是 Schema 纲要不一样。我们需要定义数据型别(Data Type)。每个字段(Column)都要指定格式，只有符合格式才能存进数据库。不同数据库的数据类型大同小异，大体上都有：

- 字符串：varchar 或 text。varchar 默认是 255 字符、text 默认是 65535 字符。如果你要开一个字段来存长篇文章，text 可能会不够存，需要在额外指定长度。
- 数字: Integer, Decimal, Float
- Blob 二进制: 可以存放档案。但是通常不建议把档案直接塞数据库，一来数据库塞太大不容易备份和管理、二来没有什么好处，因为你也没办法针对二进制档案进行条件搜寻和过滤。人们对于读档案也有心理准备会比较慢。所以通常只会在数据库里面纪录档案的 metadata 例如档名、大小、MimeType 等等，而实际的档案则放在档案系统上，或是上传到七牛或AWS S3等空间。
- Boolean 布林
- Date 日期
- Time 时间
- Datetime 日期时间

在 Rails Migration 之中，就是在定义这些表的字段是什么格式，例如：

```
create_table :events do |t|
  t.string :name
  t.text   :description
  t.integer :capacity
  t.integer :user_id, :null => false

  t.timestamps
end
```

在Rails 实战圣经有一份[对照表](https://ihower.tw/rails/migrations-cn.html#sec2)。Rails 会根据数据库的不同，自动对应使用不同的数据型态。

除了定义 Data Type，你还可以在 Schema 中定义限制 (constraint)，最基本就限制是 `NOT NULL` 必填不能为空。

数据库还可以设定更多数据验证，不过你会发现这跟我们在 Rails model 中的 validations 的作用是一样的。所以通常我们偏好在 Rails 里面做验证，而不是在数据库这层做。优缺点是：

1. 在 Rails 做比较有弹性，可以用 Ruby 来写验证逻辑
2. 在 DB 层做是硬条件，无法跳过这个验证

早期的数据库非常重视 Data/Entity Integrity 资料验证，这是因为早期的数据库用户，就是直接操作数据库。但是对近年来的网络公司来说，用户不会直接操作数据库，而是都会经过网站应用服务器(例如 Rails)，用我们写好的功能间接地使用到数据库，因此我们可以在应用层验证好数据即可。

# 3. 关系型数据库的特性二: SQL 标准语法

关系型数据库都支援使用一种叫做 SQL (Structured Query Language) 的结构化查询语言。我们会用这种语法来操作数据库，例如：

```
INSERT INTO events VALUES ("RubyConf", 100);
```

这个 SQL 句会插入一笔数据到 events 表。

```
SELECT * FROM events;
```

这个 SQL 句告诉数据库拿出 `events` 表的所有数据。在 Rails 之中虽然我们没有直接撰写 SQL 句子，其实是 Rails 内部是自动帮我们转换好了，例如刚刚的句子，我们是写这样的 Ruby 代码：

```
Event.create( :name => "RubyConf", :capacity => 100)
```

和

```
Event.all
```

在 Rails 内部则会自动转换成 SQL 句，来向数据库进行操作。在稍后的章节我们会详细介绍这个 SQL 语言，你必须进一步了解 SQL 语言，才能够完整了解 Rails 是如何操作数据库的。

# 4. 关系型数据库的特性三: ACID

关系型数据库的另一个重要的特性是 [ACID](https://en.wikipedia.org/wiki/ACID)，也就是
Atomicity, Consistency, Isolation, Durability。在解释个别的意义前，我们先介绍一个关系型数据库的功能，叫做 Transaction 事务。

请想像这样的场景：当你再做银行转帐时，A 的馀额会减少、B 的馀额会增加，如果这是两个 SQL 操作的话，我们如何能保证这两个 SQL 操作必须是一起成功的？不能发生 A 钱变少了，但是 B 没有收到钱的情况。或是考虑一个更极端的场景，如果你和别人同时同一秒钟互相转帐，数据库会不会算错馀额？

要达成这种跨 Tables 多个 SQL 操作必须同时完成(或失败)的需求，就必须用上 Transaction 事务。语法是用 `BEGIN;` 和 `COMMIT;` 把 SQL 句包裹在一起，例如：

```
BEGIN;
  INSERT INTO histories (user_id, amount) VALUES (1, -100);
  INSERT INTO histories (user_id, amount) VALUES (2, 100);
  UPDATE accounts SET balance=200 WHERE id=1;
  UPDATE accounts SET balance=300 WHERE id=2;
COMMIT;
```



> 每个 SQL 句必须用分号 `;` 代表结束

这样 `BEGIN;` 和 `COMMIT;` 中间的所有 SQL 句，就会一起递交给数据库，要么一起成功、要么一起失败。

非常多场景会用到这个 Transaction 功能，来保证数据的正确性。在 Rails 中，每个 model 的 `save` 其实都会用 Transaction 包起来，包括 model 里面的所有 callback 都会在同一个 Transaction 事务里面。

如果是跨 model 的话，你也可以用 `ActiveRecord::Base.transaction` 来包裹 `Transaction` 事务，例如：

```
ActiveRecord::Base.transaction do
  A.save
  B.save
  C.save
end
```

#### ACID

ACID 其实就是在说明 Transactin 的能耐，以下取自 [wikipedia](https://zh.wikipedia.org/zh-cn/ACID):

- Atomicity 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- Consistency 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- Isolation 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- Durability 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

透过 Transactions 事务功能，关系型数据库可以在多人连线同时执行多个 SQL 句的情况下，也可以保证数据最后的正确性。

# 5. SQL 语言: DDL

关系型数据库使用 SQL(Structured Query Language) 语言，每个 SQL 句子叫做 SQL Query 或 SQL Statement。我们可以用 CLI 指令或 GUI 软件，用 SQL 语言对数据库进行查询和操作。

SQL 分成 DDL 和 DML 两种，都是用分号 `;` 结尾。

### Data Definition Language, DDL

如何告诉数据库去定义 Schema 纲要? 也是使用 SQL 语法，这类型的 SQL 就做 DDL(Data Definition Language)

#### 建立、删除和更名数据库

每家方法不太一样，建议可以用 GUI 进行即可。PostgreSQL 和 MySQL 都是数据库服务器，可以管理很多不同数据库，例如你可以架很多 Rails 网站，但是只需要一个数据库服务器，里面建立不同数据库即可。

建立数据库时，请注意选择编码(Encoding)。PostgrSQL 可用 utf-8、MySQL 可用 utf8mb4 编码。

在 SQLite3 的话，直接在 Terminal 用 CLI 指令 `sqlite3 your_db_name.db` 就会打开(或产生)
一个数据库档案。直接砍掉档案就是删除数据库。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bLhkItQeSja1UV9DG3qx_3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/bLhkItQeSja1UV9DG3qx_3.png)

> MySQL 的话，指令式 `mysql -u root -p`。PostgreSQL 的指令是 `psql <database_name>`。

以下用 SQLite3 示范。

#### 建立 Table

以下 SQL 会建立 `events` 表，并新增三个字段 `name`, `capacity` 和 `date`。默认是字段允许 `NULL`，除非加上 `NOT NULL`。

```
CREATE TABLE events (name VARCHAR(50) NOT NULL, capacity INTEGER, date DATE);
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/SZa33bJmSyCvn55aW0ag_4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/SZa33bJmSyCvn55aW0ag_4.png)

你可以用 SQLite3 的 GUI [DB Browser for SQLite](http://sqlitebrowser.org/) 打开 `demo.db` 这个档案：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/1sJX5xEtSOeIEZFBFnri_5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/1sJX5xEtSOeIEZFBFnri_5.png)

用 GUI 进行 Schame 操作会比较简单，在 Rails 的话，则是统一都用 Migrations 机制来变更 Schema。

#### 修改 Table

- 改名 Table，例如 `ALTER TABLE persons RENAME TO people;`
- 新增字串，例如 `ALTER TABLE people ADD COLUMN status VARCHAR(50);`
- 修改和移除字段：SQLite3 没支援，需要开一个新 table 然后把资料复制过去

#### 删除 Table

语法是 `DROP TABLE IF EXISTS people;`

通常不会让终端使用者可以动态新建 table 和修改 schema。数据库的 Schema 比较像是你程式的一部分，我们的代码会依赖于 Schema 设计。另外也有效能的考量，变更 Schema 是很耗时的操作，特别是数据量已经很多的情况下，修改 Schema 会锁住整个 Table 影响网站运作。

#### Migration 机制

数据库 Schema 不是一成不变的，会随着软件变更升级也会有修改的需要。因此，在一些软件中会实作一种叫做 Migration 的功能，透过 Schema Migration 纪录目前的 schema 版本。开机的时候检查目前程式的版本和数据库里面的版本是否相同，不同的话，执行 Migration 更新 schema。这些 Migration 代码也会放进版本控制系统 Git 里面，这样整个团队的开发者和不同服务器上，都可以利用 Migration 来一致管理 Schema。

这个功能就是大家熟悉的 Rails Migration。

# 6. SQL 语言: DML

操作数据的 SQL 就是 DML(Data Manipulation Language)，也就是做 CRUD 的操作。

### 新增资料

以下 SQL 会新增数据：

`INSERT INTO events (capacity, name) VALUES (200, "JSConf");`

> 这个对应的 Rails 语法是 `Event.create( :capacity => 200, :name => "JSConf")`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/c4oCxBgGQiaJPiT156QE_6.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/c4oCxBgGQiaJPiT156QE_6.png)

插入多笔 `INSERT INTO events (capacity, name) VALUES (300, "COSCUP"), (300, "OSDC.TW");`

接下来你也可以在 GUI 的视窗中，练习输入 SQL 句：

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Z62NhfgOTTuHsQmZc8Og_7.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/Z62NhfgOTTuHsQmZc8Og_7.png)

### 查询资料

捞全部 events 资料 `SELECT * FROM events;`

> 对应的 Rails 语法是 `Event.all`

只捞出指定的字段 `SELECT name, capacity FROM events;`

> 对应的 Rails 语法是 `Event.select(:name, :capacity).all`

字段前段可以补上表的名称 `SELECT events.name, events.capacity FROM events;`

递增排序 `SELECT name, capacity FROM events ORDER BY capacity;` 或 `SELECT name, capacity FROM events ORDER BY capacity ASC;`

递减排序 `SELECT name, capacity FROM events ORDER BY capacity DESC;`

分页 `SELECT name, capacity FROM events ORDER BY capacity DESC, name ASC LIMIT 20 OFFSET 20;`

### 修改资料

以下 SQL 会修改数据

`UPDATE events SET capacity=10;` 这会修改 events table 的所有数据把 capacity 改成 10

> 对应的 Rails 语法是 `Event.update_all( :capacity => 10 )`

`UPDATE events SET capacity=100 WHERE name="RubyConf";` 用 WHERE 可以指定只有修改 name 是 "RubyConf" 的数据

> 对应的 Rails 语法是 `Event.where( :name => "RubyConf" ).update_all( :capacity => 100)`

`UPDATE events SET capacity=100, name="RubyConf 2015" WHERE name="RubyConf";` 修改 capacity 和 name

> 对应的 Rails 语法是 `Event.where( :name => "RubyConf" ).update_all( :capacity => 100, :name => "RubyConf 2015" )`

在 Rails 中，比较常见只修改一笔，例如：

```
@event = Event.find(123)
@event.update( :capacity => 200)
```

对应的 SQL 会是

```
SELECT * FROM events WHERE id = 123;
UPDATE events SET capacity=200 WHERE id=123;
```

### 删除数据数据

以下 SQL 会删除数据

`DELETE FROM events;` 会全部删除

> 对应的 Rails 语法是 `Event.delete_all`

`DELETE FROM events WHERE name="RubyConf";` 只删除

> 对应的 Rails 语法是 `Event.where( :name => "RubyConf" ).delete_all`

在 Rails 中，比较常见只删除一笔，例如：

```
@event = Event.find(123)
@event.destroy
```

对应的 SQL 会是

```
SELECT * FROM events WHERE id = 123;
DELETE FROM events WHERE id = 123;
```



### 查有哪些 tables 和 columns

各家语法不一样：

- SQLite3: `.tables` 和 `.schema tablename`
- MySQL: `show tables` 和 `describe tablename`
- PostgreSQL: `\dt` 和 `\d tablename`

这些查询在 Rails 启动的时后，其实也会帮我们做。你可以在 rails console 中对 model 执行 `columns` 方法，例如 `Event.columns` 就会反射出这个表有哪些字段。

### 条件查询

以下是一些范例来做条件查询：

- `SELECT * FROM events WHERE date = '2015-03-15';`
- 条件或 `SELECT * FROM events WHERE date = '2015-03-15' OR date = '2015-03-16';`
- 某个区间 `SELECT * FROM events WHERE date BETWEEN '2015-03-15' AND '2015-03-30';`
- 条件且 `SELECT * FROM events WHERE date = '2015-03-15' AND capacity >= 100;`
- 模糊比对 `SELECT * FROM events WHERE name LIKE '%Ruby%';`
- 不可为空 `SELECT * FROM events WHERE description IS NOT NULL;`

条件比对时，小心大小写(Case insensitive)不同数据库默认不同。MySQL 是不分大小写(case insensitive)、PostgreSQL 会区分大小写(case sensitive)。

### Indexes 索引

`WHERE`、`ORDER` 条件字段最好都要加上数据库索引(Index)，例如范例中的 `date` 字串，如果没有索引的话，会是 O(n) 的效率(这里又叫作 Full Table Scan，需要扫过整个表的意思)，数据库越多数据会越慢。如果有索引的话，会是 O(logn)，在数据量大的情况差非常多。

模糊搜寻 LIKE 查询都会变成 Full Table Scan，没办法用数据库索引，百宝箱教过的 [ransack](https://github.com/activerecord-hackery/ransack) gem 搜寻是用 LIKE 语法，在几万笔数据内效能还能接受，再大的数据量就需要用另外的 Full-Text Searching 引擎了，例如 [ElasticSearch](https://www.elastic.co/)。

加索引的 SQL 语法：

- 加索引 `CREATE INDEX events_user_id_idx ON events(user_id);`
- 索引并且值是唯一 `CREATE UNIQUE INDEX xxx_idx ON xxx(yyy);`

在 Rails Migration 中要加上索引的话，可用 `add_index` 语法，例如 `add_index :events, :date`。

> 将字段设成 unique 跟设成 unique index 是一样的

当然也不是所有字段通通都加上索引就好了，因为加索引会让写入数据变慢(因为要建立索引，也会增加储存空间)，但是查询时会加快。

### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/66)：[作业一](https://fullstack.xinshengdaxue.com/tasks/350)

已有 38 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/350/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/350)

假设我们有一个 Table 叫做 people，里面有字段 id, first_name, last_name, gender (值可能是 M 或 F), birthday

- 请写出 SQL 捞出所有资料
- 请写出 SQL 捞出所有男生
- 请写出 SQL 插入一笔资料
- 请写出 SQL 更新 id 为 3 的资料，将姓名修改成你的名字
- 请写出 SQL 删除 id 为 4 的资料

# 7. 数据库规范化 Normalization

一个数据库会包含很多张表，那么这些表要如何因应需求来做设计呢？该设计哪些表？该设计哪些字段？这两节会告诉大家。

[数据库规范化(Normalization)](https://zh.wikipedia.org/zh-cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96)是数据库设计的一个非常重要的基本概念，目的是要去除重复的数据，增加数据的一致性。实际的作法是会将重复的字段，抽出来变成另一个新的表。

规范化还分成一阶规范化、二阶规范化、三阶规范化、DK/NF规范化等等不同级别，一般来说我们的应用软件会做到二阶或三阶规范化。

让我们用实际的例子来看：假设我们要设计一个场景是纪录「使用者 User」参与多个「活动 Event」

### 未规范化

| user name | user city | zipcode | event 1  | event 1 date | event 2 | event 2 date | event 3 | event 3 date |
| --------- | --------- | ------- | -------- | ------------ | ------- | ------------ | ------- | ------------ |
| ihower    | hsinchu   | 300     | RubyConf | 2015/9/11    | JSConf  | 2015/5/1     | CSSConf | 2016/1/1     |
| john      | taipei    | 100     | RubyConf | 2015/9/11    |         |              |         |              |

这种 Table 设计缺点很多：

1. ihower 如果需要参加第四个活动，就必须变更 Table 的 Schema 增加更多字段。但是变更 Scmema 是一件成本很高的事情 :(
2. john 没有参加这么多活动，多馀的字段都是 NULL，对数据库来说是浪费空间
3. ihower 跟 john 都有参加 RubyConf，但是 2015/9/11 这个活动日期重复存了。而且如果活动改日期，表示这些值都要改

### 一阶: 移除重复语意的 columns

刚刚的 event 1, event 1 date, event 2, event 2 date, event 3, event 3 date 俩俩都是重复的，让我们消灭它们：

| user name | user city | zipcode | event    | event date |
| --------- | --------- | ------- | -------- | ---------- |
| ihower    | hsinchu   | 300     | RubyConf | 2015/9/11  |
| ihower    | hsinchu   | 300     | JSConf   | 2015/5/1   |
| ihower    | hsinchu   | 300     | CSSConf  | 2016/1/1   |
| john      | taipei    | 300     | RubyConf | 2015/9/11  |

缺点:

- 相比于没有规范化的，现在新报名不需要修改 Schame 了
- 但是重复的资料更多，包括用户数据和活动数据

### 二阶: 移除重复语意的 row

接下来需要拆表了，一口气我们拆成三张表：users 表、events 表、registration 表，并且 users 和 events 要加上可识别的 id 字段。

> 相信对 Rails 已经很熟悉的同学，这就是 User model 和 Event model 透过 Registration model 来达成多对多关系。

#### users table

| user id | user name | user city | zipcode |
| ------- | --------- | --------- | ------- |
| 1       | ihower    | hsinchu   | 300     |
| 2       | john      | taipei    | 100     |

#### events table

| event id | event    | event date |
| -------- | -------- | ---------- |
| 1        | RubyConf | 2015/9/11  |
| 2        | JSConf   | 2015/5/1   |
| 3        | CSSConf  | 2016/1/1   |

#### registrations table

| user id | event id | register_at         |
| ------- | -------- | ------------------- |
| 1       | 1        | 2016-03-16 12:00:00 |
| 1       | 2        | 2016-03-16 12:30:00 |
| 1       | 3        | 2016-03-17 12:00:00 |
| 2       | 1        | 2016-03-18 12:00:00 |

这好多了，看起来没有重复的资料了，如果要改 user 或 event 的数据，只需要改一个地方。

但是还有一个小地方可以改进，让我们继续看下去：

### 三阶: 移除不依赖主 ID 的资料

在 users table 中，city 名字其实只跟 zipcode 相关，跟 user id 没关系，因此这个 city 可以拆出来。在 users table 中只需要留着 zipcode 就好了。

#### users table

| user id | user name | zipcode |
| ------- | --------- | ------- |
| 1       | ihower    | 300     |
| 2       | john      | 300     |

#### zipcodes table

| zipcode | user city |
| ------- | --------- |
| 300     | hsinchu   |
| 100     | taipei    |

### 小结

规范化让数据不会重复和高度一致性，节省空间、增加修改数据时的效率、避免数据不一致的错误。

# 8. 数据库设计实务

数据库规范化看起来好像很难，所幸我们实务设计的时候，并不是从一阶二阶三阶这样慢慢思考的，而是用 Model 的关系来思考。

### 关联设计 Associations

在传统数据库课程中，会使用 [ER diagram](https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model) (entity-relationship model) 这种描述关联的标准图表。

> [ERD “Crow’s Foot” Relationship Symbols Cheat Sheet](http://www.vivekmchawla.com/erd-crows-foot-relationship-symbols-cheat-sheet/)

在这种图表中，定义了一对一关系、一对多关系、多对多关系等的图表。也就是在 Rails 中我们已经熟悉只用 `has_one`, `has_many`, `belongs_to` 等。

### Primary Key 主键

所谓的 Primary Key 主键就是可以唯一识别的字段，在 Rails 中会默认产生一个字段是 `id`。

这个主键有一些特性：

- 不能 NULL 也不能重复
- 最常见是 Simple ID Column Key (单一 column) 的设计。但也可以是 Compound/Composite Key (多个 columns 组成一个 primary key)，但 Rails 不支援。

如何选择你的 Primary Key ?

- 最常见是自动递增的整数(Auto incrementing Primary Key)，这是 Rails 的默认方式，也是大家熟悉的 ID
- [UUID](https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81) 通用唯一识别码: 1. 分布式系统喜欢用 2. 或是当作 token URL 功能
- Natural key (例如身分证号码, ISBN, 国码 ISO ALPHA-2) 等等，不过你需要真的确认不会重复，例如 ISBN 其实会重复的

> 由于 Rails 默认使用自动递增的整数当作 ID，一般不建议去改这件事情。在百宝箱第一集有提到你可以自己增加别的字串来当作 Model URL。

加 primary key 的 SQL 语法：

`CREATE TABLE events (id INTEGER NOT NULL PRIMARY KEY, name TEXT, capacity INTEGER);`

加 auto increment primary key 的 SQL (各家语法不一样，以下是 SQLite3)

`CREATE TABLE events (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, name TEXT, capacity INTEGER);`

这些在 Rails Migration 中已经帮我们做了。

### Foreign Key (Reference Key) 外键

所谓的 Foreign Key 是指用来关联一对多的字段字段，例如上述 registrations 表中的 user_id 和 event_id。外键的命名没有特别规定，通常是 `_id` 结尾。

你不需要特别告诉数据库这个是 foreign key，就可以当他是 foreign key 来使用。在 Rails 中，写 `belongs_to` 的那个 model，就是 foreign key 字段的那个 model。

在 Rails Migration 中可以用 [add_foreign_key](http://guides.rubyonrails.org/active_record_migrations.html#foreign-keys) 语法告诉数据库这个是 foreign key，如此数据库会提供 Referential integrity (Reference constraint) 验证：

- 确保新增或修改时，要参考的数据存在，不然数据库会报错
- 删除资料时，确保没有其他资料参考我，不然数据库会报错

传统数据库设计非常重视数据的正确性，不过在 Rails 中则偏好在应用层解决，我们有学过利用 `dependent`属性来处理删除的情况，例如：

```
class Event < ApplicationRecord
  has_many :registrations, :dependent => :destroy
end
```

其中 `:dependent`可以有几种不同的处理方式，例如：

- `:destroy` 把依赖的 registrations 也一并删除，并且执行 Registration 的 destroy 回呼
- `:delete` 把依赖的 registrations 也一并删除，但不执行 Registration 的 destroy 回呼
- `:nullify` 这是默认值，不会帮忙删除 registrations，但会把 registrations 的外部键 event_id 都设成NULL
- `:restrict_with_exception`如果有任何依赖的 registrations 资料，则连 event 都不允许删除。执行删除时会丢出错误例外 ActiveRecord::DeleteRestrictionError。
- `:restrict_with_error` 不允许删除。执行删除时会回传 false，在 @event.errors 中会留有错误讯息。

### 逆规范化 denormalized

数据库规范化并不是完全的真理，在不同场景下甚至会做逆规范化的设计。

在一般应用的场景下，也就是营运用途(OLTP)的 Schema 通常会达到比较高的规范化。但是在做分析用途(OLAP)的 Schema，则会偏好逆正规化的设计。因为不会修改数据，只会查询，所以不会有修改数据造成数据不一致的风险。这领域叫做 [Data Warehouse 数据仓库](https://zh.wikipedia.org/zh-cn/%E8%B5%84%E6%96%99%E4%BB%93%E5%82%A8)。从 OLTP 数据库搬资料转到 OLAP 的过程就做 ETL (Extract-Transform-Load)

另外，在一些需要局部效能最佳化的场景，也会做一些逆规范化的设计，例如 Rails 的 [计数快取 Counter Cache](https://ihower.tw/rails/performance-cn.html#sec0) 功能，将数量额外用一个字段先存下来，免去之后计算的查询时间。这也是一种逆规范化的设计。

#### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/66)：[作业二](https://fullstack.xinshengdaxue.com/tasks/351)

已有 30 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/351/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/351)

[rails-erd](https://github.com/voormedia/rails-erd) 这个 gem 可以分析 Rails 产生 ERD 图表，请安装并分析你手上的任一个项目，并贴上截图。

这个 gem 需要安装 [graphviz](http://www.graphviz.org/) 工具，请执行 `brew install graphviz` 就可以安装。

# 9. Joining

SQL 查询厉害的地方，就是可以同时关联(Joining)多张表来进行复杂的查询。让我们先准备示范用的数据。

以下是 user 一对多 events 的情境，请执行 `sqlite3 demo2.db`，并输入以下 SQL 建立 tables 和数据：

```
 CREATE TABLE events (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, name TEXT, capacity INTEGER, user_id INTEGER);
  CREATE TABLE users (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, name TEXT);
  INSERT INTO users (name) VALUES ('ihower');
  INSERT INTO users (name) VALUES ('john');
  INSERT INTO users (name) VALUES ('roy');
  INSERT INTO events (name, capacity, user_id) VALUES ('rubyconf',100, 1);
  INSERT INTO events (name, capacity, user_id) VALUES ('jsconf', 200, 1);
  INSERT INTO events (name, capacity, user_id) VALUES ('cssconf', 150, 2);
  INSERT INTO events (name, capacity, user_id) VALUES ('htmlconf', 300, NULL);
```

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/fAJHtnzDTmeOCfeVh1Kr_8.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/fAJHtnzDTmeOCfeVh1Kr_8.png)

跨 Tables 进行 Joining 查询，常用的有 Inner Joining 和 Left Outer Joining 两种：

#### Inner joining 合并两张 tables，接不起来就不要：

捞出所有活动，以及该活动的主办人资料：

`SELECT * FROM events INNER JOIN users ON events.user_id = users.id;`
或 `SELECT * FROM events, users WHERE events.user_id = users.id;`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ArJf0GsETC61TqgIKGEw_9.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/ArJf0GsETC61TqgIKGEw_9.png)

> 对应的 Rails 语法是 `User.joins(:events)`

#### Outer joining 合并两张 tables，接不起就填 NULL:

捞出所有活动，以及该活动的主办人资料(包括没有主办人的活动)：

`SELECT * FROM events LEFT OUTER JOIN users ON events.user_id = users.id;`

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MnIeiktnStmKYPWw7Jhy_10.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MnIeiktnStmKYPWw7Jhy_10.png)

#### AS 语法

因为有多张 tables 在 SQL 时，column 最好必须加上 table name 当作 prefix (特别是有重复的 column name 时，在 WHERE 条件里可能会无法判断)，而且可以加上别名 AS。

例如 `SELECT events.id AS event_id, events.capacity AS ec, events.name FROM events INNER JOIN users ON events.user_id = users.id WHERE ec=100;`

#### Rails 的 includes 原理

Rails ActiveRecord 的 includes 方法(当没有 WHERE 过滤条件时)则采用另一种 SQL 策略来作 Outer joining:

例如 `Event.includes(:user)` 这个 Rails 语法，实际上的 SQL 是：

`SELECT * FROM events;`

然后透过程式组合出所有的 user_id 成为 (1, 2, 3, 5, 9, 11, 14)，然后再

`SELECT * FROM users WHERE users.id IN (1, 2, 3, 5, 9, 11, 14);`

不过，如果有 users 身上有 WHERE 条件的话，Rails 会变成 LEFT OUTER JOIN。

#### Joining 图表

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/vXiFLH9QHGSRaZ6CbpaY_join1.jpg)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/vXiFLH9QHGSRaZ6CbpaY_join1.jpg)

这张 google 比较常看到，出处 [Visual Representation of SQL Joins](https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins)

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/3N0eNE9xSYettzM1lu79_join2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/3N0eNE9xSYettzM1lu79_join2.png)

这张更清楚说明不同 Join 差别，出处[SQL Joins Better](https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/)

# 10. Functions

数据库也有提供一些 Function 可以用在 SQL 里面：

### 计算 Aggregations

数量

`SELECT COUNT(*) AS event_count FROM events;`

> 加上 AS 别名才比较好识别处理
>
> 对应的 Rails 语法是 `Event.count`

最小和最大值

`SELECT MIN(capacity) as min_capacity FROM events;`
`SELECT MAX(capacity) as max_capacity FROM events;`

> 对应的 Rails 语法是 `Event.minimum(:capacity)` 和 `Event.maximum(:capacity)`

总和

`SELECT SUM(capacity) as sum_capacity FROM events;`

> 对应的 Rails 语法是 `Event.sum(:capacity)`

平均

`SELECT SUM(capacity) / COUNT(capacity) as avg_capacity FROM events;`
或
`SELECT AVG(capacity) as avg_capacity FROM events;`

> 对应的 Rails 语法是 `Event.average(:capacity)`

#### 分类 GROUP BY

GROUP BY 分类功能主要是用来搭配上述 aggregating function 来使用的，例如请回答这个问题：计算每个 user 有多少 events?

让我们试试看：

- `SELECT user_id, COUNT(*) FROM events;` 这样不行，user_id 只会回传第一笔的 user_id
- `SELECT user_id, COUNT(*) FROM events GROUP BY user_id;` 还是不行，没有 user 的名字
- `SELECT users.name, COUNT(events.id) FROM events JOIN users ON users.id = events.user_id GROUP BY user_id;` 不对，结果少了 Roy
- `SELECT users.name, COUNT(events.id) FROM users LEFT JOIN events ON users.id = events.user_id GROUP BY user_id;` 正确答案
- `SELECT users.name, COUNT(events.id) AS c FROM users LEFT JOIN events ON users.id = events.user_id GROUP BY user_id HAVING c > 1 ORDER BY c DESC;` 可再加条件和排序

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MafzIyOdQNaxp7IJQdMf_11.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/MafzIyOdQNaxp7IJQdMf_11.png)

> 其中 `WHERE` 是给 source tables 的条件，`HAVING` 才是 aggregation 后的条件

#### DISTINCT

可以去除重复的数据

`SELECT DISTINCT(user_id) FROM events;`

#### 其他函式

数据库还有提供其他函数，例如 字串 SQLite - [Useful Functions](http://www.tutorialspoint.com/sqlite/sqlite_useful_functions.htm)、时间 SQLite - [Date And Time Functions](https://www.sqlite.org/lang_datefunc.html) 等等。

不过通常比较少用到，因为我们偏好捞出来数据后，交由 Ruby 处理即可。

### 为何要 Joining

回头想想看为什么需要 Joining 语法。SQL 的 Joining 语法是对新手比较困难的部分，没办法完全掌握是正常的。很多时候其实我们在 Rails 先将需要的数据通通捞出来，然后用 Ruby 进行过滤跟组合似乎也可以达成目标，为什么需要用到这些看起来很复杂的 SQL Joining 语法呢?

主要的原因还是查询速度和需要的内存空间，数据库是一套针对 SQL 优化非常快速的软件，因此可以用远比 Ruby 高效的方式来取出数据。更何况如果全部的数据都拿出来用 Ruby 处理，很可能内存也不够。例如以下的问题：请回答去年第三季所有商品的销售额，并根据分类计算总额。去年一整年的销售可能多达上百万笔，如果要逐笔捞出用 Ruby 处理，效能会非常低下。这时候就必须用 SQL 精准地捞出想要的数据才是可行的方式。

### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/66)：[作业三](https://fullstack.xinshengdaxue.com/tasks/352)

已有 15 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/352/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/352)

在百宝箱图表那一章 20-3 分析票种的总金额、20-4 分析票种的报名人数，并根据状态分类，当时是把数据全部捞出然后用 Ruby 进行分类，请改用 SQL 的 [GROUP BY 语法](http://guides.rubyonrails.org/active_record_querying.html#group)来做。

# 11. NoSQL 简介

世界上除了「关系型」数据库，还有其他另类不使用 SQL 的数据库系统，泛称 [NoSQL](https://zh.wikipedia.org/wiki/NoSQL)。

这些 NoSQL 又可以分成几个类型：

### Key-value

[Redis](https://redis.io/) 可说是一种小型数据结构瑞士刀，作为搭配用的数据库来使用。我们在百宝箱用 [sidekiq](http://sidekiq.org/) 实作异步时看过它。

它的用途包括：

- 各式计数器：流量+1
- 简易标记( 例如同一 IP 十分钟内只算一次 pageview)
- 排行榜 zadd
- 自制 Inverted-Index Text Search
- Pub/Sub 聊天室
- Job Queue (例如 sidekiq)

主要是局部的、需要密集性写入的功能，改用 Redis 来操作，来降低主数据库的负担。

### Document-Oriented

[MongoDB](https://www.mongodb.com/) 是一种泛用型的数据库，和 MySQL/PostgreSQL 打对台，特色是 Scheme-free 不需要定义 Schema。曾经有一阵子 Rails 社区非常流行，因为不需要用 Migration 去定义 Schema 就可以使用 Model，一开始用起来非常方便。不过后来大家发现营运久了以后，没有 Schema 的数据会变脏，造成后续维运的成本增加。所以后来就没这么流行了。

### Column-Oriented

关系型数据库的 Transaction 事务的缺点是效能。数据库在做 Transaction 事务时，不可避免地必须锁住一些数据，避免其他人同时修改。因此如果是一个写入流量非常大的网站，就说是一个售票网站好了，非常多人在开票时准时抢票，这时候数据库的效能就会非常差。

特别是当数据非常巨量的时候，需要多台数据库服务器时，Transaction 事务的写入速度，就会成为扩充的瓶颈。

根据[CAP 定理](https://zh.wikipedia.org/zh-cn/CAP%E5%AE%9A%E7%90%86)告诉我们: RDBMS 在多服务器(P)架构下为了维持 C 特性，只能牺牲 A、NoSQL 让你有 tradeoff 的空间，牺牲 C 特性以换得 A、但这不是 C 和 A 二元的选择，而是 C 和 delay 延迟时间的取舍，你愿意容忍多少延迟时间才算作不 Available。

因此这类型的 NoSQL 不讲 ACID，而是讲 BASE 特性 (Basically Available, Soft state, Eventual consistency)，重点是 Eventual consistency。想像一个场景: Facebook 和 Twitter 贴文，当你贴文成功的时候，并不是当下马上其他人就可以看到你的贴文，这中间其实是有延迟时间的。这个延迟对于关系型数据库来说是不可以接受的，但是对于这种社交应用来说，却没有关系。牺牲 Consistence 一致性，就可以换到更多的写入反应效能，这就是这类型的 NoSQL 的设计目的。

- [Apache HBase](https://hbase.apache.org/) 分布式、强调超大 Table： billions of rows X millions of columns (PB以上等级) (Google Big Table 的开源版本，由 Yahoo 推出)
- [Apache Cassandra](http://cassandra.apache.org/) 分布式、最终一致性，高写入场景 (Amazon Dynamo 的开源版本，由 Facebook 推出)
- [Amazon DynamoDB](https://aws.amazon.com/cn/dynamodb/)
- [Google Cloud Datastore](https://cloud.google.com/datastore/)

> 如果你的数据量不到 1PB (=1000TB)，你就不需要考虑这类型的数据库了，用 MySQL 或 PostgreSQL 足矣。

### Graph: neo4j 图形数据库

[neo4j](https://neo4j.com/) 用节点和边来储存数据

# 12. SQL 参考资料和更多教程

网络上关于 SQL 的教程非常多，以下列出一些可以继续进修学习：

- [Udacity: Intro to Relational Databases](https://www.udacity.com/course/intro-to-relational-databases--ud197) (有简中字幕)，建议看 Lesson 1, 2, 4，不用看 Lesson 3: Python DB-API 和 Lesson 5: Final Project。
- [LaunchSchool: Introduction to SQL](https://launchschool.com/books/sql/read/introduction)
- [Learn SQL](https://www.codecademy.com/learn/learn-sql)
- [SQL: Analyzing Business Metrics](https://www.codecademy.com/learn/sql-analyzing-business-metrics)
- [SQL Exercises](https://en.wikibooks.org/wiki/SQL_Exercises)
- [PostgreSQL Exercises](https://pgexercises.com/)
- [SQL Tutorial](http://sqlzoo.net/wiki/SQL_Tutorial)
- [如果有人问你数据库的原理，叫他看这篇文章](http://blog.jobbole.com/100349/)
