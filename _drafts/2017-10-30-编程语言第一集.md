---
layout: post
title: "编程语言第一集"
date: 2017-10-30
tags:
    Rails
    教材
---
| 程序是如何运作的？                                |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  1. 前言](https://fullstack.xinshengdaxue.com/posts/1382) |                                          |
| [**  2. 什么是编程语言](https://fullstack.xinshengdaxue.com/posts/1383) |                                          |
| [**  3. 什么是操作系统](https://fullstack.xinshengdaxue.com/posts/1384) |                                          |
| [**  4. 内存管理](https://fullstack.xinshengdaxue.com/posts/1385) |                                          |
| [**  5. 编译型语言和解释型语言](https://fullstack.xinshengdaxue.com/posts/1386) |                                          |
| [**  6. 各种编程语言介绍](https://fullstack.xinshengdaxue.com/posts/1387) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1387#task) |

| 编程语言的设计                                  |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  7. 数据类型 Data Type: 基本数据类型](https://fullstack.xinshengdaxue.com/posts/1388) |                                          |
| [**  8. 组合数据类型 (Reference Data Types)](https://fullstack.xinshengdaxue.com/posts/1389) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1389#task) |
| [**  9. 作用域 Variable Scope](https://fullstack.xinshengdaxue.com/posts/1390) |                                          |
| [**  10. 正则表达式 Regular Expression](https://fullstack.xinshengdaxue.com/posts/1391) |                                          |

| 算法和数据结构                                  |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  11. 什么是算法?](https://fullstack.xinshengdaxue.com/posts/1392) |                                          |
| [**  12. 如何评估算法](https://fullstack.xinshengdaxue.com/posts/1393) |                                          |
| [**  13. 什么是数据结构?](https://fullstack.xinshengdaxue.com/posts/1394) | 共2个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1394#task) |
| [**  14. 算法的极限](https://fullstack.xinshengdaxue.com/posts/1395) |                                          |
| [**  15. 推荐书籍](https://fullstack.xinshengdaxue.com/posts/1396) |                                          |

# 1. 前言

这堂课将介绍各种关于编程语言的知识理论，并用各位熟悉的 Ruby 语言来举例。

要学会开车，不需要知道汽车内部构造原理，但是如果要当职业赛车手，就需要了解汽车内部各个元件的作用了，了解这些零件是如何整合在一起的。这样才可以用得更好，避免误用。万一半途抛锚了，也能很快做故障排除，知道哪个零件坏了会有什么影响，可不可以继续开，如果要修又要多少时间和成本。不过，你仍然不需要知道太底层的东西，例如怎么真的去制作内燃机、轮胎等零件。

在完成这堂课之后，你可以回答以下问题:

- 程序在计算机中是如何执行的?
- Ruby 编程语言和其他程式语言有什么不同?
- 计算机的架构是什么？内存是干嘛的？
- 操作系统是干嘛的?
- 各种数据型态的差异
- 为什么有乱码? 什么是 Unicode 万国码?
- 什么是正规表示法 Regular Expression，这可以干嘛？
- 什么是算法、数据结构？
- 如何用 BigO 评估算法效能，了解不同数据结构的效能差异

# 2. 什么是编程语言

编程语言用来描述电脑如何工作，电脑很厉害可以处理超多资料、每秒可以做数亿次的操作(operations)，但是同时也很笨，每个操作很简单机械、没有见解或理解。编程语言也需要很精确，需要固定语法(syntax)结构让电脑可以了解。

世界上很有很多编程语言，为什么有这么多种语言呢？让我们先分成两种：低级语言和高级语言来说明。

#### 低级语言

低级语言指的是[机器语言](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80)和[汇编语言](https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80)，一步一步指示电脑微处理器如何动作，是最原始的编程语言。低级语言不是说比高级语言差，而是指抽象化的程度比较低，与电脑硬件的指令直接对应的意思。

首先，一台电脑的组成，包括中央处理器(CPU)、内存(RAM)、硬盘和其他 I/O 设备(网卡、键盘、鼠标和萤幕等)。其中内存就像是短期记忆，所有正要执行的指令和数据，都会先放在内存上。CPU 会从内存读取出要执行的指令和数据，执行完的结果再放回内存。内存的速度很快，但是只要关机重开，数据就会不见，而且容量较小。为了持久化数据，我们用硬盘来存成档案，来做持续保存。硬盘的空间很大，也比较便宜。

中央处理器(CPU)有自己的指令集，不同厂商的 CPU 指令集不一样，例如 [Intel x86](https://zh.wikipedia.org/wiki/X86) 和 [ARM](https://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%9E%84) 不一样。Intel 的 CPU 主宰了桌机和服务器市场，特色是效能高跑得快。而 ARM 架构的 CPU 特色是省电，因此大部分的手机和行动装置，都是用 ARM 架构的 CPU。

机器语言会指示 CPU 进行什么操作：首先将指令和数据从内存搬进 CPU 的寄存器，接着 CPU 进行计算，然后将结果从CPU 寄存器搬回内存，代码长得像这样：

```
000000 00001 00010 00110 00000 100000
100011 00011 01000 00000 00001 000100
000010 00000 00000 00000 10000 000000
```

看不懂意义是正常的。其中每一行内容就是某个 CPU 指令、CPU 寄存器编号，以及内存位址。这个内存位址的长度是固定的，目前主流是 32 位元或 64 位元 (所以 CPU 跟操作系统，还有分 64 位元和 32 位元，指的就是这个长度)。

> 电脑的数字信号是以二进制数来表示的，一个 0 或 1 就是一个位元(bits)。8个 bits 称为 1 bytes 是常见电脑计算容量的基本单位，32位元也就是4bytes的长度。在往上则是 1000 byte 或 1024 bytes 为 1 kilobyte (1KB)。1000 或 1024 KB 是 1 Megabyte (1 MB)、1000 或 1024 MB 是 1 Gibibyte、1000 或 1000 GiB 是 1 Tebibyte (1TB)。什么时候用十进制 1000 什么时候用二进制的 1024 (二的十次方)呢？对商人有利的时候就会用十进制，例如卖你硬盘容量的时候讲 1T，但是硬盘格式化之后，电脑是用二进制运作的，所以变成 930 GB 而已。

机器语言人类是很难直接阅读和撰写，因此 CPU 厂商发明了汇编语言，基本上就是对应机器语言，只是给予符号意义，长得像这样：

```
MOV eax, 1
ADD eax, 4
SUB eax, 2
MOV num, eax
INVOKE printf, ADDR formatStr, num
ret    0
```

低级语言写起来很费事，但电脑跑起来飞快。注意，不同 CPU 的机器码(又叫做 native code)是不一样的。因此 Intel x86 和 ARM CPU 的代码、32位元和64位元的程序是不通用的。

> 这世界上 10 种人，懂二进制的，以及不懂二进制的。

#### 高级语言

由于撰写低级语言的开发速度太慢，因此我们会用所谓的高级语言来开发软件。高级语言透过结构化的程序设计语法，包括变量、数据型态 函式、控制结构、循环等等功能，来让开发好读好写。

这些高级语言例如 C 语言、Java 语言、PHP/Python/Ruby 等等。其中最重要的发明就是 C 语言了，长得像这样：

```
#include <stdio.h>
int main() {
    int n, i, sum = 0;

    printf("Enter a positive integer: ");
    scanf("%d",&n);

    for(i=1; i <= n; ++i) {
        sum += i;   // sum = sum+i;
    }

    printf("Sum = %d",sum);
    return 0;
}
```

请存成 `sum.c`，然后执行 `cc sum.c -o sum` 就会编译出 `sum` 这个执行档，用 `./sum` 就会执行。这个程式会从 1 累加到你输入的一个数字。

在 C 语言中，使用变量需要先宣告数据型态，例如这里是 `int` 表示整数。它会预先跟内存要固定的空间(int 会要 4 bytes)。在 C 语言中，要使用变量都必须跟内存先讲要多少空间。

电脑可以执行机器码，但是无法直接消化高级语言，这些高级语言的源代码都必须经过一个编译(compile)的过程，转换成二进制机器语言，也就是可执行的档案。

这个编译的工具，叫做编译器(Compiler)。你不必弄明白代码是怎么变成二进制码的机器语言，但你得知道这个过程。

电脑软件可以分成系统软件和应用软件，前者包括操作系统、编译器、嵌入式系统等等，不希望有任何效能损耗，需要了解硬件、操控硬件，例如内存空间。后者则是各种 App、桌面软件、手机软件、Web 应用等，效能上可以有权衡(trade-off)，好写好改 vs. 程式执行效能，来因应变来变去的商务需求。

其中 C 语言是最重要的系统程式语言，目前绝大部分编程语言的编译器，都是用 C 语言写的，例如 Ruby 也是用 C 语言写的。C 源码经过编译后可以移植到不同硬件上(例如 Intel 或 ARM，同一份 C 源码，用不同平台编译器编译出不同的机器码)上，执行的效能非常好。

> 趣闻：[那第一个C语言编译器是怎样编写的？](https://news.cnblogs.com/n/533687/)

# 3. 什么是操作系统

关于编程语言是如何运作的，我们还漏介绍一个关键的系统软件，那就是[操作系统](https://zh.wikipedia.org/zh-cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)。

一台电脑不只跑一只程序，而是同时有非常多程序在执行，另外还有各式各样不同厂商的I/O设备。而操作系统就是负责管理这些硬件资源的程序，它会负责管理如何分配内存给不同的程序和优先级、控制I/O设备，例如硬盘、网卡、鼠标、键盘等等，并且提供一个用户接口让我们可以安装和操作不同应用软件。

因此，上一章有提到的高级语言需要透过编译器转换成机器码，会因为不同 CPU 架构而不同，也会因为不同的操作系统而不同。不同的操作系统，会提供不同的 API 让编程语言可以调用硬件资源。编程语言不需要知道不同厂商的硬盘怎么调用，编程语言内部会调用操作系统所提供的档案 API，而不同厂商的硬盘，会提供驱动(Driver)软件与操作系统串接。

操作系统例如微软的 Windows、Apple 的 MacOS、Linux 等等。

让我们动手操作一下，观察一下操作系统的运作。请打开 Mac 的 Activity Monitor

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/nzQYF8m9Sh6Xlbgi2h7Q_1.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/nzQYF8m9Sh6Xlbgi2h7Q_1.png)

其中每只正在执行的程序，就叫做 Process 进程，会有一个编号是 PID。每个 Process 会被操作系统分配一整块内存，以及分配给一个 CPU 执行，不同 Process 可以同时执行。如果有多个 CPU 就是真的平行处理，如果只有一颗 CPU，那操作系统也会依照优先级依序让不同 Process 执行，因为 CPU 很快就好像是平行执行的一样。

如果一个 Process 内想要平行处理，那可以再生出轻量的 Thread(线程)，不同线程可以分配到不同 CPU 上执行，但是是共享同一块内存。撰写多线程的程序是困难的，我们不太会接触。

# 4. 内存管理

了解内存是编程非常重要的概念，因为如果你把内存用光了，操作系统就得去把硬盘模拟成内存使用，但是由于硬盘的速度跟内存差太多了，整台电脑的效能会急剧下滑，就会呈现当机的状态。一台电脑的内存是有限的，你的 MacBook 可能只有 4G 或 8G，租一台服务器，最重要的也是先看有多少内存空间可以使用。内存越多，可以同时执行的程序就越多。

打开 Mac 的 Activity Monitor，点击 Memory 可以观察各个程序使用内存的情况

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/sRR2O3OLSreyRXGqXaNS_2.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/sRR2O3OLSreyRXGqXaNS_2.png)

前几节提到在 C 语言中，使用变量需要预先跟内存索要空间，这跟 Ruby 很不一样。在 Ruby 是全自动的内存管理，你学到现在好像都不需要关心到底内存是如何被使用的吧。但是在 C 语言中需要手动管理内存。在硬件资源有限或需要效能至上的软件中，手动管理内存有其必要，但是缺点就是降低了开发效率，开发者必须注意好内存管理，用的时候要先宣告，不用的时候要释放回操作系统。如果一只程序一直消耗内存，却从来不归还给操作系统，那这只程序就是不断不断地耗用，直到全部内存都被吃光，最后电脑就当机了(或是手机上的操作系统会强制关闭你的应用)。

以编程语言的发展历史来看，第二重要的可能就是 Java 语言了。Java 有许多重大的发明，其中面向对象我们下一个教程会教的重点，另外就是内部 Virtual Machine(VM)跨平台设计，以及和[垃圾回收 Garbage Collection (GC)](https://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)) 了，我们先谈谈 GC。

GC 是编程语言的一种内部功能，作用是自动把再没有用到的变量，把内存释出回操作系统。例如你可以想像，编程语言在执行的时候，会定时停一下检查所有变量，看看哪些变量已经没有被使用，就释放回操作系统。

垃圾回收可以让程式员减轻许多负担，也减少程式员犯错的机会。在 Java, Ruby, JavaScript 都有 GC，一般来说不需要特别烦恼内存的使用。还是有可能碰到内存泄露(memory leak)问题，例如不断使用内存但没有释放的机会。

例如以下 Ruby 程式，是一个无穷循环不断增加资料到数组里面:

```
arr = []
i=0

while(true)
  arr[i] = "hahaha!"
  i = i+1
end
```

请继续观察 Mac 的 Activity Monitor，等等你会发现有一只 Ruby 程序，它的内存用量不断上升......... (请记得中断这个程序)。

编程语言内部的 GC 算法非常重要，非常影响编程语言的执行效能。GC 多久执行一次，每次执行 GC 要花多少时间(一跑 GC，你的程序就等于是暂停下来)，这些都会严重影响程序的进行。例如在一些 real-time 强即时性的软件中，就说是一个机器人走路的软件好了，是不能用 GC 的，需要手动管理内存。想像一下走路腿抬到一半，然后编程语言不定就自动跑了 GC 暂停一下，那就跌倒了。

近十年 Ruby 1.9 到 Ruby 2.4 的版本，都着重在改进内部的 GC 算法，以来增加效能。

# 5. 编译型语言和解释型语言

高级语言又可以分为两种：编译型语言(静态语言/Static)和解释型语言(动态语言/Dynamic)，这两种语言的优缺点，一直以来都是开发者社群最爱论战的话题。

编译型语言包括：C 语言、C++、Java 语言等等，这种语言要求一定要先把全部代码编译变成机器码(native code)，也就是可执行的档案。软件散布和分享的时候，是拿最后的执行档。在这类语言中，使用变量必须事先宣告类型，例如这个变量一开始宣告是 int，那就一定只能是 int，不能换成存字符串。

解释型语言包括: Ruby、Python、JavaScript、PHP 等等，这种语言不需要先编译，而是透过一种叫做解释器(interpreter)的软件，逐行编译然后直接执行。软件散布和分享的时候，是拿源代码。在这类语言中，使用变量不需要事先宣告类型，一开始存整数，后来换成存字符串也可以。

编译型语言每次修改代码，都必须重新把程序编译好，如果程序任一行有错，就无法编译。但是因为都先编译好了，所以执行的速度比较快，而且执行档很小。刚刚的 C 语言范例，编译后只有8K的大小。

解释型语言不需要先编译，修改起来比较方便，写代码也快一些，但是任何错误都要等到真正执行之后，才会知道。因为要等到执行时才编译，所以执行的速度较慢。一个只有一行的 Ruby 代码程序，如果要再另一台电脑跑起来，那台电脑也必须把 Ruby 解释器安装起来，而且跑起来至少需要 5MB 的内存，即使只是输出一行 Hello World。

所以为何有不同的程式语言呢？一方面是大家对于效率的需求不一样，有的希望是执行快，有的希望开发快。一般来说 「机器语言 -> 组合语言 -> C 语言 -> Java 语言 -> 动态语言」越往右边跑起来效能较差，但开发起来效率比较好。

另一方面也是编程语言的设计哲学不同，有些喜欢功能多、程式码比较有表现力，例如 Scala，但语言本身会比较复杂。有些喜欢功能少，比较精实但打比较多字，例如 Go 语言。

#### 为什么 Web 应用，使用解释型语言有更好的的优势?

著名的”人月神话”一书作者Fred Brooks曾说：「一个程式设计师一天能产生的程式码行数是差不多的，无论什么程式语言」。因此一个具有表达能力的高阶程式语言，就会比低阶的程式语言能完成更多功能。相较于静态程式语言，使用更高阶的动态脚本语言可以帮助我们：

1. 用更少程式码做更多事情，大大增加生产力
2. 更快因应客户开发需求，敏捷开发

不过，动态语言也不是没有缺点：

1. 执行效能是绝对比不上静态语言的
2. 没有编译期可以检查型别错误

但是，我们知道现在的电脑越来越快、越来越便宜、上网越来越容易、内存越来越多、硬盘越来越大。另外，行动装置也越来越多，需要搭配的网络服务需求也增加了。这些趋势告诉我们有更多的软件的需求，另一方面由于硬件效能的增强，人力开发成本比起软件的执行期的效能，也越来越重要。同样一个程式，用动态语言执行的效能已经可以达到实用(例如每秒可以处理50~500个的HTTP请求，也可以透过增加服务器来扩展架构)，也许用静态语言后的执行速度可以再快一倍，但是却需要十倍以上的时间来开发，这件事情是不是值得呢？

在硬件资源有限的行动装置及嵌入式系统上，仍是静态语言的天下，这一点需要更多时间才有动态语言的生存空间。
没有编译期可以检查型别错误的问题，也随着单元测试和TDD(Test-driven development)测试驱动开发等敏捷最佳实务而逐渐降低重要性。而大部分的Bug会出自于商业逻辑错误，而不是型别错误上。

# 6. 各种编程语言介绍

讨论各种编程语言的优劣，也是程序员经常笔战的热门话题。以下简单介绍一些常见的编程语言：

- C 语言: 开发系统程式 (System Programming)、操作系统、编译器等等工具必备语言。经过编译可以移植到不同硬件上。
- C++ 语言: 多了一大堆功能和面向对象的超级复杂版 C 语言，大型软件如 Google Chrome, Qt, WebKit, V8, HHVM 或是效能要求高的游戏等等，用 C++ 比较多。但是 C++ 由于语法太多太复杂，被认为是最不好上手的语言之一。Linux 和 Git 的发明人 Linus，就坚决反对 C++。
- Java 语言: 提供跨平台 VM、面向对象，使用 GC 内存垃圾自动回收，由于发展已久，效能也非常好，后端很多企业软件和中间件使用，在超大型网站中也十分常见，例如阿里巴巴、Twitter、Linkedin 服务端。前端方面要 Android 软件也是用 Java 语言，

这里提一下什么是跨平台，这有一些歧义。Java 当年的一个理念是跨平台(Windows、Mac、Linux 等)：同一份编译好的执行档，可以在不同平台执行，不需要像 C 语言需要编译成不同执行档。为了达成这么目的，Java 发明了一种叫做[字节码(bytecode)](https://zh.wikipedia.org/wiki/Java%E5%AD%97%E8%8A%82%E7%A0%81)的设计，Java 会先编译成这种与平台没有依赖的字节码，但是每个平台需要先装 Java VM (JVM)，又叫做 [JRE(Java Runtime Environment)](https://java.com/download/)，现在新的操作系统应该都有内建了。

这么说 Ruby 其实也是跨平台，因为同一份 Ruby 源码也可以跑在 Windows、Mac、Linux 上，只要 Ruby 的解释器(interpreter)能装上去就行。不过通常没这么幸运，因为很多 Ruby 库是用 C 语言写的，而不是 Ruby，因此不一定能在不同平台上顺利编译成功，因为这些 C 代码可能有依赖操作系统的，例如调用了某个只在 Linux 操作系统上才有的 C 库。因此很多需要编译的 gem 例如 [nokogiri](https://rubygems.org/gems/nokogiri/versions) 甚至都必须针对 Windows 提供不同的 gem 版本。

不过说到真正的跨平台，目前的主流是 Web 应用，浏览器才是真正跨平台的软件。用户不需要预先安装 VM 也不需安装动态语言的解释器，只需要有个浏览器就可以了。

- Scala 语言、Clojure 语言、JRuby 语言等等：这些语言都建构上 JVM 上，透过编译变成 Java 字节码，就可以在不同平台上执行。这些语言用自己偏好的语法设计，然后搭上 Java VM 发展成熟的便车，可以调用 Java 的库。
- C# 语言: 微软的官方语言，当年是仿 Java 所推出的编程语言。它的 .NET framework 等同于 JVM 的设计。在 .NET 上还有其他微软的编程语言 VB.NET, ASP.NET, F# 等等
- Objective-C 和 Swift，苹果专用的编程语言，撰写 MacOS 和 iOS 应用必备
- PHP 语言，当年发明的时候叫做 Personal Home Page，所以叫做 PHP。PHP 的初衷是作为 HTML 样板(就像是 Rails 里面的 html.erb)，主攻 Web 应用。因为容易上手使用，在 2000 年初搭配 MySQL 数据库非常流行。
- Python 语言: 也是动态语言的一种，和 Ruby 时常拿来对比。近年来在数据分析和机器学习领域用得很多。
- JavaScript 语言: 托浏览器的福，成为全世界最风行的语言。后端可以用 [Node.js](https://nodejs.org/en/) 单独将 JavaScript 跑在服务器上，而不需要依赖浏览器的环境。
- R 语言: 用于数据分析领域，学术领域用的很多。但不会拿来做软件应用。

别人用什么?

- Java: Google, Oracle
- Swift, Objective-C: Apple
- C#: Microsoft, stack overflow
- PHP: wikipedia, vimeo, facebook
- Ruby: airbnb, shopify, github, twitter, groupon, basecamp, hulu+
- Python: youtube, quora, google, instagram, pinterest

编程语言有许多概念和功能是跨语言都有的，只是 ecosystem (衍生出来的套件、社群和支援)不一样，擅长的情境不一样，一般来说：

- 开发系统程式(例如操作系统、编译器)，适合 C 语言
- 开发 Web 后端应用，适合 PHP/Ruby/Python/Node.js
- 开发 Web 前端应用，得用 JavaScript
- 开发 Android 应用，得用 Java
- 开发 iOS 应用，得用 Swift 或 Objective-C

最后，「编程语言」和「编程语言的实作」是不一样的概念，前者是指语法的规格定义，后者是指编译器(或解释器)。同一门编程语言，但是有不同家的编译器(或解释器)是常见的事情，例如：

- JavaScript 的语法标准叫做 [ECMAScript](http://zh.wikipedia.org/wiki/ECMAScript)，但是 JavaScript 的实作有很多，包括 Chrome 浏览器用的 [V8 引擎](https://zh.wikipedia.org/zh-cn/V8_(JavaScript%E5%BC%95%E6%93%8E))、Safari 用 [WebKit](https://zh.wikipedia.org/zh-cn/WebKit)、Firefox 用 SpiderMonkey。虽然都叫 JavaScript 语言，但是真正跑在不同浏览器时，实际上是不同的解释器，还是有差异的。
- Ruby 有 [CRuby](https://www.ruby-lang.org/)(又叫做 MRI，大家目前安装的就是 MRI 版本)、[JRuby](http://jruby.org/)、[Rubunius](https://rubinius.com/)、 [RubyMotion](http://www.rubymotion.com/)等等
- PHP 有 [Zend Engine](http://php.net/) (这是官方版) 和 [HipHop](https://github.com/facebook/hhvm/wiki) (这是 Facebook 针对 PHP 重写过的 PHP 解释器，以改进效能)
- Objective-C 和 Swift 当然就谨此 Apple 一家出编译器
- .NET 有微软官方版和 [Mono](http://www.mono-project.com/)
- Java 有 HotSpot (这是 Oracle 的官方版本) 和 OpenJDK (这是开源版本，在 Linux 安装的话会装到这个版本)

### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/62)：[作业一](https://fullstack.xinshengdaxue.com/tasks/341)

已有 21 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/341/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/341)

请用 C 语言和 JavaScript(Node.js) 写一个 Hello World 程序可以在命令行输出 Hello World。

执行 `brew install node` 就会安装 JavaScript，用 `node xxx.js` 就可以在本机上执行 xxx.js 源码。

请贴上执行成果。

# 7. 数据类型 Data Type: 基本数据类型

在高级语言中，每个值都属于一种数据类型，这些数据类型可以概分为两种：基本数据类型和组合数据类型

为什么编程语言需要设计数据类型? 因为同样是 2 bytes 的资料，如果不知道是什么类型的话，那我们就无从得那 16 bits 的二进制数字代表的意义，可能是字符串、也可以是数字。

### Data Type 基本数据类型(Primitive Data Type)

基本数据类型包括 String 字符串、Integer 整数、Float 浮点数、Boolean 布林、nil 空值等。

### String 字符串

在编程语言内部，字符串就是一个一个字符，用数组串起来实作的。让我定义一下什么是字符：一个英文字母是一个字符、一个中文汉字是字符、一个符号也是一个字符。

但是电脑存储的是二进制，需要透过编码(Encoding)才能让人给这些二进制意义，透过字符集对照表，告诉我们这个二进制编码对应的字符是哪一个。

最早的字符集是 1967 年美国人发明的 [ASCII](https://zh.wikipedia.org/wiki/ASCII) (American Standard Code for Information Interchange) 美国信息交换标准代码，用一个 1 byte 的空间，来储存可显示的英文字母和符号，以及不可见的控制字符，例如：

二进制 0100 0001，十进制 65，这个编码代表 A
二进制 0100 0010，十进制 66，这个编码代表 B
...
二进制 0110 0001，十进制 97，这个编码代表 a
...

不过，1 byte 的空间，至多也就是 256 种字符而已，对于非英语系国家是绝对不够用了。于是各个国家自定义了各自语言的字符集，例如：

- [GB 2312](https://zh.wikipedia.org/wiki/GB_18030) 信息交换用汉字编码字符集，收录了6763个简体汉字
- [Big5](https://zh.wikipedia.org/zh-cn/%E5%A4%A7%E4%BA%94%E7%A0%81) 大五码，收录了13,060个繁体汉字，在台湾、香港与澳门使用
- [Shift JIS](https://zh.wikipedia.org/wiki/Shift_JIS) 日文
- ...族繁不及备载

这些语言的字符集，使用了 2 bytes 的空间，至多可以容纳 65526 种字符，看起来似乎是足够的。

不过，相信大家可能都碰过[乱码](https://zh.wikipedia.org/zh-cn/%E4%B9%B1%E7%A0%81)问题，打开一份文件或是网页，发现都是无意义的字符，这就是因为使用了错误的字符集去显示，解决办法就是重新选过 Text Encoding 挑到正确的字符集，文字才能正确显示。

另外，如果想要同一份文件同时显示汉字、日文、韩文、越南文等等，就没有一种字符集可以满足需求耶？

所幸，我们目前使用的业界标准，是 1991 年开始发展的 [Unicode 万国码](https://zh.wikipedia.org/wiki/Unicode#.E5.8E.86.E5.8F.B2)，这个计画定义了全世界所有语言的编码。在这个计画下，定义了几个字符集标准：

- UTF-32 用 4 bytes 来存一个字符
- UTF-16 用 2 或 4 bytes，汉字会是 4 bytes
- UTF-8 用不定长度 1~4 bytes，一个英文字母用 1 byte 存储，一个汉字会用 3 bytes 才存储

其中 UTF-32 很少使用，因为太浪费空间了。本来一个英文字母用 1 byte 就可以存，改成用 4 bytes 后，前面三个 bytes 都是 0，耗费的空间变成四倍。

蛮多编程语言内部是用 UTF-16 时做字符串的，例如 Java 和 Python。

至于 UTF-8 则是目前最为通行的标准，既能表示所有语言，空间上又比较节省。因此广泛应用在 HTML 和各种文件上。在 Rails 默认产生的网页，也都是使用 UTF-8 标准。另外，ASCII 刚好是 UTF-8 的子集，有着良好的向后相容性。

关于编码，可以再参考看看这篇文章 [字符，字符集，字符编码](http://www.jianshu.com/p/bd7a6c508c33)

Ruby 对于各种字符集的支援非常好，每个字符串，都属于一种字符集，默认是 UTF-8：

让我们执行 irb 实验看看：

```
"a".encoding    # 得到 <Encoding:UTF-8>
"a".size    # 这是 1 个字符
"a".bytesize  # 这是1个 bytes
```

```
"中".encoding   # 得到 <Encoding:UTF-8>
"中".size      # 这是 1 个字符
"中".bytesize  # 这是3 个 bytes
```

Ruby 内建支援了 101 种字符集。执行

```
Encoding.list.map{ |x| x.name }
 => ["ASCII-8BIT", "UTF-8", "US-ASCII", "UTF-16BE", "UTF-16LE", "UTF-32BE", "UTF-32LE", "UTF-16", "UTF-32", "UTF8-MAC", "EUC-JP", "Windows-31J", "Big5", "Big5-HKSCS", "Big5-UAO", "CP949", "Emacs-Mule", "EUC-KR", "EUC-TW", "GB2312", "GB18030", "GBK", "ISO-8859-1", "ISO-8859-2", "ISO-8859-3", "ISO-8859-4", "ISO-8859-5", "ISO-8859-6", "ISO-8859-7", "ISO-8859-8", "ISO-8859-9", "ISO-8859-10", "ISO-8859-11", "ISO-8859-13", "ISO-8859-14", "ISO-8859-15", "ISO-8859-16", "KOI8-R", "KOI8-U", "Shift_JIS", "Windows-1250", "Windows-1251", "Windows-1252", "IBM437", "IBM737", "IBM775", "CP850", "IBM852", "CP852", "IBM855", "CP855", "IBM857", "IBM860", "IBM861", "IBM862", "IBM863", "IBM864", "IBM865", "IBM866", "IBM869", "Windows-1258", "GB1988", "macCentEuro", "macCroatian", "macCyrillic", "macGreek", "macIceland", "macRoman", "macRomania", "macThai", "macTurkish", "macUkraine", "CP950", "CP951", "IBM037", "stateless-ISO-2022-JP", "eucJP-ms", "CP51932", "EUC-JIS-2004", "GB12345", "ISO-2022-JP", "ISO-2022-JP-2", "CP50220", "CP50221", "Windows-1256", "Windows-1253", "Windows-1255", "Windows-1254", "TIS-620", "Windows-874", "Windows-1257", "MacJapanese", "UTF-7", "UTF8-DoCoMo", "SJIS-DoCoMo", "UTF8-KDDI", "SJIS-KDDI", "ISO-2022-JP-KDDI", "stateless-ISO-2022-JP-KDDI", "UTF8-SoftBank", "SJIS-SoftBank"]teless-ISO-2022-JP-KDDI (autoload)>, #<Encoding:UTF8-SoftBank>, #<Encoding:SJIS-SoftBank (autoload)>]
```

你可以用 encode 转换编码到不同字符集：

```
"中".encode("GB2312")  # 得到 "\x{D6D0}" 终端机默认用 UTF-8，因此无法顺利显示 GB2312。\x 是16进制的意思
"中".encode("GB2312").bytesize # 得到 2 bytes

"中".encode("ASCII") # 这样会报错 Encoding::UndefinedConversionError: U+4E2D from UTF-8 to US-ASCII 因为汉字无法转成用 ASCII 存储
```

以及用 force_encode 换字符集但不转换编码：

```
"\xD6\xD0".encoding # 因为默认是 UTF-8
"\xD6\xD0".force_encoding("GB2312").encode("utf-8") # 编码不变，但是告诉 Ruby 说这个是 GB2312，然后再转回 UTF-8
```

在 Ruby 之中，默认读取写入资料都是用 UTF-8 编码，但是如果要串接其他系统或资料，就需要知道字符集的知识。例如数据库要记得用 UTF-8，抓比较旧的外部文件或网页，如果不是 UTF-8 编码的话，那就必须处理转码问题。

### Symbol

Symbol 是 Ruby 语言特有的类型，作用跟字符串很像，但是是唯一且不会变动的识别名称，用冒号 `:` 开头，例如 `:this_is_a_symbol`

为什么不用字符串呢？这是使用 Symbol 执行效能比较好。在 Ruby 语言内部，相同名称的 Symbol 不会再重复建构、Symbol 本身的方法也比 String 少很多、你也不能修改 Symbol。让我们进 irb 实验看看：

```
puts "foobar".object_id      # 输出 2151854740
puts "foobar".object_id      # 输出 2151830100

puts :foobar.object_id       # 输出 577768
puts :foobar.object_id       # 输出 577768
```

`object_id`方法会回传 Ruby 内部的内存位址编号。你会发现两个字符串就算内容相同，也是不同的位址。但是 Symbol 只要内容相同，就是相同位址。这种特性让 Symbol 的主要用途是作为散列 Hash 的键(Key)。

### Number 数值类型

#### 整数 Integer

电脑内部是用[补码](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A1%A5%E6%95%B0)的方式来存储整数，一个 byte 的空间可以表示 -128~127 之间的数字。在 C 语言中，需要先宣告你要使用多大的数字，例如 short 是 2 bytes，只可以存 -32768 - 32767 之间的整数，int 是 -2^31 - (2^31-1) 之间的整数。

在动态语言例如 Ruby 中不需要先宣告，Ruby 会自动调控使用多少 bytes 来存整数。

在静态语言中，需要先宣告需要用多大空间的整数，在编译的时候就会在内存中预留空间 (所以执行起来比 Ruby 快啊)。

#### Float 浮点数

如果要做科学运算、数值分析，会有很多除不尽的小数情况，这时候就会用浮点数 Float，可以表示任意长度的实数。

以 [IEEE 单精度浮点数标准](https://zh.wikipedia.org/zh-cn/%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0) 为例，32位元，第一个位元是正负号、8个位元存指数，后23个位元存有效位数，透过2的指数来计算，如此就可以表示非常非常大和非常非常小的数字。

但是符点数有个最大的缺点就是输入与储存的值不一定精确、计算后的结果可能会有微小误差(因为无法刚好用 2 的指数来表示，只能逼近)

[举例](http://0.30000000000000004.com/)来说，0.1 + 0.2 是不等于 0.3 的，你可以进 irb 实验看看

```
0.1 + 0.2  # 得到 0.30000000000000004

0.1 + 0.2 == 0.3   # 得到 false
```

> 在 JavaScript 语言中，所有数值都是浮点数。

#### Decimal 十进制数

如果需要小数点，又希望绝对的精确，这时候会用 Decimal 型态，设定整数部分和小数部分的要用多少位数，可以精准表示

在 Ruby 内可以用 [BigDecimal](https://ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html)

不过，真正重要的其实是数据库，在 Rails migration 中，如果你要存有小数点的资料，可以用 float 或 decimal 是都可以。但是如果情境是 GPS 定位、汇率等等，已知小数长度是固定的话，这时间建议用 decimal 会比较准确。

例如在 Rails migration 中，最好用 deciaml 而不是 float 来存汇率或经纬度：

```
# 总共六位数，小位数三位

t.decimal  "currency_rate", precision: 6, scale: 3
```

不然可以你输入某个经度纬度，存进数据库再拿出来，可能会差小数码一些些，但对 GPS 来说可能就差好几公尺了。

# 8. 组合数据类型 (Reference Data Types)

组合数据类型，包括 Array、Hash 和程序员自订的复合资料类型(也就是 Class)，这种类型的数据是一种容器，里面可以放上述的基本数据类型，或是组合其他的组合数据类型。

### Array 有序容器，用整数当作索引

在编程基础中各位应该已经熟悉 Array 的使用，在内存里面，Array 就是用一块连续的存储空间。

```
|1|2|3|4|5|6|7|8|
```

每个数组元素，在内存里面的大小是固定的。透过索引，我们可以很快就计算出该元素在内存中的位置。

例如假设每个元素占 4 bytes，`arr[0]` 在内存位置 100，那 `arr[3]` 就是 100 + 4*3 在位置 112 了。

### Hash Table 散列表 (或称作 Map 或 Dictionary)

一种 Key-Value 的容器，通常用 Symbol 或字符串当作索引，要了解散列 Hash 的原理，需要先知道什么是散列函数。

散列函数是一种能将数据变成摘要(digest)的算法，执行 `irb`，然后输入以下代码实验看看：

```
require 'digest'
Digest::SHA1.hexdigest '12345678'
```

得到 `"7c222fb2927d828af22f592134e8932480637c0d"`

散列函数有一些很好的特性：1. 相同的数据，每次都会得到一样的摘要 2. 即使只有微小差异的内容，摘要也会差异很多，非常分散。

因此，我们将散列的 key 丢进这个散列函数，得到一组摘要。然后用这个摘要的前几码，来把 value 放到内存中对应的位置。

例如我们可以设计一个有 26*26 个空间的容器(在内存中佔用 26 * 26 * 4 bytes空间)，给予编号 aa 到 zz。然后取 key 摘要的前两码，把 value 放到那个位置：

```
|aa|ab|ac|ad|.....|zx|zy|zz|
```

假设初始位置是 100，如果给一个 key 算出来的散列值是 ad，那我们就把值放在 100 + 4*3 在位置 112。

这样设计的好处是，随便给一个 key，都可以马上算出它在内存中的位置，非常有效率。

> 因为只取前几码，当然有可能不同的 key 会放在同一个位置。内部实作根据这种情况，会再处理冲突，详见[散列表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)。

### 组合数据的修改

辨识哪些是引用数据类型，是很重要的基本概念，例如

```
a = 1
b = a
a = 2
```

请问最后 b 是多少? a 是多少? 这题没坑，a 就是 2，b 就是 1。
a, b 两个变量分别佔了内存的两块空间，当 `b = a` 时，b 内存就被填成当时 a 的值是 1。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/v4aSQqf3Tx6AYBAly9Yr_4.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/v4aSQqf3Tx6AYBAly9Yr_4.png)

同样的逻辑，让我们换成 array:

```
a = [1,2,3]
b = a
a[0] = 9
```

请问最后 a, b 数组长怎样？

令初学者感到意外的是，a 和 b 最后都是 `[9,2,3]`，两个数组变量都被修改到了！

这是因为在内存里面，组合数据类型的变量，并不是直接存它的值，而是存一个引用位址(reference)，指向另一块真正存值的内存空间。

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/gWfO0ueSIuAzhPcxHP2e_5.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/gWfO0ueSIuAzhPcxHP2e_5.png)

因此当 `b=a` 时，复制的是引用位址(reference)，指向同一块存有 `[1,2,3]` 的内存空间。当最后 `a[0]` 时，就会改到同一份数据。

为什么编程语言会这样设计呢？这是因为组合数据类型是个容器，这个容器可能存有非常多的数据，复制的成本是很高的。因此在默认的情况下，我们不会真的去复制它的值，而是复制引用而已。

#### 方法调用

方法调用也必须注意参数是基本类型还是引用类型：

```
def foo(x)
  x = 9999
  return x
end

x = 1
foo(x);
x
```

请问最后 x 是多少? 还是 1 喔。在调用 foo 的时候，这个 x 的值被复制到方法的参数 x，所以方法里面改的 x 变量，跟外面的 x 变量是不一样的。

```
def bar(x) {
  x[0] = 9999;
}

arr = [1,2,3];
bar(arr)
```

请问最后的 arr 是多少? 也被修改成 `[9999,2,3]` 了，调用方法，被复制成为参数的是引用，所以在方法里面修改 x 就是修改 arr 的值。

会这样设计的原因，也是因为默认复制引用类型成本太高了。

#### 就地编辑(in-place editing)

在 Ruby 内建的 API 中，有些 API 是「回传新的副本」、有些是「In-place」做修改(mutate)，例如：

Array 的 sort 方法：

```
a = [5,1,9]
b = a.sort
```

`b` 会是排序好的 `[1,5,9]`，但是 `a` 是没有变的，还是 `[5,1,9]`

Array 的 sort! 方法：

```
a = [5,1,9]
a.sort!
```

这个 `a` 直接被修改了，变成 `[1,5,9]`

> 对 Ruby 来说，这个 `!` 只是名字的一部分，没有特别的作用。只是一个惯例提醒你说这个方法会有 副作用(side-effect)。

那什么时候要用哪一种呢？比执行速度的话，「In-place」做修改(mutate) 是比「回传新的副本」还快，因为后者需要新的内存空间来存储。不过，实际写代码时，我们一般会偏好「回传新的副本」的方式，因为这样比较不容易有 bug。

这是因为一个软件里面的方法会调用其他方法，其他方法里面又会调用方法，所以参数可能会传递到很深的方法里面，如果有一个方法不小心直接修改了参数，对于调用者来说，可能不是预期会被修改的行为。因此用「回传新的副本」的方式，会比较保险安全。

#### 复制

组合数据类别的 `=` 指派只会复制引用，如果需要真的复制值，会改用 `clone` 方法：

```
a = [1,2,3]
b = a.clone
a[0] = 999
a
b
```

改了 `a[0]`，就不会影响到 `b` 了。

不过，`clone`不是万能的，如果组合数据里面又有组合数据，那么....

```
a = [1,2,3]
b = [0, a]

c = b.clone
a[0] = 999

b
c
```

虽然 `c` 是 clone 出来的，但是改了 `a`，还是同时影响到 b,c 了。这是因为内建的 clone 是不支援 deep clone (深度复制)。这可能会有很复杂的情况，如果真的要复制，你需要自己写方法。

看起来好像会很复杂，所幸我们不常碰到需要 clone 的情况。

### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/62)：[作业二](https://fullstack.xinshengdaxue.com/tasks/342)

已有 13 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/342/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/342)

请判断 Ruby [Enumerable module](https://docs.ruby-lang.org/en/2.4.0/Enumerable.html)、[Array class](https://docs.ruby-lang.org/en/2.4.0/Array.html) 和 [Hash class](https://docs.ruby-lang.org/en/2.4.0/Hash.html) 文件中方法，哪些是「回传新的副本」？哪些是「In-place」修改方法？哪些是成对的？请研究至少五个 API 以上。

在 Ruby 里面只要是可以被走访的容器，都会 include Enumerable module。因此 Array 和 Hash 都会继承 Enumerable module，它的方法会被继承下来。

# 9. 作用域 Variable Scope

变量作用域 Variable Scope 指的是变量可以被存取到的范围，一般分成本地变量(Local variable)和全局变量(Global variable)

```
def foo
 x = 1
end

x = 2

foo()

x # 仍然是 2
```

这段简单的程序中，宣告在方法里面的局部变量 `x`，只可以在该方法内存取的到，对外面来说是没有影响的。对 Ruby 来说，一个局部变量的 scope 就是在该方法内。

至于全局变量则是不管在程式哪里，都可以存取的到。在 Ruby 之中会用 开头，例如 `$THIS_IS_GLOBAL_VERIABLE`

> Ruby 还有对象变量(Instance variable) Scope 和类变量(Class variable) scope，之后的面向对象教程会学到。

设计作用域 Variable Scope 的目的是避免变量名称冲突(naming collisions)。

为什么要避免变量名称冲突呢？一个软件会有很多方法，也会用到很多不是我们自己写的库，如果没有作用域的话，变量名称很可能会刚好命名成一样，就冲突了。

同样的原因，我们也会避免使用全域变量，就算要用，全域变量的命名也会取比较长，来避免冲突。

# 10. 正则表达式 Regular Expression

[正则表达式 Regular Expression](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)是一种精巧比对字串的方式。我们在第一集百宝箱中，曾经用过这个技巧来验证 URL 网址：

`validates_format_of :friendly_id, :with => /\A[a-z0-9\-]+\z/`

其中的 `/\A[a-z0-9\-]+\z/` 就是一个正则表达式，检查字符串必须是小写a到z，或数字0到9，或是横线`-`。

更多用途举例：

- 检查 “Mississippi” 字串里面有没有出现 “ss” ?
- 找出每段文章中的第三个单字
- 将文章”开头”中的 “Dear” 全部用 “Hi” 替换
- 将文章结尾的”.”换成”。”
- 检查是否是合法的 Email、URL 自串

用法规则：

- `.` 符合任何单一字符
- `\w` 单字字符
- `\d` 数字字符
- `\s` 任何空白
- `\S` 非空白
- `^` 行首位置
- `*` 出现 0 次以上
- `+` 出现 1 次以上
- `?` 出现 0 或 1 次
- `{m,n}` 出现 m 次到 n 次
- `[a-z]` a 到 z 范围内的任何单一字符
- `[^a-z]` 非 a-z 之外的任何单一字符

线上工具：

- <http://rubular.com/>
- <https://regex101.com/>

所幸，你不需要学习太难的表达式，大部分常用的正规表达式，用抄的就可以了，例如 [知道这20个正则表达式，能让你少写1,000行代码](http://www.jianshu.com/p/e7bb97218946)。

# 11. 什么是算法?

1960 年代发明的结构化程式设计 (Structured programming) 是一种编程典范。它采用函式、程式码区块、for循环以及while循环等结构，来取代传统的 [goto](https://zh.wikipedia.org/wiki/Goto)语法。希望借此来改善电脑程式的明晰性、品质以及开发时间，并且避免写出面条式代码。程式从可以随便跳来跳去的 goto 写法，变成限制成三种流程控制：循序(prodecure)、分歧(if-else)、反复(while loop)。因此算法也是由这三大基础结构所构成。

现今的编程语言几乎都有这些特性，成为「常识」：流程控制(Flow control)和函数(function)

所谓的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)是一种有次序、明确定义和可行，最终会结束、有输出的可执行步骤。虽然你可以用各种方式来描述一个算法，例如画一个流程图也可以是算法，但是对程序员来说，使用结构化形式来描述解决问题的详细步骤，是最常见的方式。

例如，这是一个给数组求最大值的算法，先假设第一个元素最大，然后依序走访数组每一个元素，检查哪一个比较对就指派给 `max` 变量。最后跑完剩下来的 `max` 就是最大值。

```
def find_max(arr)
  max = arr[0]

  arr.each do |a|
    if a > max
      max = a
    end
  end

  return max
end
```

这个算法看起来非常简单，它的基本思维就是[暴力搜寻](https://zh.wikipedia.org/zh-cn/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2)技术，这是非常基本的解决问题方式：把所有可能的解答都计算过一次，然后从里面挑一个最棒的。

# 12. 如何评估算法

一个算法好不好，要怎么评估呢？电脑科学家特别关心当数据越来越多时，一个算法需要耗费多少时间。

我们使用一种叫做 Big-O 的符号来描述算法的复杂度，复杂度可以分成时间复杂度和空间复杂度，前者计算这个算法要花多少步骤，后者则是耗费多少内存空间。通常我们比较关心前者，以下介绍时间复杂度。

```
def constant(n)
  result = n * n
  result = result + 1

  return result
end
```

这个 constant 方法，不管 n 是多少，执行的步骤都是固定的，执行时间都一样，科学者于是称之这个时间复杂度是 O(1)是常数的。

```
def linear(n)
  sum = 0
  1.upto(n) do |i|
    sum = sum + i
  end

  return sum
end
```

这个 linear 方法，当 n 越大的时候，里面的循环就得跑越多次，这时间复杂度为 O(n) 是线性的：当 n 成长十倍时，需要的执行时间也是十倍。

```
def quadratic(n)
  sum = 0
  1.upto(n) do |i|
    1.upto(n) do |j|
      sum = sum + i + j
    end
  end

  return sum
end
```

这个 quadratic 方法，当 n 越大的时候，里面的循环就得平方多次，这时间复杂度为 O(n^2) 是平方的：当 n 成长十倍时，需要的执行时间是一百倍。

```
def logarithmic(n)
  result = 0
  while n > 1
    n = n.to_f / 2
    result += 1
  end

  return result
end
```

这个 logarithmic 方法的 Big-O 是 O(log n)，当 n 成长从 100 变成 100000 时，需要的执行时间是 2.5 倍而已。

以下是不同 Big-O 的成长图表

[![img](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/luI4sNi3SuajgagMle3S_3.png)](https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/luI4sNi3SuajgagMle3S_3.png)

在计算机本科生的算法课程中，会非常详细的去分析和评估算法的复杂度。例如经典的案例就是数组的[排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)。我们在上一堂课中，曾经要求大家练习选择排序法。如果你有练习的话，这个算法内的循环内还有一个循环，这是一个 O(n^2) 的算法。世界上有各式各样的排序算法，在算法课中就会去示范分析每一种算法的优缺点，要多少复杂度。

不同排序算法示范：

- [Sorting Algorithms Animations](https://www.toptal.com/developers/sorting-algorithms/)
- [15 Sorting Algorithms in 6 Minutes](https://www.youtube.com/watch?v=kPRA0W1kECg)

其中证明了最好的就是 O(nlogn)，像 Ruby 的 Array#sort 方法就是用[快速排序法](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)做的。

还有，在编程基础练习中，有一题是在数组中找到最大(或最小)的数字，例如 `arr = [5,1,9,4]`，以下两种算法都可以得到答案：

第一种：

```
def find_max(arr)
  max = arr[0]

  arr.each do |a|
    if a > max
      max = a
    end
  end

  return max
end
```

第二种：

```
def find_max(arr)
  arr.sort.last
end
```

第二种看起来比较简单，但是现在你可以判断第一种方法是 O(n)，第二种确是 O(nlogn) 了，前者比较好。

> 当然，Ruby 可以直接调用 `arr.max` 方法，就得到第一种方法的结果

# 13. 什么是数据结构?

数据结构定义资料之间的相互关系，是设计算法的载体，数据输入输出和设计算法步骤时，都会对应于使用的数据结构。而不同的数据结构有不同的特性。在计算机本科生的课程中，有门数据结构的课，就是在分析各种不同的数据结构，做不同操作时的优点点和复杂度：[Common Data Structure Operations](http://bigocheatsheet.com/)

对 Ruby 程序员来说，最常用的就是 Array 和 Hash，我们在组合数据类型介绍过 Array 和 Hash 内部原理，现在我们来分析一下常用的操作，对 Array 和 Hash 的算法复杂度。

#### 插入和删除到容器里面

要在数组中插入一个值，如果刚好在最后(例如 Arrar#push 方法)，是 O(1)
如果在数组中间插入一个值，因为数组是内存中「连续」的空间，中间新插入，会需要搬动后面所有元素的位置往后移动一格，这是 O(n) 的算法，n 越大需要移动的元素越多。

对散列 Hash 来说，插入是平均复杂度是 O(1)。

#### 检查一个值都没有在容器里面

Array 是 O(n)，需要走访整个数组依序检查

Hash 是 O(1)，只要将 key 经过散列算法，就可以直接检查那个位置有没有数据。

让我们动手实验看看，Ruby 内建有 [benchmark](https://docs.ruby-lang.org/en/2.4.0/Benchmark.html) 工具，可以让我们量测一个方法的执行时间：

```
require 'benchmark'

a1 = Array.new(1000000){ rand(100) } # 造一个一百万个元素的数组，内容是乱数

a2 = a1 * 10   # 数组放大十倍


h1 = {}
a1.each { |x| h1[x] = :y } # 把数组转成散列


h2 = {}
a2.each { |x| h2[x] = :y }


Benchmark.bm do |x|
  x.report {
    a1.include?(999)
  }
  x.report {
    a2.include?(999)
  }
  x.report {
    h1[999] == :y
  }
  x.report {
    h2[999] == :y
  }
end
```

这个实验检查容器里面有没有 999 这个值，这是结果：

```
user     system      total        real
   0.000000   0.000000   0.000000 (  0.005854) # 数组一
   0.060000   0.010000   0.070000 (  0.064084) # 十倍大的数组二：时间约成长 10 倍
   0.000000   0.000000   0.000000 (  0.000005) # 散列一:
   0.000000   0.000000   0.000000 (  0.000005) # 十倍大的散列二: 时间一样
```

你会发现需要的时间，数组需要的时间约增加了十倍，但是散列却一样。

> 数据库打索引的原理也是一样的，没有打索引就是 O(n)，有打索引是 O(logn)。当数据库成长到上百万笔资料时，有没有索引的时间差距是很大的。数据库内部用的索引数据结构是 [B-tree](https://zh.wikipedia.org/zh-cn/B%E6%A0%91)

### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/62)：[作业三](https://fullstack.xinshengdaxue.com/tasks/343)

已有 11 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/343/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/343)

给定一个数组，请写出一个方法，找出里面重复的数字。例如

- 输入 `[1,1,2]` 回传 `[1]`
- 输入 `[1,1,2,2]` 回传 `[1,2]`
- 输入 `[1,2,3]` 回传 `[]`

请分析以下两种解法的复杂度，并贴上 benchmark 对比的结果，哪一个算法比较好：

- <https://gist.github.com/ihower/b7e8c3f658b49bd9e261876202810094>
- <https://gist.github.com/ihower/48cdb4dc3725b52c7b1616bb60cd49d0>

##### [作业](https://fullstack.xinshengdaxue.com/assignments/62)：[作业四](https://fullstack.xinshengdaxue.com/tasks/344)

已有 9 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/344/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/344)

Ruby 的 [Array#find_index](https://docs.ruby-lang.org/en/2.4.0/Enumerable.html#method-i-find_index) 方法可以从数组中寻找一个值，回传它的索引，这个算法是 O(n)。

`arr = [5,1,9,6]arr.find_index(9) # 回传 2`

Ruby 还有一个 [Array#bsearch](https://docs.ruby-lang.org/en/2.4.0/Array.html#method-i-bsearch)，实作了 [二分搜索算法 binary search](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)。如果你已知数组是排序过的，这个算法会是 O(log n)。

请自行实作一个 Binary Search 算法，并且 benchmark 比较当 arr 元素有10个、10000个、1000000 个时，平均(或最糟)需要多少运算时间。

把答案和 Benchmark 结果贴在 [https://gist.github.com](https://gist.github.com/) 然后作业缴交 gist 网址：

```
def binary_search(arr, element)
 # .... 你的实作放这里

end

arr = [0, 5, 13, 13, 30, 42, 52, 70, 85, 96, 103, 111, 116, 127, 130, 143, 150, 150, 161, 175, 207, 210, 218, 246, 257, 257, 263, 280, 304, 310, 326, 327, 332, 346, 360, 371, 374, 378, 406, 407, 407, 408, 428, 431, 437, 442, 445, 479, 489, 491, 505, 517, 520, 536, 548, 598, 602, 605, 618, 642, 649, 654, 659, 662, 677, 678, 682, 689, 695, 696, 697, 701, 711, 717, 727, 737, 745, 749, 754, 757, 770, 786, 802, 805, 814, 832, 840, 850, 853, 854, 888, 894, 904, 913, 913, 945, 962, 964, 972, 998]

binary_search(arr, 371) # 应该回传 35
```

当然，如果数组没有排序过，你要先排序才能调用二分搜寻算法，就是一排序就会是 O(n logn) 了。

# 14. 算法的极限

这一节我们探讨一个有趣的问题，电脑这么厉害，有没有不能计算的问题？

有的，例如[停机问题](https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98)：你没办法写一个软件，去判断另一个软件会不会当机。所以说 Apple 审核不可能审核到你的 App 会不会当机。

另外，有些问题虽然可以计算，但是算法耗费太多资源或时间，这种问题的最佳解 Big-O 是 O(2^N)，而非多项式时间内。因此要求最佳解是不切实际的，只能用最佳化逼近解。

我们可以看看 O(2^N) 有多恐怖，当 N = 100 时，就比大霹雳以来的微秒数还要多。没有电脑可以在我们有生之年可以计算完毕。最近的热门话题 [AlphaGo](https://zh.wikipedia.org/wiki/AlphaGo) 下围棋之所以这么了不起，就是因为就算现代电脑这么先进了，也不可能穷举所有的可能来下围棋。

已知最佳解就是 O(2^N) 的算法问题，就叫做 [NP 类型](https://zh.wikipedia.org/wiki/NP_(%E5%A4%8D%E6%9D%82%E5%BA%A6))的算法问题，例如河内塔步骤：假设有 N 个的环，那么最佳解的移动步骤是 2^N - 1，原始版本和尚要移动 64 个环根本就不可能。其他像是西洋棋必胜策略也是 NP 类型问题。

已知有指数时间解，但是不确定有没有更好的多项式时间解，这就作 [NP-Complete](https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8) 类型的问题。例如 [旅行推销员问题](https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98)是 O(n!) n阶层时间。

> [P = NP](https://zh.wikipedia.org/wiki/P/NP%E9%97%AE%E9%A2%98) 是 在理论信息学中计算复杂度理论领域里至今没有解决的问题。

# 15. 推荐书籍

这门教程的知识点非常多，包括了计算机大学本科 1. 数据结构 2. 算法 3. 操作系统 4. 编译器 5. 编程语言，大一到大三共五门必修课程的主要概念。我推荐以下的书籍可以继续进修：

- [改变未来的九大算法](https://book.douban.com/subject/24529132/) 介绍九个影响世界的重要的算法，没有代码，是科普书
- [一路编程](https://book.douban.com/subject/26937425/)，入门程度的概括性介绍软件编程
- [代码之髓](https://book.douban.com/subject/25927585/) 介绍编程语言的设计
- [程序是怎样跑起来的](https://book.douban.com/subject/26365491/)
- [计算机是怎样跑起来的](https://book.douban.com/subject/26397183/)
- [大话数据结构](https://book.douban.com/subject/6424904/)
- [算法图解](https://book.douban.com/subject/26979890/)

> 放心，这些都不是大部头的教科书

### 关于算法和找工作面试

有些公司很爱考算法题目，特别是大型公司，例如 Google、Microsof、Facebook、BAT 等大企业。因为他们偏好学历好计算机本科系刚毕业，聪明、底子好的学生，不看重作品集，招聘后再内训。

如果你对这类型公司有偏好，你需要熟悉各种数据结构的操作算法，例如 Stack、Queue、Linked List、Tree、Graph 等等。

基本的解题策略是：先很快的用暴力解(Brute-force)，先别担心算法效率。然后再最佳化，找出哪些步骤是多余重复的计算。通常考官都会逐步提示你完成最佳化。

你需要花时间练习熟悉题型：例如

- <http://www.coderbyte.com/>
- <https://leetcode.com/>
- [Cracking the Coding Interview](https://book.douban.com/subject/25753386/)

就算是大神，碰到这种公司不先刷题也是被拒的。

- <https://twitter.com/mxcl/status/608682016205344768>
- <http://osherove.com/blog/2011/4/5/my-google-rejection-letter.html>
