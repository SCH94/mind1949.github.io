---
layout: post
title: "编程语言第二集"
date: 2017-10-30
tags:
    Rails
    教材
---
| 函数式编程                                    |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  12. 匿名函式](https://fullstack.xinshengdaxue.com/posts/1426) |                                          |
| [**  13. 匿名函式的应用](https://fullstack.xinshengdaxue.com/posts/1427) |                                          |
| [**  14. Combinator functions](https://fullstack.xinshengdaxue.com/posts/1428) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1428#task) |

| 面向对象编程                                   |                                          |
| ---------------------------------------- | ---------------------------------------- |
| [**  15. 什么是面向对象?](https://fullstack.xinshengdaxue.com/posts/1429) |                                          |
| [**  16. Ruby 语法说明](https://fullstack.xinshengdaxue.com/posts/1430) |                                          |
| [**  17. 特性一: 封装(encapsulation)](https://fullstack.xinshengdaxue.com/posts/1431) |                                          |
| [**  18. 特性二: 继承(inheritance)](https://fullstack.xinshengdaxue.com/posts/1432) |                                          |
| [**  19. 特性三: 多态(polymorphism)](https://fullstack.xinshengdaxue.com/posts/1433) |                                          |
| [**  20. 面向对象设计](https://fullstack.xinshengdaxue.com/posts/1434) | 共1个作业 \|[** 未完成](https://fullstack.xinshengdaxue.com/posts/1434#task) |

# 12. 匿名函式

我们学过在编程语言中数据有不同类型，例如字符串、数字等。这一节要教大家一个非常重要的概念，那就是函式也是一种数据类型。函式也是一种数据类型。函式也是一种数据类型。很重要所以说三遍。

> 又叫做 [First-class function 头等函数](https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0)

以下的 Ruby 程式码中，变量 `x` 就是一个函式变量。它的值 `->{ puts "Hello World"}` 叫做匿名函式(或叫做 anonymous function, code block 或 lambda )。匿名函式要透过 `.call` 才会实际调用。

```
x = -> { puts "Hello World" }
x.call # 输出 Hello World
```

> `->` 等同于 `lambda` 等同于 `Proc.new`，这三种写法都可以。有小小的差异但目前先不管没关系。

这里 Ruby 的语法看起来有点奇怪，如果你有学过一点 JavaScript，以下是等同的 JavaScript 代码：

```
x = function(){ console.log("Hello World") }
x() # 输出 Hello World
```

其中 `x` 是一个函式变量，透过 `x()` 才会调用。在 JavaScript 中调用一个函式一定要加上括号，所以用 `x()`表示触发调用。但是在 Ruby 里面，调用函式是可以省略括号的，因为没办法区分 `x` 跟 `x()` 的情况下，Ruby 需要用 `.call` 方法才会调用匿名函式。

### 把函式变量当作参数

既然函式也是一种数据类型，我们就可以将这个函式变量当作参数来传递，例如

```
foo = -> { puts "foo" }

def bar(x)
  puts "bar"
  x.call
end

bar(foo)

# 输出

# bar

# foo
```

我们将 `foo` 变量当作参数，传到 `bar` 里面去，然后再调用它。注意到第一行宣告 `foo` 函式的时候，我们并没有真的调用它，直到 `x.call` 时才调用它。因此是先输出 bar，然后才输出 foo。

这段代码等同于以下的 JavaScript 代码：

```
foo = function() { console.log("foo") }

function bar(x) {
  console.log("bar")
  x()
}

bar(foo)
```

### 直接内嵌的写法

也可以直接用匿名函式放到参数里面：

```
def bar(x)
  puts "bar"
  x.call
end

bar( ->{ puts "zoo" } )

# 输出

# bar

# zoo
```

等同于

```
function bar(x) {
  console.log("bar")
  x()
}

bar(function(){
  console.log("zoo")
})
```

有写过 JQuery 的同学们应该很熟悉这种形式。不过 Ruby 的写法似乎不太常见这样写，这是因为通常会简化成这样：

```
def bar
  puts "bar"
  yield
end

bar do
  puts "foo"
end

# 或是 bar { puts "foo" }
```

看起来很熟悉了吧。如果参数列最后一个参数是匿名函式，那么就会用这种简化的写法：传入的匿名函式用 `{ ...}` 或 `do .... end` 表示，然后在函式里面用 `yield` 这个关键字来实际调用它。

> 通常单行的程式会用 `{ ... }` 的写法，多行则会用 `do ... end` 的写法。这只是 Coding Style 惯例而已，作用是一样的。

如果匿名函式接受参数的话，语法是这样：

```
def bar
  puts "bar"
  yield("zoo")
end

bar do |x|
  puts x
  puts "foo"
end

# 输出

# bar

# zoo

# foo
```

其中 `yield("zoo")` 会将 "zoo" 带入匿名函式，也就是函式 `bar` 的 `x` 参数

另外，还有一种混合的写法长这样：

```
def bar(&block)
  puts "bar"
  block.call
end

bar do
  puts "foo"
end

# 或是 bar { puts "foo" }
```

用 `&block` 可以具体化传入的 `{....}` 或 `do ... end` 参数。不过除非你还会继续在 bar 里面调用另一个方法代入这个匿名函式，否则一般不需要这样写。

# 13. 匿名函式的应用

匿名函式是一种非常重要的概念，这种可以将函数当作参数的技巧，有非常多的 API 设计使用到，特别如果你是库(Library)或框架(Framework)的作者的话，更会用到这个技巧。以下来看看几种不同的应用：

> 这种技巧又叫做 [Higher-order function 高阶函数](https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0)

### pre-and post-processing

pre-and post-processing 的意思是前置和后置处理，将共享的前置和后置处理代码抽取出来。以 Ruby 的开档写入为例，无论要写入什么，首先一定要打开档案，完成后一定要调用 `close` 方法：

```
f = File.open("myfile.txt", 'w')
f.write("Lorem ipsum dolor sit amet")
f.write("Lorem ipsum dolor sit amet")
f.close
```

我们可以改用传入 block 参数的写法，这样就会自动关档了：

```
File.open("myfile.txt", 'w') do |f|
  f.write("Lorem ipsum dolor sit amet")
  f.write("Lorem ipsum dolor sit amet")
end
```

作为练习，假如我们模仿写一个类似的方法，会长这样：

```
def my_open_file(filename, file_mode)
  f = File.open(filename, file_mode) # 前置处理

  yield(f)
  f.close  # 后置处理

end

my_open_file("myfile.txt", 'w') do |f|
  f.write("Lorem ipsum dolor sit amet")
  f.write("Lorem ipsum dolor sit amet")
end
```

这个 `my_open_file` 方法就是一个通用的开档方法，这样的好处是不用写 `f.close` 了，而且也不可能忘记。如果忘了写 `end` 的话会语法错误。另一个好处是透过代码缩进也更好阅读了解这些代码在一起的。

### callback function

[回调函数](https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0)的意思是先挖好坑，让调用这个 API 的人可以填要执行什么。

例如 Rails ActiveRecord 可以注册 [callback 方法](https://ihower.tw/rails/activerecord-lifecycle-cn.html#sec1)，在 `save` 前后做一些事情。我们在百宝箱 2-3 自订 Model 网址曾经用过 `before_validation :generate_friendly_id, :on => :create`，这会在 `save`前去调用 `generate_friendly_id` 方法。

这个原理就是回调函式，假如我们自己来写一个练习看看，这个 `save` 会长这样：

```
class MyRecord

  def self.register_before_callback(&block)
    @@before_callback = block
  end

  def self.register_after_callback(&block)
    @@after_callback = block
  end

  def save
    @@before_callback.call  # 挖了一个坑

    puts "save into DB"
    @@after_callback.call   # 挖了一个坑

  end

end
```

上面的代码属于库(Library)的通用代码，你可以想像在 Rails 内部大概是这样的。

接下来是我们实际使用的情况：

```
MyRecord.register_before_callback do # 填坑

  puts "this is before callback"
end

MyRecord.register_after_callback do # 填坑

  puts "this is before callback"
end

record = MyRecord.new
record.save

# 输出

# this is before callback

# save into DB

# this is after callback
```

调用函式在 JavaScript 用的就更多了，例如绑事件：

```
$("div").click(function(){
  console.log("click!")
})
```

这个 `click` 的参数就是一个回调函式用法，当我们真正 click 时，才会调用这个匿名函式。

### currying function

既然函数也是一种数据，我们可以造一种函式让他也回传一个匿名函式：

```
def add(x)
   ->(y){ x + y }
end

add2 = add(2)
add3 = add(3)


puts add2.call(4) # 输出 6

puts add3.call(6) # 输出 9
```

这虽然不太实用，但是是个有趣的例子。

### Closure 闭包特性

匿名函式有一个很重要的特性，那就是 Closure (闭包)。这个意思是它会将外面的作用域(scope)一起包进来，函式内可以读取到函数外的变量，但是在匿名函式中新建立的变量，离开匿名函式后会清掉。

```
arr = [1,2,3]
outer = 1

arr.each do
  puts outer  # 可以读取到外面的 outer 变量

  inner = 4   # 新建立一个 inner 变量

end

inner  # 错误 NameError，找不到 inner 这个变量
```

# 14. Combinator functions

另一个常见的应用是 Combinator functions，指的是处理容器的三个组合招数，让我们一一道来：

### 映射 map

映射的意思就是将容器里面的元素，一对一变换成另一个新的容器。

例如我们想将以下的 `arr` 元素每一个都加一，首先示范一下传统的写法：

```
arr = [1,2,3,4,5,6,7,8,9,10]

result = []
arr.each do |i|
  result.push(i+1)
end

puts result
# 输出 [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

改用 `map` 方法，这个方法接受一个匿名函式来做转换：

```
arr = [1,2,3,4,5,6,7,8,9,10]

result = arr.map { |i| i+1 }

puts result
# 输出 [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

### 过滤 filter

过滤就是将容器里的元素，根据某些条件过滤建立另一个容器。

例如过滤出所有偶数，首先示范一下传统的写法：

```
arr = [1,2,3,4,5,6,7,8,9,10]
result = []
arr.each do |i|
  if (i % 2 == 0)
    result.push(i);
  end
end

puts result
# 输出 [2, 4, 6, 8, 10]
```

改用 `select` 方法，这个方法接受一个匿名函式来决定条件：

```
arr = [1,2,3,4,5,6,7,8,9,10]

result = arr.select{ |i| i % 2 == 0 }  # 这个匿名函式要回传 true 或 false


puts result
```

### 归纳 reduce

归纳就是将一个容器里的元素，归纳成一个值：

例如加总好了，首先示范一下传统的写法：

```
arr = [1,2,3,4,5,6,7,8,9,10]

result = 0;
arr.each do |i|
  result = result + i
end

puts result
# 输出 55
```

改用 `reduce` 方法：

```
arr = [1,2,3,4,5,6,7,8,9,10]
result = arr.reduce(0) { |sum, i| sum + i }

puts result
```

`result` 比较难理解一点：`reduce` 的第一个参数 `0` 是初始值，然后这个匿名函式依序走访容器，两个参数 `sum` 跟 `i`，前者 `sum` 是前一次循环的回传结果。`i` 是这次走访的元素。

找最大值其实也可以用 `reduce` 方法：

```
arr = [9, 2, 10, 6, 2, 4, 5, 6, 0, 4]

max = arr.reduce do |max, i|
  if max > i
    max
  else
    i
  end
end

puts max
# 输出 10
```

每次循环，匿名函式回传的值就是下一次的 `max` 参数。

如果 `reduce` 没给第一个参数，那容器的第一个元素会是初始值。

### 综合应用

假如我们想从以下的数据找出小于 1000 的最大的金额，要怎么找呢？

先示范传统写法：

```
tickets = [
  { name: "Ticket A", amount: 100 },
  { name: "Ticket B", amount: 1123 },
  { name: "Ticket C", amount: 670 },
  { name: "Ticket D", amount: 50 },
  { name: "Ticket E", amount: 990 },
]

result = tickets[0][:amount]   # 一定要先在 code block 外面初始这个变量，如果放在里面，出来就被清掉了

tickets.each do |ticket|
  if (ticket[:amount] < 1000 && ticket[:amount] > result )
    result = ticket[:amount];
  end
end

puts result
# 输出 990
```

改成刚刚学到的写法：

```
tickets = [
  { name: "Ticket A", amount: 100 },
  { name: "Ticket B", amount: 1123 },
  { name: "Ticket C", amount: 670 },
  { name: "Ticket D", amount: 50 },
  { name: "Ticket E", amount: 990 },
]

result = tickets.map{ |t| t[:amount] }.select{ |a| a < 1000 }.reduce{ |x,y|
(x > y)? x : y }

puts result
# 输出 990
```

一行就可以写完，有没有觉得很厉害呢。

#### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/67)：[作业一](https://fullstack.xinshengdaxue.com/tasks/353)

已有 14 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/353/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/353)

```
people = [
  { name: "Person 1", :age => 21 },
  { name: "Person 2", :age => 15 },
  { name: "Person 3", :age => 13 },
  { name: "Person 4", :age => 30 },
  { name: "Person 5", :age => 45 },
]
```

请用 Combinator Function 用一行代码得到一个 Array 是其中大于 20 岁的人名(name)，也就是 `["Person 1", "Person 4", "Person 5"]`

# 15. 什么是面向对象?

所谓的对象(Object)就是指一个带有状态和方法的容器，例如以下是 JavaScript 中的自定义对象：

```
var my_object = {
  name: "ihower",
  move: function(){
    console.log( this.name + " is moving" )
  }
}


my_object.move()
```

`my_object` 有两个属性，一个是 `name` 一个是 `move`，而 `move` 其实是一个匿名函式。这个对象有自己的状态(`name` 是 ihower)，有自己的方法(move)。我们把相关的数据和方法，一起包进物件里面。

`my_object.move()` 可以看成是朝对象 `my_object` 发送一个 `move` 讯息。接收者 `my_object` 接到一个 `move` 讯息。

向面对象(Object-Oriented)程序设计指的就是以对象为基础的编程方式，整个软件就是一群对象之间的互动。

### 为什么要用面向对象？

在编程语言第一集中，算法和数据结构强调的是正确性和高效率。但是在面向对象要追求的是软件的扩充性、维护性、修改弹性、可读性、可测性，是一种将代码适当安排组织的一种设计方式。

Ruby 是一个非常面向对象思维的编程语言，在 Ruby 中其实每一个数据其实都是对象。

### Class-based 基于类的面向对象设计

主流编程语言中，只有 JavaScript 可以像刚刚一样直接创造一个自定义对象，其他编程语言包括 Ruby，都是要先定义类(Class-based)才能创造对象。所谓的类(Class)就是去定义了某一种类型的对象所拥有的属性和方法。类别是抽象的事物，而不是其所描述的特定对象。以下的 Ruby 代码先定义了 `Person` 类，然后再用 `new` 方法创造出两个对象 `p1` 和 `p2`：

```
class Person
  attr_accessor :name

  def move
    puts "Hello, #{@name}"
  end
end

p1 = Person.new
p1.name = "ihower"
p1.move # 输出 Hello, ihower


p2 = Person.new
p2.name = "John"
p2.move # 输出 Hello, John
```

你可以想像类(Class)就是对象(Object)的模版，这些对象都有 `name` 属性和一个 `move` 方法。

> 名词释疑：除了 Object (对象)的讲法，这些由类产生出来的 Object，又叫做 Instance (实例)

# 16. Ruby 语法说明

让我们完整解说一下 Ruby 中类的语法：

```
class Person

    def initialize(name)
        @name = name
    end

    def say(word)
        puts "#{word}, #{@name}"
    end

end

p1 = Person.new("ihower")
p2 = Person.new("ihover")

p1.say("Hello") # 输出 Hello, ihower

p2.say("Hello") # 输出 Hello, ihover
```

- 类一定是大写开头，也是一种常数
- `initialize` 是对象的建构方法，当调用 `new` 的时候的会把参数传进这里
- `@` 开头的变量，也就是范例中的 `@name` 叫做对象变量(instance variable)。这个是对象的内部状态。
- `def` 会定义对象的方法

```
class Person

    @@name = “ihower”

    def self.say
        puts @@name
    end

end

Person.say # 输出 ihower
```

- 两个 `@@` 开头的变量，也就是 `@@name` 叫做类变量(class variable)，这个是属于类的
- 用 `self.def` 开头定义的方法，也就是 `def self.say` 叫做类方法。用 `Person.say` 就会调用。

另外，对象变量(@开头)和类变量(@@开头)，都是封装在类内部，类外无法存取。都需透过定义方法才可以存取到。

例如：

```
class Person
    def initialize(name)
        @name = name
    end
end

p = Person.new('ihower')
p.name
# NoMethodError 会出错

p.name='peny'
# NoMethodError 会出错
```

需要定义存取的方法，一个读、一个写：

```
class Person

   def initialize(name)
    @name = name
   end

   def name
     @name
   end

   def name=(name)
     @name = name
   end

end

p = Person.new('ihower')
p.name
=> "ihower"
p.name = "peny"
=> "peny"
```

### attr_* 用法

由于定义存取方法很常见，Ruby 提供了 `attr_accessor`、`attr_reader`、`attr_writer` 等类方法帮我们定义：

```
class Person

  attr_accessor :name

  attr_reader :foo
  attr_writer :bar
end
```

其中 `attr_accessor :name` 等同于刚刚我们自定义的存取方法。`attr_reader` 只定义读、`attr_writer`只定义写。

### public/protected/private 方法

对象方法还有分 public(公开)、protected 和 private 不同，默认是 public。

```
class MyClass

    def public_method
      private_method # 调用 private 方法

      self.protected_method # 调用 protected_method 方法，self. 可加可不加

    end

    private # 以下定义的都是 private 方法


    def private_method
    end

    protected  # 以下定义的都是 protected 方法


    def protected_method
    end

end

m = MyClass.new
m.public_method

m.private_method
# NoMethodError: private method `private_method' called 会出错


m.protected_method
# NoMethodError: protected method `protected_method' called 会出错

```

你不能对对象 `m` 调用 privated_method 或 protected_method。这两个方法只能在内部调用。

> 那 private 和 protected 有什么差别? protected 允许调用同一类的对象。private 则严格限制在内部调用。

为什么面向对象语言会设计这个功能呢？这是因为我们希望管控有哪些 public 方法。这些 public 是公开的 API 会给程序员调用的，如果有任何修改都会影响到软件的其他地方要一起修改。但是 private 但 protected 方法就只会影响这个对象的内部而已。

# 17. 特性一: 封装(encapsulation)

面向对象的其中一个特色就是封装，调用者不需要关心内部结构，只需根据公开接口进行操作。程式只依赖物件的公开接口，而不依赖内部结构。这样内部的结构可以根据架构需求而修改，而不会影响到其他程式。

我们看一个没有封装的例子，分数相加：

```
# 设计处理分数的相加，假设分子是 x、分母是 y


def add_rational_numerator(x1, y1, x2, y2)
    x1*y2 + x2*y1
end

def add_rational_denominator(x1, y1, x2, y2)
    y1*y2
end

# 2/3 + 3/4

x1 = 2
y1 = 3
x2 = 3
y2 = 4

answer_x = add_rational_numerator(x1, y1, x2, y2)
answer_y = add_rational_denominator(x1, y1, x2, y2)

puts "#{answer_x}/#{answer_y}"
```

分子、分母、算分母的方法、算分子的方法，都是分开的。

如果改用面向对象来写，首先定义分数的类：

```
class MyRational

  attr_accessor :x, :y

  def initialize(x, y)
    @x, @y = x, y
  end

  def add(target)
    MyRational.new(@x*target.y + @y*target.x, @y*target.y)
  end

end

# 2/3 + 3/4

a = MyRational.new(2,3)
b = MyRational.new(3,4)
c = a.add(b)

puts "#{c.x}/#{c.y}"
```

于是有关分数的数据和方法，都被一起封装到对象里面去了。这样就很清楚它们是相关的。

# 18. 特性二: 继承(inheritance)

继承可以让父类的定义都复制到子类，在 Ruby 中用 `class Child < Parent` 符号表示：

```
class Vehicle

  def move
    puts "vehicle move"
  end

end

class Car < Vehicle

  def foo
    puts "car foo"
  end

end

class Bike < Vehicle

  # overwrite
  def move
    puts "special bike move"
  end

  def foo
    puts "bike foo"
  end

end

car = Car.new
bike = Bike.new

car.move()
bike.move()

car.foo()
bike.foo()
```

`Vehicle` 类定义了 `move`方法，而 `Car` 跟 `Bike` 都继承自 `Vehicle`，因此他们也都有 `move` 方法。但是在 `Bike` 中你也可以复写掉 `move` 方法。

在 Rails 中也很常见继承，打开任一个 Model 档案，都是继承自 `ApplicationRecord`。再打开会发现 `ApplicationRecord` 继承自 `ActiveRecord::Base`。后者是 Rails 框架的核心类，我们之所以可以调用 `.save`、`.find`、`.where` 等等方法就是在 `ActiveRecord::Base` 中定义的。。

打开任一个 Controller 档案，都是继承自 `ApplicationController`，然后 `ApplicationController` 又是继承自 `ActionController::Base`，我们之所以可以调用 `before_action`、`render`、`redirect_to`等等方法就是在 `ActionController::Base` 中定义的。

透过继承，我们写的 Model 和 Controller 都是基于 Rails 已经写好的功能进行扩充而已。

### 多重继承

上述的写法只能单一继承，也就是只能有一个父类。如果有多个父类要继承，在 Ruby 中会用到 module：

```
module Ownership
  def show_owner
    puts "#{self.class} show_owner called"
  end
end

class Vehicle
  def move
    puts "move"
  end
end

# Car has two parents: Car and Ownership

class Car < Vehicle
  include Ownership
end

class House
  include Ownership
end

car = Car.new
house = House.new

car.show_owner()
house.show_owner()
```

其中 `module Ownership` 会用 `include` 的语法 mix-in(混入)到 `Car` 里面。

> 那 class 跟 module 有什么不一样？你不能实例化 module，也就是不能对 module 调用 `new` 方法来产生对象。

### module 命名空间

顺道一提 module 的另一个用途，就是拿来做命名空间，也就是让常数的命名长一点避免撞名：

```
module  A
  class B
  end
end
```

这个被 module A 包起来的 class B，如果要使用它要用 `A::B`。

如果 module A 已经定义过了，则可以这样写：

```
class A::C

end
```

假如在 module A 里面定义了一个跟最外层撞名的类，这时候如果要拿外层的类，需要加上 `::` 符号：

```
class Person
end

module A
  class Person
    def foo
      Person    # 这个会是指 A::Person
      ::Person  # 前面要加 :: 表示要拿最外层的 Person
    end
  end
end
```

最后，可以用 module 来定义模块方法：

```
module MyUtil

  def self.foobar
    puts "foobar"
  end

end

MyUtil.foobar
# 输出 foobar
```

Ruby 的 [Math API](https://ruby-doc.org/core-2.2.0/Math.html) 就是长这种形式。

# 19. 特性三: 多态(polymorphism)

多态的意思是可以把很多不一样的东西，当作同一种东西来处理。例如箱子有很多种，打开的实作方式各有不同(有的有锁、有的没锁)，但是这些箱子都有提供「打开」这个接口可以操作。下命令的人只需要知道呼叫这个指令即可。

先来示范一个不是面向对象的设计：

```
box1 = { :name => "Box1", :type => "locked" }
box2 = { :name => "Box2", :type => "unlocked"}
box3 = { :name => "Box3", :type => "seal" }

def open_box(box)
  if box[:type] == "locked"
    puts "Open locked"
  elsif box[:type] == "unlocked"
    puts "Open unlocked"
  elsif box[:type] == "seal"
    puts "Open Seal"
  end
end

arr = [box1, box2, box3]
arr.each do |x|
  open_box(x)
end
```

上述的代码中，有一个很厉害的 `open_box` 方法，在里面会判断不同的箱子调用不同的输出。这样设计的缺点是不好扩充，维护性低。因为无论是新增不同的箱子，或是修改某一个箱子打开的行为，都得修改同一个方法，复杂度全部集中在 `open_box` 之中。

让我们改用面向对象来写：

```
class Box
  attr_accessor :name

  def initialize(name)
    @name = name
  end

  def open
    puts "Open default box"
  end
end

class LockedBox < Box
  def open
    puts "Open locked"
  end
end

class UnlockedBox < Box
  def open
    puts "Open Unlocked"
  end
end

class SealBox < Box
  def open
    puts "Open seal"
  end
end

box1 = LockedBox.new("Box1")
box2 = UnlockedBox.new("Box2")
box3 = SealBox.new("Box3")

arr = [box1, box2, box3]
arr.each do |x|
  x.open()
end
```

代码看起来好像变多了，但是扩充性和维护性比较好。因为如果要新增不同的箱子，只需要新增类即可，不需要改到本来的代码。没有多型的话，单一函数就会充满根据数据类型的判断的 if-else，变得难以扩充。这种多型的特型让我们不需要担心确切的数据类型，只要接口一致(都有 open 方法)就可以操作

### 鸭子型别 Duck Typing

在动态语言中，不同对象只要方法的接口一样，就可以有多态的特型，这又叫做 [Duck Typing](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)：当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。

> 名词释疑：方法的「接口(Interface)」指的是方法的名称和参数，方法的「实作(Implement)」指的是方法内实际要做的代码。上述的 LockedBox、UnlockedBox 和 SealBox 都有一样的 open 接口，但是子类别中定义了不同的实作。

刚刚的 Box 例子是透过继承来达成多态，因为所有继承自 Box 的子类，都一定有 open 方法，自然是多态的。

# 20. 面向对象设计

到目前为止我们只是基本了解定义类的语法，以及认识了面向对象的三个特性。但是面对一个复杂的软件好像还是不知道怎么去设计要有哪些类？

别担心，作为应用程式开发的初学者，我们绝大部分需要的类设计，都由应用程式框架，也就是 Rails 提供了，只要照着框架的规范写程式即可，一开始不太需要自己设计全新的类别。随着大型专案的需求，才会逐步需要这方面的知识进行更好的程式架构调整。

> 这种不依赖框架，自己定义的对象，又叫作 Plain-Old Ruby Object

面向对象设计又是一门学问，有兴趣的学员，可以朝以下参考资源搜寻：

- [面向对象设计实践指南: Ruby 语言描述](https://book.douban.com/subject/25795276/) 人民邮电
- [SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) OO 设计原则
- [Design Patterns 设计模式](https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)，最有名的即 GoF patterns。设计模式针对了特定的情境，提供设计解法(通常是如何设计你的类别)，并且「命名」这些模式让程序员可以方便沟通和当作命名的元素。另一方面也是提供一种可以临摹的设计范例。常见的设计模式包括 Factory, Adapter, Composite, Decorator, Iterator, Observer 等等

例如以下是一个 Strategy Pattern 范例：情境是我们想要设计一个通用的数据输出功能，并且允许我们随时可以抽换不同的输出方式，例如 XML 或 JSON。

```
class AwesomeFormatter

  attr_accessor :data, :formatter

  def initialize(data, formatter)
    self.data = data
    self.formatter = formatter
  end

  def output
    puts self.formatter.output( self.data )
  end

end

class XMLFormatter
  def output(data)
    "<data>#{data}</data>"
  end
end

class JSONFormatter
  def output(data)
    "{ data: #{data} }"
  end
end


formatter = AwesomeFormatter.new( "ihower", XMLFormatter.new )

formatter.output() # 输出 XML 格式


formatter.formatter = JSONFormatter.new   # 动态更换不同的输出策略


formatter.output() # 输出 JSON 格式
```

在建构 `AwesomeFormatter.new` 时，第二个参数就是不同的策略，其中 `formatter` 属性就代表不同的输出方式。

透过这个 Strategy Pattern，我们可以随时抽换不同的输出方式。

#### 本节作业

##### [作业](https://fullstack.xinshengdaxue.com/assignments/67)：[作业二](https://fullstack.xinshengdaxue.com/tasks/354)

已有 14 个第一期同学提交了这个作业 [**看看同学怎么做](https://fullstack.xinshengdaxue.com/tasks/354/other_answers?order=recent)

[**提交作业](https://fullstack.xinshengdaxue.com/tasks/354)

请实作一个 class 是汽车，属性有名称 `name` 和型号 `modal`，都是字符串。以及出场年份 `year` 是日期。三个属性都有存取方法。

接着实作一个方法回传车子的年纪、一个方法是输出格式化的字符串是 "出场年份 型号 名称"。
